USE master;

--
-- FHSQLMonitor v2.9.1 - 2025.08.05 19.42.19
--

BEGIN
	--
	-- Installation parameters - They are used both during a fresh installation and during an update
	--
	DECLARE @createSQLAgentJob    bit           = 1;
	DECLARE @fhSQLMonitorDatabase nvarchar(128) = 'FHSQLMonitor';
	DECLARE @pbiSchema            nvarchar(128) = 'FHSM';

	--
	-- Service parameters - They are only used during a fresh installation and not during an update
	--   When updating the already configured values in the tables dbo.fhsmSchedules and dbo.fhsmRetentions remains unchanged
	--
	DECLARE @olaDatabase                    nvarchar(128) = NULL;
	DECLARE @blocksAndDeadlocksFilePath     nvarchar(260) = NULL;
	DECLARE @fhsqlAgentJobName              nvarchar(128) = 'FHSQLMonitor in ' + @fhSQLMonitorDatabase;

	DECLARE @enableAgentJobs                bit = 1;
	DECLARE @enableAgentJobsPerformance     bit = 1;
	DECLARE @enableAgeOfStatistics          bit = 1;
	DECLARE @enableBackupStatus             bit = 1;
	DECLARE @enableBlocksAndDeadlocks       bit = 1;
	DECLARE @enableCapacity                 bit = 1;
	DECLARE @enableConnections              bit = 1;
	DECLARE @enableCPUUtilization           bit = 1;
	DECLARE @enableDatabaseIO               bit = 1;
	DECLARE @enableDatabaseState            bit = 1;
	DECLARE @enableIndexOperational         bit = 1;
	DECLARE @enableIndexPhysical            bit = 1;
	DECLARE @enableIndexUsage               bit = 1;
	DECLARE @enableInstanceState            bit = 1;
	DECLARE @enableMissingIndexes           bit = 1;
	DECLARE @enablePerformanceStatistics    bit = 1;
	DECLARE @enablePlanCacheUsage           bit = 1;
	DECLARE @enablePlanGuides               bit = 1;
	DECLARE @enableQueryStatistics          bit = 1;
	DECLARE @enableTriggers                 bit = 1;
	DECLARE @enableWaitStatistics           bit = 1;
	DECLARE @enableWhoIsActive              bit = 1;
	DECLARE @enableIndexRebuild             bit = 0;
	DECLARE @enableIndexReorganize          bit = 0;
	DECLARE @enableUpdateAllStatistics      bit = 0;
	DECLARE @enableUpdateModifiedStatistics bit = 0;
END;

--
-- No need to change more from here on
--

DECLARE @currentAgentJobName nvarchar(128);
DECLARE @currentVersion nvarchar(128);
DECLARE @installationJobExecuting nvarchar(16);
DECLARE @installationJobStatus int;
DECLARE @installationMsg nvarchar(max);
DECLARE @installationNow datetime;
DECLARE @installationNowStr nvarchar(max);
DECLARE @installationWaitCnt int;
DECLARE @installUpgradeFlag int;
DECLARE @serverInfo nvarchar(max);
DECLARE @stmt nvarchar(max);

IF (DB_ID(@fhSQLMonitorDatabase) IS NULL)
BEGIN
	SET @installUpgradeFlag = 1;	-- 1: Install
END
ELSE BEGIN
	SET @installUpgradeFlag = 2;	-- 2: Upgrade

	SET @stmt = 'SET @currentVersion = ' + QUOTENAME(@fhSQLMonitorDatabase) + '.dbo.fhsmFNGetConfiguration(''Version'');';
	EXEC sp_executesql @stmt, N'@currentVersion nvarchar(128) OUTPUT', @currentVersion = @currentVersion OUTPUT;
	SET @currentVersion = COALESCE(@currentVersion, 'N.A.');

	SET @stmt = 'SET @currentAgentJobName = ' + QUOTENAME(@fhSQLMonitorDatabase) + '.dbo.fhsmFNGetConfiguration(''AgentJobName'');';
	EXEC sp_executesql @stmt, N'@currentAgentJobName nvarchar(128) OUTPUT', @currentAgentJobName = @currentAgentJobName OUTPUT;
	SET @fhsqlAgentJobName = COALESCE(@currentAgentJobName, @fhsqlAgentJobName);
END;

SET @serverInfo = @@SERVERNAME;

RAISERROR('', 0, 1) WITH NOWAIT;
SET @installationMsg = CASE @installUpgradeFlag WHEN 1 THEN 'Install version v2.9.1' + ' of' ELSE 'Upgrade' END + ' FHSQLMonitor in database ' + @fhSQLMonitorDatabase + ' on ' + @serverInfo + ' ' + CASE @installUpgradeFlag WHEN 1 THEN '' ELSE 'from ' + @currentVersion + ' to v2.9.1' END;
RAISERROR(@installationMsg, 0, 1) WITH NOWAIT;

--
-- Get job enabled status
--
BEGIN
	SET @installationJobStatus =
		COALESCE(
			(
				SELECT sj.enabled
				FROM msdb.dbo.sysjobs AS sj
				WHERE (sj.name = @fhsqlAgentJobName)
			),
			-1
		);

	IF (@installationJobStatus IN (0, 1))
	BEGIN
       RAISERROR('', 0, 1) WITH NOWAIT;
		SET @installationMsg = 'Agent job ' + QUOTENAME(@fhsqlAgentJobName) + ' is ' + CASE @installationJobStatus WHEN 1 THEN 'enabled' WHEN 0 THEN 'disabled' END;
		RAISERROR(@installationMsg, 0, 1) WITH NOWAIT;
	END;
END;

--
-- Disable job if enabled
--
IF (@installationJobStatus = 1)
BEGIN
   RAISERROR('', 0, 1) WITH NOWAIT;
	SET @installationMsg = 'Disabling job ' + QUOTENAME(@fhsqlAgentJobName);
	RAISERROR(@installationMsg, 0, 1) WITH NOWAIT;

	EXEC msdb.dbo.sp_update_job
		@job_name = @fhsqlAgentJobName,
		@enabled = 0;

	WAITFOR DELAY '00:00:10';
END;

--
-- Wait until job has stopped executing
--
BEGIN
	SET @installationWaitCnt = 0;

	SET @installationJobExecuting = 'Running';

	WHILE (@installationJobExecuting = 'Running')
	BEGIN
		SET @installationJobExecuting = (
			SELECT
				TOP 1
				CASE
					WHEN ja.job_id IS NOT NULL AND ja.stop_execution_date IS NULL THEN 'Running'
					WHEN jh.run_status = 0 THEN 'Failed'
					WHEN jh.run_status = 1 THEN 'Succeeded'
					WHEN jh.run_status = 2 THEN 'Retry'
					WHEN jh.run_status = 3 THEN 'Cancelled'
				END AS JobLastOutcome
			FROM msdb.dbo.sysjobs AS j
			LEFT JOIN msdb.dbo.sysjobactivity AS ja ON
				(ja.job_id = j.job_id)
				AND (ja.run_requested_date IS NOT NULL)
				AND (ja.start_execution_date IS NOT NULL)
			LEFT JOIN msdb.dbo.sysjobsteps AS js ON
				(js.job_id = ja.job_id)
				AND (js.step_id = ja.last_executed_step_id)
			LEFT JOIN msdb.dbo.sysjobhistory AS jh ON
				(jh.job_id = j.job_id)
				AND (jh.instance_id = ja.job_history_id)
			WHERE j.name = @fhsqlAgentJobName
			ORDER BY ja.start_execution_date DESC
		);

		IF (@installationJobExecuting = 'Running')
		BEGIN
			SET @installationWaitCnt = @installationWaitCnt + 1;

			SET @installationNow = GETDATE();
			SET @installationNowStr = CONVERT(nvarchar, @installationNow, 126);
			SET @installationNowStr = REPLACE(LEFT(@installationNowStr, LEN(@installationNowStr) - 4), 'T', ' ');

			SET @installationMsg = '  Waiting for job ' + QUOTENAME(@fhsqlAgentJobName) + ' to stop executing - #:' + CAST(@installationWaitCnt AS nvarchar) + ' - ' + @installationNowStr;
			RAISERROR(@installationMsg, 0, 1) WITH NOWAIT;

			WAITFOR DELAY '00:00:05';
		END;
	END;
END;

--
-- File part:_Install-FHSQLMonitor.sql modified: 2025.08.05 19.40.50
--
SET @stmt = '
SET NOCOUNT ON;

--
-- Default installations parameters
--
BEGIN
	DECLARE @createSQLAgentJob bit;
	DECLARE @fhsqlAgentJobName nvarchar(128);
	DECLARE @fhSQLMonitorDatabase nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @buildTimeStr nvarchar(128);

	SET @createSQLAgentJob = 1;
	SET @fhsqlAgentJobName = ''FHSQLMonitor in FHSQLMonitor'';
	SET @fhSQLMonitorDatabase = ''FHSQLMonitor'';
	SET @pbiSchema = ''FHSM'';
	SET @buildTimeStr = ''YYYY.MM.DD HH.MM.SS'';
END;

--
-- No need to change more from here on
--

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing FHSQLMonitor main'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);

	SET @myUserName = SUSER_NAME();
	SET @nowUTC = SYSUTCDATETIME();
	SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
	SET @version = ''2.9.1'';
END;

--
-- Only execute if we are in the master database
--
IF NOT ((SELECT DB_NAME()) = ''master'')
BEGIN
	RAISERROR(''Can not install as current database is not ''''master'''''', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Create database if it not already exists
	--
	IF NOT EXISTS (SELECT * FROM sys.databases AS d WHERE (d.name = @fhSQLMonitorDatabase))
	BEGIN
		SET @stmt = ''
			RAISERROR(''''Creating database '' + @fhSQLMonitorDatabase + '''''', 0, 1) WITH NOWAIT;

			CREATE DATABASE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
		'';
		EXEC(@stmt);

		SET @stmt = ''
			RAISERROR(''''Changing database '' + @fhSQLMonitorDatabase + '' to simple recovery mode'''', 0, 1) WITH NOWAIT;

			ALTER DATABASE '' + QUOTENAME(@fhSQLMonitorDatabase) + '' SET RECOVERY SIMPLE;
		'';
		EXEC(@stmt);
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPExtendedProperties
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPExtendedProperties'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPExtendedProperties'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPExtendedProperties AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPExtendedProperties
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPExtendedProperties'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPExtendedProperties(
							@objectType nvarchar(128)
							,@updateIfExists bit
							,@propertyName nvarchar(128)
							,@propertyValue sql_variant
							,@level0name nvarchar(128) = NULL
							,@level1name nvarchar(128) = NULL
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							DECLARE @message nvarchar(max);

							IF (@objectType = ''''''''Database'''''''')
							BEGIN
								IF NOT EXISTS (
									SELECT *
									FROM sys.extended_properties AS ep
									WHERE (ep.class = 0) AND (ep.name = @propertyName)
								)
								BEGIN
									EXEC sys.sp_addextendedproperty @name = @propertyName, @value = @propertyValue;
								END
								ELSE BEGIN
									IF (@updateIfExists = 1)
									BEGIN
										EXEC sys.sp_updateextendedproperty @name = @propertyName, @value = @propertyValue;
									END;
								END;
							END
							ELSE IF (@objectType = ''''''''Schema'''''''')
							BEGIN
								IF NOT EXISTS (
									SELECT *
									FROM sys.extended_properties AS ep
									WHERE (ep.class = 3) AND (ep.major_id = SCHEMA_ID(@level0name)) AND (ep.name = @propertyName)
								)
								BEGIN
									EXEC sys.sp_addextendedproperty @name = @propertyName, @level0type = ''''''''SCHEMA'''''''', @level0name = @level0name, @value = @propertyValue;
								END
								ELSE BEGIN
									IF (@updateIfExists = 1)
									BEGIN
										EXEC sys.sp_updateextendedproperty @name = @propertyName, @level0type = ''''''''SCHEMA'''''''', @level0name = @level0name, @value = @propertyValue;
									END;
								END;
							END
							ELSE IF (@objectType IN (''''''''Table'''''''', ''''''''View'''''''', ''''''''Function'''''''', ''''''''Procedure''''''''))
							BEGIN
								SET @objectType = UPPER(@objectType);

								IF NOT EXISTS (
									SELECT *
									FROM sys.extended_properties AS ep
									WHERE (ep.class = 1) AND (ep.major_id = OBJECT_ID(QUOTENAME(@level0name) + ''''''''.'''''''' + QUOTENAME(@level1name))) AND (ep.name = @propertyName)
								)
								BEGIN
									EXEC sys.sp_addextendedproperty @name = @propertyName, @level0type = ''''''''SCHEMA'''''''', @level0name = @level0name, @level1type = @objectType, @level1name = @level1name, @value = @propertyValue;
								END
								ELSE BEGIN
									IF (@updateIfExists = 1)
									BEGIN
										EXEC sys.sp_updateextendedproperty @name = @propertyName, @level0type = ''''''''SCHEMA'''''''', @level0name = @level0name, @level1type = @objectType, @level1name = @level1name, @value = @propertyValue;
									END;
								END;
							END
							ELSE BEGIN
								SET @message = ''''''''Unknown object type - '''''''''''''''''''''''' + @objectType + '''''''''''''''''''''''''''''''';
								PRINT @message;

								RETURN -1;
							END;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPExtendedProperties
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPExtendedProperties'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Register extended properties on the database
	--
	BEGIN
		SET @stmt = ''
			USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Database'''', @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Database'''', @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Database'''', @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Database'''', @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Database'''', @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
		'';
		EXEC sp_executesql
			@stmt
			,N''@version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
			,@version = @version
			,@nowUTCStr = @nowUTCStr
			,@myUserName = @myUserName;
	END;

	--
	-- Create ''PBI'' schema if it not already exists
	--
	BEGIN
		SET @stmt = ''
			USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

			DECLARE @stmt nvarchar(max);
			IF (SCHEMA_ID('''''' + @pbiSchema + '''''') IS NULL)
			BEGIN
				SET @stmt = ''''CREATE SCHEMA '' + QUOTENAME(@pbiSchema) + '';'''';
				EXEC(@stmt);
			END;
		'';
		EXEC(@stmt);
	END;

	--
	-- Register extended properties on the ''PBI'' schema
	--
	BEGIN
		SET @stmt = ''
			USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Schema'''', @level0name = @pbiSchema, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Schema'''', @level0name = @pbiSchema, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Schema'''', @level0name = @pbiSchema, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Schema'''', @level0name = @pbiSchema, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Schema'''', @level0name = @pbiSchema, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
		'';
		EXEC sp_executesql
			@stmt
			,N''@pbiSchema nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
			,@pbiSchema = @pbiSchema
			,@version = @version
			,@nowUTCStr = @nowUTCStr
			,@myUserName = @myUserName;
	END;

	--
	-- Create or alter function dbo.fhsmFNParseDimensionColumn
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNParseDimensionColumn'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNParseDimensionColumn'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNParseDimensionColumn() RETURNS nvarchar(128) AS BEGIN RETURN NULL; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNParseDimensionColumn
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNParseDimensionColumn'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNParseDimensionColumn(@column nvarchar(128))
						RETURNS nvarchar(128)
						AS
						BEGIN
							DECLARE @pos1 int;
							DECLARE @pos2 int;
							DECLARE @token nvarchar(128);

							SET @token = ''''''''CASE '''''''';
							IF (LEFT(@column, LEN(@token)) = @token)
							BEGIN
								SET @pos1 = CHARINDEX('''''''' '''''''', @column);
								SET @pos2 = CHARINDEX('''''''' '''''''', @column, @pos1 + 1);

								SET @column = SUBSTRING(@column, @pos1 + 1, @pos2 - @pos1 - 1);
							END;

							SET @token = ''''''''CAST('''''''';
							IF (LEFT(@column, LEN(@token)) = @token)
							BEGIN
								SET @pos1 = CHARINDEX('''''''' '''''''', @column);

								SET @column = SUBSTRING(@column, LEN(@token) + 1, @pos1 - LEN(@token) - 1);
							END;

							SET @token = ''''''''COALESCE('''''''';
							IF (LEFT(@column, LEN(@token)) = @token)
							BEGIN
								SET @pos1 = CHARINDEX('''''''','''''''', @column);

								SET @column = SUBSTRING(@column, LEN(@token) + 1, @pos1 - LEN(@token) - 1);
							END;

							SET @token = ''''''''CONVERT('''''''';
							IF (LEFT(@column, LEN(@token)) = @token)
							BEGIN
								SET @pos1 = CHARINDEX('''''''','''''''', @column);
								SET @pos2 = CHARINDEX('''''''','''''''', @column, @pos1 + 1);

								SET @column = SUBSTRING(@column, @pos1 + 1, @pos2 - @pos1 - 1);
							END;

							SET @column = LTRIM(RTRIM(@column));

							RETURN @column;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNParseDimensionColumn
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNParseDimensionColumn'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNTryParseAsInt
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNTryParseAsInt'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNTryParseAsInt'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNTryParseAsInt() RETURNS int AS BEGIN RETURN NULL; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNTryParseAsInt
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNTryParseAsInt'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNTryParseAsInt(@str nvarchar(128))
						RETURNS int
						AS
						BEGIN
							DECLARE @i int;
							DECLARE @chkFlg bit;
							DECLARE @retVal int;

							SET @chkFlg = 0;

							SET @str = LTRIM(RTRIM(@str));

							IF (@str IS NOT NULL)
							BEGIN
								IF (LEN(@str) > 0)
								BEGIN
									SET @i = 1;

									WHILE (@i <= LEN(@str))
									BEGIN
										IF NOT (SUBSTRING(@str, @i, 1) LIKE ''''''''[0-9]'''''''')
										BEGIN
											BREAK;
										END;

										SET @i += 1;

										IF (@i > LEN(@str))
										BEGIN
											SET @chkFlg = 1;
										END;
									END;
								END;
							END;

							IF (@chkFlg = 0)
							BEGIN
								SET @retVal = NULL;
							END
							ELSE BEGIN
								SET @retVal = CAST(@str AS int);
							END;

							RETURN @retVal;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNTryParseAsInt
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNTryParseAsInt'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @stmt = ''
			USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

			DECLARE @edition nvarchar(128);
			DECLARE @productEndPos int;
			DECLARE @productStartPos int;
			DECLARE @productVersion nvarchar(128);
			DECLARE @productVersion1 int;
			DECLARE @productVersion2 int;
			DECLARE @productVersion3 int;

			SET @tableCompressionStmt = '''''''';

			SET @edition = CAST(SERVERPROPERTY(''''Edition'''') AS nvarchar);

			SET @productVersion = CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar);

			SET @productStartPos = 1;
			SET @productEndPos = CHARINDEX(''''.'''', CAST(@productVersion AS nvarchar(128)) COLLATE DATABASE_DEFAULT, @productStartPos);
			SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

			SET @productStartPos = @productEndPos + 1;
			SET @productEndPos = CHARINDEX(''''.'''', CAST(@productVersion AS nvarchar(128)) COLLATE DATABASE_DEFAULT, @productStartPos);
			SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

			SET @productStartPos = @productEndPos + 1;
			SET @productEndPos = CHARINDEX(''''.'''', CAST(@productVersion AS nvarchar(128)) COLLATE DATABASE_DEFAULT, @productStartPos);
			SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

			IF (CAST(@edition AS nvarchar(128)) COLLATE DATABASE_DEFAULT = ''''SQL Azure'''')
				OR (SUBSTRING(CAST(@edition AS nvarchar(128)) COLLATE DATABASE_DEFAULT, 1, CHARINDEX('''' '''', CAST(@edition AS nvarchar(128)) COLLATE DATABASE_DEFAULT)) = ''''Developer'''')
				OR (SUBSTRING(CAST(@edition AS nvarchar(128)) COLLATE DATABASE_DEFAULT, 1, CHARINDEX('''' '''', CAST(@edition AS nvarchar(128)) COLLATE DATABASE_DEFAULT)) = ''''Enterprise'''')
				OR (@productVersion1 > 13)
				OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
				OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
			BEGIN
				SET @tableCompressionStmt = '''' WITH (DATA_COMPRESSION = PAGE)'''';
			END;
		'';
		EXEC sp_executesql
			@stmt
			,N''@tableCompressionStmt nvarchar(max) OUTPUT''
			,@tableCompressionStmt = @tableCompressionStmt OUTPUT;
	END;

	--
	-- Create table dbo.fhsmConfigurations and indexes if they not already exists
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF OBJECT_ID(''''dbo.fhsmConfigurations'''', ''''U'''') IS NULL
				BEGIN
					RAISERROR(''''Creating table dbo.fhsmConfigurations'''', 0, 1) WITH NOWAIT;

					CREATE TABLE dbo.fhsmConfigurations(
						Id int identity(1,1) NOT NULL
						,[Key] nvarchar(128) NOT NULL
						,Value nvarchar(128) NOT NULL
						,CONSTRAINT PK_fhsmConfigurations PRIMARY KEY([Key])'' + @tableCompressionStmt + ''
					);
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmConfigurations'''')) AND (i.name = ''''NC_fhsmConfigurations_Id''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmConfigurations_Id ON dbo.fhsmConfigurations(Id)'' + @tableCompressionStmt + '';
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmConfigurations
		--
		BEGIN
			SET @objectName = ''dbo.fhsmConfigurations'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Save installation data in dbo.fhsmConfigurations
	--
	BEGIN
		SET @stmt = ''
			USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

			WITH
			cfg([Key], Value) AS(
				SELECT
					''''PBISchema''''
					,'''''' + @pbiSchema + ''''''
			)
			MERGE dbo.fhsmConfigurations AS tgt
			USING cfg AS src ON (src.[Key] = tgt.[Key])
			WHEN MATCHED
				THEN UPDATE
					SET tgt.Value = src.Value
			WHEN NOT MATCHED BY TARGET
				THEN INSERT([Key], Value)
				VALUES(src.[Key], src.Value);

			WITH
			cfg([Key], Value) AS(
				SELECT
					''''Version''''
					,'''''' + CAST(@version AS nvarchar) + ''''''
			)
			MERGE dbo.fhsmConfigurations AS tgt
			USING cfg AS src ON (src.[Key] = tgt.[Key])
			WHEN MATCHED
				THEN UPDATE
					SET tgt.Value = src.Value
			WHEN NOT MATCHED BY TARGET
				THEN INSERT([Key], Value)
				VALUES(src.[Key], src.Value);

			WITH
			cfg([Key], Value) AS(
				SELECT
					''''BuildTime''''
					,'''''' + CAST(@buildTimeStr AS nvarchar) + ''''''
			)
			MERGE dbo.fhsmConfigurations AS tgt
			USING cfg AS src ON (src.[Key] = tgt.[Key])
			WHEN MATCHED
				THEN UPDATE
					SET tgt.Value = src.Value
			WHEN NOT MATCHED BY TARGET
				THEN INSERT([Key], Value)
				VALUES(src.[Key], src.Value);
		'';
		EXEC(@stmt);
	END;

	--
	-- Create table dbo.fhsmDimensions if it not already exists
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF OBJECT_ID(''''dbo.fhsmDimensions'''', ''''U'''') IS NULL
				BEGIN
					RAISERROR(''''Creating table dbo.fhsmDimensions'''', 0, 1) WITH NOWAIT;

					CREATE TABLE dbo.fhsmDimensions(
						Id int identity(1,1) NOT NULL
						,DimensionName nvarchar(128) NOT NULL
						,DimensionKey nvarchar(128) NOT NULL
						,SrcTable nvarchar(128) NOT NULL
						,SrcAlias nvarchar(128) NOT NULL
						,SrcWhere nvarchar(max) NULL
						,SrcDateColumn nvarchar(128) NOT NULL
						,SrcColumn1 nvarchar(128) NOT NULL
						,SrcColumn2 nvarchar(128) NULL
						,SrcColumn3 nvarchar(128) NULL
						,SrcColumn4 nvarchar(128) NULL
						,SrcColumn5 nvarchar(128) NULL
						,SrcColumn6 nvarchar(128) NULL
						,OutputColumn1 nvarchar(128) NOT NULL
						,OutputColumn2 nvarchar(128) NULL
						,OutputColumn3 nvarchar(128) NULL
						,OutputColumn4 nvarchar(128) NULL
						,OutputColumn5 nvarchar(128) NULL
						,OutputColumn6 nvarchar(128) NULL
						,CONSTRAINT PK_fhsmDimensions PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
						,CONSTRAINT UQ_fhsmDimensions_SrcTable_DimensionName UNIQUE(SrcTable, DimensionName)'' + @tableCompressionStmt + ''
					);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmDimensions
		--
		BEGIN
			SET @objectName = ''dbo.fhsmDimensions'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
		
		--
		-- Delete registration for DatabaseFileKey as it wil be changed by DatabaseIO and DatabaseSize
		--
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DELETE d
				FROM dbo.fhsmDimensions AS d
				WHERE (1 = 1)
					AND (d.DimensionKey = ''''DatabaseFileKey'''')
					AND (d.SrcColumn4 IS NULL);
			'';
			EXEC(@stmt);
		END;
	END;

	--
	-- Create table dbo.fhsmRetentions and indexes if they not already exists
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF OBJECT_ID(''''dbo.fhsmRetentions'''', ''''U'''') IS NULL
				BEGIN
					RAISERROR(''''Creating table dbo.fhsmRetentions'''', 0, 1) WITH NOWAIT;

					CREATE TABLE dbo.fhsmRetentions(
						Id int identity(1,1) NOT NULL
						,Enabled bit NOT NULL
						,TableName nvarchar(128) NOT NULL
						,Sequence tinyint NOT NULL
						,TimeColumn nvarchar(128) NOT NULL
						,IsUtc bit NOT NULL
						,Days int NOT NULL
						,Filter nvarchar(max) NULL
						,LastStartedUTC datetime NULL
						,LastExecutedUTC datetime NULL
						,CONSTRAINT PK_fhsmRetentions PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
						,CONSTRAINT UQ_fhsmRetentions_TableName_Sequence UNIQUE(TableName, Sequence)'' + @tableCompressionStmt + ''
					);
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmRetentions'''')) AND (i.name = ''''NC_fhsmRetentions_Enabled_TableName_Sequence''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmRetentions_Enabled_TableName_Sequence ON dbo.fhsmRetentions(Enabled, TableName, Sequence)'' + @tableCompressionStmt + '';
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmRetentions
		--
		BEGIN
			SET @objectName = ''dbo.fhsmRetentions'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create table dbo.fhsmLog and indexes if they not already exists
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF OBJECT_ID(''''dbo.fhsmLog'''', ''''U'''') IS NULL
				BEGIN
					RAISERROR(''''Creating table dbo.fhsmLog'''', 0, 1) WITH NOWAIT;

					CREATE TABLE dbo.fhsmLog(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,Version nvarchar(128) NULL
						,Task nvarchar(128) NOT NULL
						,Type nvarchar(16) NOT NULL
						,Message nvarchar(max) NOT NULL
						,TimestampUTC datetime NOT NULL CONSTRAINT DEF_fhsmLog_TimestampUTC DEFAULT (SYSUTCDATETIME())
						,Timestamp datetime NOT NULL CONSTRAINT DEF_fhsmLog_Timestamp DEFAULT (SYSDATETIME())
						,CONSTRAINT PK_fhsmLog PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmLog'''')) AND (i.name = ''''NC_fhsmLog_TimestampUTC''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmLog_TimestampUTC ON dbo.fhsmLog(TimestampUTC)'' + @tableCompressionStmt + '';
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmLog'''')) AND (i.name = ''''NC_fhsmLog_Timestamp''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmLog_Timestamp ON dbo.fhsmLog(Timestamp)'' + @tableCompressionStmt + '';
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmLog'''')) AND (i.name = ''''NC_fhsmLog_Type_Timestamp''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmLog_Type_Timestamp ON dbo.fhsmLog(Type, Timestamp)'' + @tableCompressionStmt + '';
				END;

				IF EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmLog'''')) AND (i.name = ''''NCAuto_fhsmLog_Task_Name''''))
				BEGIN
					DROP INDEX NCAuto_fhsmLog_Task_Name ON dbo.fhsmLog;
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmLog'''')) AND (i.name = ''''NC_fhsmLog_Task_Name_Version''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmLog_Task_Name_Version ON dbo.fhsmLog(Task, Name, Version)'' + @tableCompressionStmt + '';
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmLog
		--
		BEGIN
			SET @objectName = ''dbo.fhsmLog'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;

		--
		-- Register retention for dbo.fhsmLog
		--
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				WITH
				retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
					SELECT
						1
						,''''dbo.fhsmLog''''
						,1
						,''''TimestampUTC''''
						,1
						,30
						,NULL
				)
				MERGE dbo.fhsmRetentions AS tgt
				USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
				WHEN NOT MATCHED BY TARGET
					THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
					VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);

				WITH
				retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
					SELECT
						1
						,''''dbo.fhsmLog''''
						,2
						,''''TimestampUTC''''
						,1
						,7
						,''''Type = ''''''''Debug''''''''''''
				)
				MERGE dbo.fhsmRetentions AS tgt
				USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
				WHEN NOT MATCHED BY TARGET
					THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
					VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
			'';
			EXEC(@stmt);
		END;
	END;

	--
	-- Create table dbo.fhsmProcessing and indexes if they not already exists
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF OBJECT_ID(''''dbo.fhsmProcessing'''', ''''U'''') IS NULL
				BEGIN
					RAISERROR(''''Creating table dbo.fhsmProcessing'''', 0, 1) WITH NOWAIT;

					CREATE TABLE dbo.fhsmProcessing(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,Task nvarchar(128) NOT NULL
						,Version nvarchar(128) NULL
						,Type int NOT NULL
						,StartedTimestampUTC datetime NOT NULL
						,StartedTimestamp datetime NOT NULL
						,EndedTimestampUTC datetime NULL
						,EndedTimestamp datetime NULL
						,CONSTRAINT PK_fhsmProcessing PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmProcessing'''')) AND (i.name = ''''NC_fhsmProcessing_StartedTimestampUTC''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmProcessing_StartedTimestampUTC ON dbo.fhsmProcessing(StartedTimestampUTC)'' + @tableCompressionStmt + '';
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmProcessing'''')) AND (i.name = ''''NC_fhsmProcessing_StartedTimestamp''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmProcessing_StartedTimestamp ON dbo.fhsmProcessing(StartedTimestamp)'' + @tableCompressionStmt + '';
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmProcessing'''')) AND (i.name = ''''NC_fhsmProcessing_Task_Name_Version''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmProcessing_Task_Name_Version ON dbo.fhsmProcessing(Task, Name, Version)'' + @tableCompressionStmt + '';
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmProcessing
		--
		BEGIN
			SET @objectName = ''dbo.fhsmProcessing'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;

		--
		-- Register retention for dbo.fhsmProcessing
		--
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				WITH
				retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
					SELECT
						1
						,''''dbo.fhsmProcessing''''
						,1
						,''''StartedTimestampUTC''''
						,1
						,90
						,NULL
				)
				MERGE dbo.fhsmRetentions AS tgt
				USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
				WHEN NOT MATCHED BY TARGET
					THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
					VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
			'';
			EXEC(@stmt);
		END;
	END;

	--
	-- Create table dbo.fhsmSchedules and indexes if they not already exists
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF OBJECT_ID(''''dbo.fhsmSchedules'''', ''''U'''') IS NULL
				BEGIN
					RAISERROR(''''Creating table dbo.fhsmSchedules'''', 0, 1) WITH NOWAIT;

					CREATE TABLE dbo.fhsmSchedules(
						Id int identity(1,1) NOT NULL
						,Enabled bit NOT NULL
						,DeploymentStatus int NOT NULL CONSTRAINT DEF_fhsmSchedules_DeploymentStatus DEFAULT 0
						,Name nvarchar(128) NOT NULL
						,Task nvarchar(128) NOT NULL
						,Parameter nvarchar(max) NULL
						,ExecutionDelaySec int NOT NULL
						,FromTime time(0) NOT NULL
						,ToTime time(0) NOT NULL
						,Monday bit NOT NULL
						,Tuesday bit NOT NULL
						,Wednesday bit NOT NULL
						,Thursday bit NOT NULL
						,Friday bit NOT NULL
						,Saturday bit NOT NULL
						,Sunday bit NOT NULL
						,LastStartedUTC datetime NULL
						,LastExecutedUTC datetime NULL
						,LastErrorMessage nvarchar(max) NULL
						,CONSTRAINT PK_fhsmSchedules PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
						,CONSTRAINT UQ_fhsmSchedules_Name UNIQUE(Name)'' + @tableCompressionStmt + ''
					);
				END;

				IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''''dbo.fhsmSchedules'''')) AND (i.name = ''''NC_fhsmSchedules_Enabled_Name''''))
				BEGIN
					CREATE NONCLUSTERED INDEX NC_fhsmSchedules_Enabled_Name ON dbo.fhsmSchedules(Enabled, Name)'' + @tableCompressionStmt + '';
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column DeploymentStatus to table dbo.fhsmSchedules if it not already exists
		--
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''''dbo.fhsmSchedules'''')) AND (c.name = ''''DeploymentStatus''''))
				BEGIN
					RAISERROR(''''Adding column [DeploymentStatus] to table dbo.fhsmSchedules'''', 0, 1) WITH NOWAIT;

					ALTER TABLE dbo.fhsmSchedules
						ADD DeploymentStatus int NOT NULL CONSTRAINT DEF_fhsmSchedules_DeploymentStatus DEFAULT 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Rename column Parameters on table dbo.fhsmSchedules to Parameter
		--
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				IF EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''''dbo.fhsmSchedules'''')) AND (c.name = ''''Parameters''''))
				BEGIN
					RAISERROR(''''Renaming column [Parameters] on table dbo.fhsmSchedules to [Parameter]'''', 0, 1) WITH NOWAIT;

					EXEC sp_rename ''''dbo.fhsmSchedules.Parameters'''', ''''Parameter'''', ''''COLUMN'''';
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmSchedules
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSchedules'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Table'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNAgentJobTime
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNAgentJobTime'''', ''''IF'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNAgentJobTime'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNAgentJobTime() RETURNS TABLE AS RETURN (SELECT ''''''''dummy'''''''' AS Txt);'''');
				END;

				--
				-- Alter dbo.fhsmFNAgentJobTime
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNAgentJobTime'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNAgentJobTime(
							@date int
							,@time int
							,@duration int
						)
						RETURNS TABLE AS RETURN
						(
							SELECT
								CONVERT(
									datetime,
									(CAST((@date / 10000) AS nvarchar)							-- years
									+ ''''''''-''''''''
									+ RIGHT(''''''''0'''''''' + CAST((@date % 10000 / 100) AS nvarchar), 2)	-- months
									+ ''''''''-''''''''
									+ RIGHT(''''''''0'''''''' + CAST((@date % 100) AS nvarchar), 2)			-- days
									+ ''''''''T''''''''
									+ RIGHT(''''''''0'''''''' + CAST((@time / 10000) AS nvarchar), 2)			-- hours
									+ '''''''':''''''''
									+ RIGHT(''''''''0'''''''' + CAST((@time % 10000 / 100) AS nvarchar), 2)	-- minutes
									+ '''''''':''''''''
									+ RIGHT(''''''''0'''''''' + CAST((@time % 100) AS nvarchar), 2))			-- seconds
									,126
								) AS StartDateTime
								,(@duration / 10000) * 3600			-- convert hours to seconds, can be greater than 24
									+ ((@duration % 10000) / 100) * 60	-- convert minutes to seconds
									+ (@duration % 100) AS DurationSeconds
						);
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNAgentJobTime
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNAgentJobTime'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNGenerateKey
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @productEndPos int;
				DECLARE @productStartPos int;
				DECLARE @productVersion nvarchar(128);
				DECLARE @productVersion1 int;
				DECLARE @productVersion2 int;
				DECLARE @productVersion3 int;
				DECLARE @stmt nvarchar(max);

				--
				-- Initialize variables
				--
				BEGIN
					SET @productVersion = CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar);
					SET @productStartPos = 1;
					SET @productEndPos = CHARINDEX(''''.'''', @productVersion, @productStartPos);
					SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
					SET @productStartPos = @productEndPos + 1;
					SET @productEndPos = CHARINDEX(''''.'''', @productVersion, @productStartPos);
					SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
					SET @productStartPos = @productEndPos + 1;
					SET @productEndPos = CHARINDEX(''''.'''', @productVersion, @productStartPos);
					SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
				END;

				IF OBJECT_ID(''''dbo.fhsmFNGenerateKey'''', ''''IF'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNGenerateKey'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNGenerateKey() RETURNS TABLE AS RETURN (SELECT ''''''''dummy'''''''' AS Txt);'''');
				END;

				--
				-- Alter dbo.fhsmFNGenerateKey
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNGenerateKey'''', 0, 1) WITH NOWAIT;
			
					IF (@productVersion1 <= 10)
					BEGIN
						-- SQL Versions SQL2008R2 or lower

						SET @stmt = ''''
							ALTER FUNCTION dbo.fhsmFNGenerateKey(
								@p1 nchar(128) = NULL
								,@p2 nchar(128) = NULL
								,@p3 nchar(128) = NULL
								,@p4 nchar(128) = NULL
								,@p5 nchar(128) = NULL
								,@p6 nchar(128) = NULL
							)
							RETURNS TABLE AS RETURN
							(
								SELECT CONVERT(
									bigint
									,HASHBYTES(
										''''''''SHA1''''''''
										 ,ISNULL(CAST(UPPER(@p1) AS nvarchar(128)), '''''''''''''''')
										+ ISNULL(CAST(UPPER(@p2) AS nvarchar(128)), '''''''''''''''')
										+ ISNULL(CAST(UPPER(@p3) AS nvarchar(128)), '''''''''''''''')
										+ ISNULL(CAST(UPPER(@p4) AS nvarchar(128)), '''''''''''''''')
										+ ISNULL(CAST(UPPER(@p5) AS nvarchar(128)), '''''''''''''''')
										+ ISNULL(CAST(UPPER(@p6) AS nvarchar(128)), '''''''''''''''')
									)
									,2
								) AS [Key]
							);
						'''';
						EXEC(@stmt);
					END
					ELSE BEGIN
						-- SQL Versions SQL2012 or higher

						SET @stmt = ''''
							ALTER FUNCTION dbo.fhsmFNGenerateKey(
								@p1 nchar(128) = NULL
								,@p2 nchar(128) = NULL
								,@p3 nchar(128) = NULL
								,@p4 nchar(128) = NULL
								,@p5 nchar(128) = NULL
								,@p6 nchar(128) = NULL
							)
							RETURNS TABLE AS RETURN
							(
								SELECT CONVERT(
									bigint
									,HASHBYTES(
										''''''''SHA2_256''''''''
										,CONCAT(
											UPPER(@p1)
											,UPPER(@p2)
											,UPPER(@p3)
											,UPPER(@p4)
											,UPPER(@p5)
											,UPPER(@p6)
										)
									)
									,2
								) AS [Key]
							);
						'''';
						EXEC(@stmt);
					END;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNGenerateKey
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNGenerateKey'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNGetConfiguration
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNGetConfiguration'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNGetConfiguration'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNGetConfiguration() RETURNS bit AS BEGIN RETURN 0; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNGetConfiguration
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNGetConfiguration'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNGetConfiguration(
							@key nvarchar(128)
						)
						RETURNS nvarchar(128)
						AS
						BEGIN
							DECLARE @value nvarchar(128);

							SET @value = (
								SELECT c.Value
								FROM dbo.fhsmConfigurations AS c
								WHERE (c.[Key] = @key)
							);

							RETURN @value;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNGetConfiguration
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNGetConfiguration'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNConvertToDisplayTxt
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNConvertToDisplayTxt'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNConvertToDisplayTxt'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNConvertToDisplayTxt() RETURNS bit AS BEGIN RETURN 0; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNConvertToDisplayTxt
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNConvertToDisplayTxt'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNConvertToDisplayTxt(
							@txt nvarchar(128)
						)
						RETURNS nvarchar(128)
						AS
						BEGIN
							RETURN UPPER(LEFT(@txt, 1)) + SUBSTRING(REPLACE(LOWER(@txt), ''''''''_'''''''', '''''''' ''''''''), 2, LEN(@txt));
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNConvertToDisplayTxt
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNConvertToDisplayTxt'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNGetTaskParameter
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNGetTaskParameter'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNGetTaskParameter'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNGetTaskParameter() RETURNS bit AS BEGIN RETURN 0; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNGetTaskParameter
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNGetTaskParameter'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNGetTaskParameter(
							@task nvarchar(128)
							,@name nvarchar(128)
						)
						RETURNS nvarchar(max)
						AS
						BEGIN
							DECLARE @parameter nvarchar(max);

							SET @parameter = (
								SELECT s.Parameter
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @task) AND (s.Name = @name)
							);

							RETURN @parameter;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNGetTaskParameter
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNGetTaskParameter'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNGetExecutionDelaySec
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNGetExecutionDelaySec'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNGetExecutionDelaySec'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNGetExecutionDelaySec() RETURNS bit AS BEGIN RETURN 0; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNGetExecutionDelaySec
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNGetExecutionDelaySec'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNGetExecutionDelaySec(
							@task nvarchar(128)
							,@name nvarchar(128)
						)
						RETURNS int
						AS
						BEGIN
							DECLARE @executionDelaySec nvarchar(max);

							SET @executionDelaySec = (
								SELECT s.ExecutionDelaySec
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @task) AND (s.Name = @name)
							);

							RETURN @executionDelaySec;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNGetExecutionDelaySec
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNGetExecutionDelaySec'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNIsValidInstallation
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNIsValidInstallation'''', ''''FN'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNIsValidInstallation'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNIsValidInstallation() RETURNS bit AS BEGIN RETURN 0; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNIsValidInstallation
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNIsValidInstallation'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNIsValidInstallation()
						RETURNS bit
						AS
						BEGIN
							DECLARE @checkCount int;
							DECLARE @retVal bit;

							SET @checkCount = (
								SELECT COUNT(*)
								FROM (
									SELECT ep.name
									FROM sys.extended_properties AS ep
									CROSS APPLY (SELECT o.name, o.schema_id FROM sys.objects AS o WHERE (o.object_id = ep.major_id)) AS Object
									CROSS APPLY (SELECT sch.name FROM sys.schemas AS sch WHERE (sch.schema_id = Object.schema_id)) AS [Schema]
									WHERE (ep.class = 1) AND (ep.name = ''''''''FHSMVersion'''''''')
										AND ([Schema].name = ''''''''dbo'''''''')
										AND (Object.name IN (
											 ''''''''fhsmConfigurations'''''''',       ''''''''fhsmDimensions'''''''',             ''''''''fhsmLog'''''''',                ''''''''fhsmProcessing'''''''',             ''''''''fhsmRetentions''''''''
											,''''''''fhsmSchedules'''''''',            ''''''''fhsmSPAgentJobControl'''''''',      ''''''''fhsmSPCleanup'''''''',          ''''''''fhsmSPControl'''''''',              ''''''''fhsmSPControlCleanup''''''''
											,''''''''fhsmSPExtendedProperties'''''''', ''''''''fhsmSPLog'''''''',                  ''''''''fhsmSPProcessing'''''''',       ''''''''fhsmSPSchedules'''''''',            ''''''''fhsmSPUpdateDimensions''''''''
											,''''''''fhsmFNAgentJobTime'''''''',       ''''''''fhsmFNGenerateKey'''''''',          ''''''''fhsmFNGetConfiguration'''''''', ''''''''fhsmFNGetExecutionDelaySec'''''''', ''''''''fhsmFNGetTaskParameter''''''''
											,''''''''fhsmFNParseDatabasesStr'''''''',  ''''''''fhsmFNParseDimensionColumn'''''''', ''''''''fhsmFNSplitString'''''''',      ''''''''fhsmFNTryParseAsInt''''''''
										))
								) AS a
							);

							SET @retVal = CASE WHEN (@checkCount <> 24) THEN 0 ELSE 1 END;

							RETURN @retVal;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNIsValidInstallation
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNIsValidInstallation'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNParseDatabasesStr
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNParseDatabasesStr'''', ''''TF'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNParseDatabasesStr'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNParseDatabasesStr() RETURNS @dummy TABLE(A int) AS BEGIN RETURN; END;'''');
				END;

				--
				-- Alter dbo.fhsmFNParseDatabasesStr
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNParseDatabasesStr'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNParseDatabasesStr(
							@databases nvarchar(max)
						)
						RETURNS
							@dbTable TABLE(
								DatabaseName nvarchar(128)
								,[Order] int
							)
						AS
						BEGIN
			'';
			SET @stmt += ''
							DECLARE @selectedDatabases TABLE(DatabaseName nvarchar(128), DatabaseType nvarchar(1), StartPosition int, Selected bit);
							DECLARE @stringDelimiter nvarchar(max) = '''''''','''''''';
							DECLARE @tmpDatabases TABLE(Id int identity, DatabaseName nvarchar(128), DatabaseType nvarchar(1), StartPosition int, [Order] int, Selected bit, PRIMARY KEY(Selected, [Order], Id));

							-- Remove CR-LF if they exists in the input
							SET @databases = REPLACE(@databases, char(10), '''''''''''''''');
							SET @databases = REPLACE(@databases, char(13), '''''''''''''''');

							-- Remove any spaces after delimiter
							WHILE (CHARINDEX(@stringDelimiter + '''''''' '''''''', @databases) > 0)
							BEGIN
								SET @databases = REPLACE(@databases, @stringDelimiter + '''''''' '''''''', @stringDelimiter);
							END;

							-- Remove any spaces before delimiter
							WHILE (CHARINDEX('''''''' '''''''' + @stringDelimiter, @databases) > 0)
							BEGIN
								SET @databases = REPLACE(@databases, '''''''' '''''''' + @stringDelimiter, @stringDelimiter);
							END;

							-- Trim leading and trailing spaces away
							SET @databases = LTRIM(RTRIM(@databases));
			'';
			SET @stmt += ''

							-- Split the @databases parameter into individual items
							WITH
							Databases1 AS (
								SELECT
									1 AS StartPosition
									,ISNULL(NULLIF(CHARINDEX(@stringDelimiter, @databases, 1), 0), LEN(@databases) + 1) AS EndPosition
									,SUBSTRING(@databases, 1, ISNULL(NULLIF(CHARINDEX(@stringDelimiter, @databases, 1), 0), LEN(@databases) + 1) - 1) AS DatabaseItem
								WHERE @databases IS NOT NULL

								UNION ALL

								SELECT
									CAST(EndPosition AS int) + 1 AS StartPosition
									,ISNULL(NULLIF(CHARINDEX(@stringDelimiter, @databases, EndPosition + 1), 0), LEN(@databases) + 1) AS EndPosition
									,SUBSTRING(@databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@stringDelimiter, @databases, EndPosition + 1), 0), LEN(@databases) + 1) - EndPosition - 1) AS DatabaseItem
								FROM Databases1
								WHERE EndPosition < LEN(@databases) + 1
							)
							,Databases2 AS (
								SELECT
									CASE WHEN DatabaseItem LIKE ''''''''-%'''''''' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem
									,StartPosition
									,CASE WHEN DatabaseItem LIKE ''''''''-%'''''''' THEN 0 ELSE 1 END AS Selected
								FROM Databases1
							)
							,Databases3 AS (
								SELECT
									CASE WHEN DatabaseItem IN(''''''''ALL_DATABASES'''''''', ''''''''SYSTEM_DATABASES'''''''', ''''''''USER_DATABASES'''''''') THEN ''''''''%'''''''' ELSE DatabaseItem END AS DatabaseItem
									,CASE WHEN DatabaseItem = ''''''''SYSTEM_DATABASES'''''''' THEN ''''''''S'''''''' WHEN DatabaseItem = ''''''''USER_DATABASES'''''''' THEN ''''''''U'''''''' ELSE NULL END AS DatabaseType
									,StartPosition
									,Selected
								FROM Databases2
							)
							,Databases4 AS (
								SELECT
									CASE WHEN LEFT(DatabaseItem,1) = ''''''''['''''''' AND RIGHT(DatabaseItem,1) = '''''''']'''''''' THEN PARSENAME(DatabaseItem, 1) ELSE DatabaseItem END AS DatabaseName
									,DatabaseType
									,StartPosition
									,Selected
								FROM Databases3
							)
							INSERT INTO @selectedDatabases(DatabaseName, DatabaseType, StartPosition, Selected)
							SELECT DatabaseName, DatabaseType, StartPosition, Selected
							FROM Databases4
							OPTION (MAXRECURSION 0);
			'';
			SET @stmt += ''

							-- Insert databases on the server into @tmpDatabases
							INSERT INTO @tmpDatabases(DatabaseName, DatabaseType, [Order], Selected)
							SELECT
								d.name AS DatabaseName
								,CASE WHEN name IN(''''''''master'''''''', ''''''''msdb'''''''', ''''''''model'''''''', ''''''''tempdb'''''''') OR is_distributor = 1 THEN ''''''''S'''''''' ELSE ''''''''U'''''''' END AS DatabaseType
								,0 AS [Order]
								,0 AS Selected
							FROM sys.databases AS d
							WHERE (d.source_database_id IS NULL)
							ORDER BY d.name ASC;

							-- Update @tmpDatabases with the list of those that are selected
							UPDATE tmpDatabases
							SET tmpDatabases.Selected = SelectedDatabases.Selected
							FROM @tmpDatabases AS tmpDatabases
							INNER JOIN @selectedDatabases AS SelectedDatabases
								ON (tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName, ''''''''_'''''''', ''''''''[_]''''''''))
								AND ((tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType) OR (SelectedDatabases.DatabaseType IS NULL))
							WHERE (SelectedDatabases.Selected = 1);

							-- Update @tmpDatabases with the list of those that are de-selected
							UPDATE tmpDatabases
							SET tmpDatabases.Selected = SelectedDatabases.Selected
							FROM @tmpDatabases AS tmpDatabases
							INNER JOIN @selectedDatabases AS SelectedDatabases
								ON (tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName, ''''''''_'''''''', ''''''''[_]''''''''))
								AND ((tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType) OR (SelectedDatabases.DatabaseType IS NULL))
							WHERE (SelectedDatabases.Selected = 0);
			'';
			SET @stmt += ''

							-- Update @tmpDatabases StartPosition according to the position the databases are in @databases
							UPDATE tmpDatabases
							SET tmpDatabases.StartPosition = SelectedDatabases2.StartPosition
							FROM @tmpDatabases AS tmpDatabases
							INNER JOIN (
								SELECT
									tmpDatabases.DatabaseName
									,MIN(SelectedDatabases.StartPosition) AS StartPosition
								FROM @tmpDatabases AS tmpDatabases
								INNER JOIN @selectedDatabases AS SelectedDatabases
									ON (tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName, ''''''''_'''''''', ''''''''[_]''''''''))
									AND ((tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType) OR (SelectedDatabases.DatabaseType IS NULL))
								WHERE (SelectedDatabases.Selected = 1)
								GROUP BY tmpDatabases.DatabaseName
							) AS SelectedDatabases2
							ON (tmpDatabases.DatabaseName = SelectedDatabases2.DatabaseName);

							-- Update @tmpDatabases Order based upon the StartPosition
							WITH
							tmpDatabases AS (
								SELECT
									DatabaseName
									,[Order]
									,ROW_NUMBER() OVER (ORDER BY StartPosition ASC, DatabaseName ASC) AS RowNumber
								FROM @tmpDatabases AS tmpDatabases
								WHERE (Selected = 1)
							)
							UPDATE tmpDatabases
							SET [Order] = RowNumber;

							-- Insert data into the result table
							INSERT INTO @dbTable(DatabaseName, [Order])
							SELECT td.DatabaseName, td.[Order]
							FROM @tmpDatabases AS td
							WHERE (td.Selected = 1);

							RETURN;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNParseDatabasesStr
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNParseDatabasesStr'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter function dbo.fhsmFNSplitString
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmFNSplitString'''', ''''IF'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub function dbo.fhsmFNSplitString'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE FUNCTION dbo.fhsmFNSplitString() RETURNS TABLE AS RETURN (SELECT ''''''''dummy'''''''' AS Txt);'''');
				END;

				--
				-- Alter dbo.fhsmFNSplitString
				--
				BEGIN
					RAISERROR(''''Alter function dbo.fhsmFNSplitString'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER FUNCTION dbo.fhsmFNSplitString(
							@string nvarchar(max)
							,@delimiter nvarchar(max)
						)
						RETURNS TABLE AS RETURN
						(
							SELECT
								ROW_NUMBER() OVER(ORDER BY(SELECT NULL)) AS Part
								,LTRIM(RTRIM(Split.a.value(''''''''.'''''''', ''''''''nvarchar(max)''''''''))) AS Txt
							FROM (
								SELECT CAST(''''''''<X>'''''''' + REPLACE(@string, @delimiter, ''''''''</X><X>'''''''') + ''''''''</X>'''''''' AS XML) AS String
							) AS a
							CROSS APPLY String.nodes(''''''''/X'''''''') AS Split(a)
						);
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the function dbo.fhsmFNSplitString
		--
		BEGIN
			SET @objectName = ''dbo.fhsmFNSplitString'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Function'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPAgentJobControl
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPAgentJobControl'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPAgentJobControl'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPAgentJobControl AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPAgentJobControl
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPAgentJobControl'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPAgentJobControl(
							@command nvarchar(8),
							@jobStatus int OUTPUT
						)
						AS
						BEGIN
							SET NOCOUNT ON;
			'';
			SET @stmt += ''
							DECLARE @jobExecuting nvarchar(16);
							DECLARE @jobName nvarchar(128);
							DECLARE @message nvarchar(max);
							DECLARE @now datetime;
							DECLARE @nowStr nvarchar(max);
							DECLARE @waitCnt int;

							SET @jobName = dbo.fhsmFNGetConfiguration(''''''''AgentJobName'''''''');

							--
							-- Get job enabled status
							--
							BEGIN
								SET @jobStatus =
									COALESCE(
										(
											SELECT sj.enabled
											FROM msdb.dbo.sysjobs AS sj
											WHERE (sj.name = @jobName)
										),
										-1
									);

								IF (@jobStatus IN (0, 1))
								BEGIN
								   RAISERROR('''''''''''''''', 0, 1) WITH NOWAIT;
									SET @message = ''''''''Agent job '''''''' + QUOTENAME(@jobName) + '''''''' is '''''''' + CASE @jobStatus WHEN 1 THEN ''''''''enabled'''''''' WHEN 0 THEN ''''''''disabled'''''''' END;
									RAISERROR(@message, 0, 1) WITH NOWAIT;
								END;
							END;

							IF (@command = ''''''''Disable'''''''')
							BEGIN
								--
								-- Disable job if enabled
								--
								IF (@jobStatus = 1)
								BEGIN
									RAISERROR('''''''''''''''', 0, 1) WITH NOWAIT;
									SET @message = ''''''''Disabling job '''''''' + QUOTENAME(@jobName);
									RAISERROR(@message, 0, 1) WITH NOWAIT;

									EXEC msdb.dbo.sp_update_job
										@job_name = @jobName,
										@enabled = 0;

									WAITFOR DELAY ''''''''00:00:10'''''''';
								END;

								--
								-- Wait until job has stopped executing
								--
								BEGIN
									SET @waitCnt = 0;

									SET @jobExecuting = ''''''''Running'''''''';

									WHILE (@jobExecuting = ''''''''Running'''''''')
									BEGIN
										SET @jobExecuting = (
											SELECT
												TOP 1
												CASE
													WHEN ja.job_id IS NOT NULL AND ja.stop_execution_date IS NULL THEN ''''''''Running''''''''
													WHEN jh.run_status = 0 THEN ''''''''Failed''''''''
													WHEN jh.run_status = 1 THEN ''''''''Succeeded''''''''
													WHEN jh.run_status = 2 THEN ''''''''Retry''''''''
													WHEN jh.run_status = 3 THEN ''''''''Cancelled''''''''
												END AS JobLastOutcome
											FROM msdb.dbo.sysjobs AS j
											LEFT JOIN msdb.dbo.sysjobactivity AS ja ON
												(ja.job_id = j.job_id)
												AND (ja.run_requested_date IS NOT NULL)
												AND (ja.start_execution_date IS NOT NULL)
											LEFT JOIN msdb.dbo.sysjobsteps AS js ON
												(js.job_id = ja.job_id)
												AND (js.step_id = ja.last_executed_step_id)
											LEFT JOIN msdb.dbo.sysjobhistory AS jh ON
												(jh.job_id = j.job_id)
												AND (jh.instance_id = ja.job_history_id)
											WHERE j.name = @jobName
											ORDER BY ja.start_execution_date DESC
										);

										IF (@jobExecuting = ''''''''Running'''''''')
										BEGIN
											SET @waitCnt = @waitCnt + 1;

											SET @now = GETDATE();
											SET @nowStr = CONVERT(nvarchar, @now, 126);
											SET @nowStr = REPLACE(LEFT(@nowStr, LEN(@nowStr) - 4), ''''''''T'''''''', '''''''' '''''''');

											SET @message = ''''''''  Waiting for job '''''''' + QUOTENAME(@jobName) + '''''''' to stop executing - #:'''''''' + CAST(@waitCnt AS nvarchar) + '''''''' - '''''''' + @nowStr;
											RAISERROR(@message, 0, 1) WITH NOWAIT;

											WAITFOR DELAY ''''''''00:00:05'''''''';
										END;
									END;
								END;
							END
							ELSE IF (@command = ''''''''Enable'''''''')
							BEGIN
								--
								-- Enable job again if it was enabled when we started
								--
								IF (@jobStatus = 0)
								BEGIN
									RAISERROR('''''''''''''''', 0, 1) WITH NOWAIT;
									SET @message = ''''''''Enabling job '''''''' + QUOTENAME(@jobName);
									RAISERROR(@message, 0, 1) WITH NOWAIT;

									EXEC msdb.dbo.sp_update_job
										@job_name = @jobName,
										@enabled = 1;
								END;
							END;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPAgentJobControl
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPAgentJobControl'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPControl
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPControl'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPControl'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPControl AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPControl
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPControl'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPControl(
							@Command nvarchar(16) = '''''''''''''''',
							@Days int = NULL,
							@Enabled bit = NULL,
							@ExecutionDelaySec int = NULL,
							@Filter nvarchar(max) = '''''''''''''''',
							@Friday bit = NULL,
							@FromTime nvarchar(8) = '''''''''''''''',
							@IsUtc bit = NULL,
							@Key nvarchar(128) = '''''''''''''''',
							@Monday bit = NULL,
							@Name nvarchar(128) = '''''''''''''''',
							@NewValue nvarchar(128) = '''''''''''''''',
							@Parameter nvarchar(max) = '''''''''''''''',
							@Saturday bit = NULL,
							@Sequence tinyint = NULL,
							@Sunday bit = NULL,
							@TableName nvarchar(128) = '''''''''''''''',
							@Task nvarchar(128) = '''''''''''''''',
							@TimeColumn nvarchar(128) = '''''''''''''''',
							@Thursday bit = NULL,
							@ToTime nvarchar(8) = '''''''''''''''',
							@Tuesday bit = NULL,
							@Type nvarchar(16),
							@Value nvarchar(128) = '''''''''''''''',
							@Wednesday bit = NULL
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							DECLARE @message nvarchar(max);
							DECLARE @retentionChanges TABLE(
								Action nvarchar(10),
								DeletedDays int,
								DeletedEnabled bit,
								InsertedDays int,
								InsertedEnabled bit
							);
							DECLARE @scheduleChanges TABLE(
								Action nvarchar(10),
								DeletedEnabled bit,
								DeletedExecutionDelaySec int,
								DeletedFromTime time(0),
								DeletedToTime time(0),
								DeletedMonday bit,
								DeletedTuesday bit,
								DeletedWednesday bit,
								DeletedThursday bit,
								DeletedFriday bit,
								DeletedSaturday bit,
								DeletedSunday bit,
								InsertedEnabled bit,
								InsertedExecutionDelaySec int,
								InsertedFromTime time(0),
								InsertedToTime time(0),
								InsertedMonday bit,
								InsertedTuesday bit,
								InsertedWednesday bit,
								InsertedThursday bit,
								InsertedFriday bit,
								InsertedSaturday bit,
								InsertedSunday bit
							);
							DECLARE @scheduleId int;
							DECLARE @spControl nvarchar(128);
							DECLARE @stmt nvarchar(max);
							DECLARE @thisTask nvarchar(128);
							DECLARE @version nvarchar(128);
			'';
			SET @stmt += ''
							SET @thisTask = OBJECT_NAME(@@PROCID);
							SET @version = '''''''''' + @version + '''''''''';

							SET @Command    = LTRIM(RTRIM(@Command));
							SET @Filter     = LTRIM(RTRIM(@Filter));
							SET @FromTime   = LTRIM(RTRIM(@FromTime));
							SET @Key        = LTRIM(RTRIM(@Key));
							SET @Name       = LTRIM(RTRIM(@Name));
							SET @Parameter  = LTRIM(RTRIM(@Parameter));
							SET @TableName  = LTRIM(RTRIM(@TableName));
							SET @Task       = LTRIM(RTRIM(@Task));
							SET @TimeColumn = LTRIM(RTRIM(@TimeColumn));
							SET @ToTime     = LTRIM(RTRIM(@ToTime));
							SET @Type       = LTRIM(RTRIM(@Type));
							SET @Value      = LTRIM(RTRIM(@Value));

							SET @Parameter = REPLACE(@Parameter, '''''''''''''''''''''''''''''''', '''''''''''''''''''''''''''''''''''''''''''''''');

							SET @Command = LOWER(@Command);
							SET @Command = COALESCE(NULLIF(@Command, ''''''''''''''''), ''''''''list'''''''');

							IF (@Command NOT IN (''''''''list'''''''', ''''''''rename'''''''', ''''''''set''''''''))
							BEGIN
								RAISERROR(''''''''@Command must be ''''''''''''''''list'''''''''''''''', ''''''''''''''''rename'''''''''''''''' or ''''''''''''''''set'''''''''''''''''''''''', 0, 1) WITH NOWAIT;
								RETURN -1;
							END;

							SET @Type   = LOWER(@Type);

							IF (@Type NOT IN (''''''''configuration'''''''', ''''''''parameter'''''''', ''''''''retention'''''''', ''''''''schedule'''''''', ''''''''uninstall''''''''))
							BEGIN
								RAISERROR(''''''''@Type must be ''''''''''''''''Configuration'''''''''''''''', ''''''''''''''''Parameter'''''''''''''''', ''''''''''''''''Retention'''''''''''''''', ''''''''''''''''Schedule'''''''''''''''' or ''''''''''''''''Uninstall'''''''''''''''''''''''', 0, 1) WITH NOWAIT;
								RETURN -2;
							END;
			'';
			SET @stmt += ''
							IF (@Type = ''''''''configuration'''''''')
							BEGIN
								IF (@Command = ''''''''list'''''''')
								BEGIN
									SELECT
										c.[Key],
										c.Value
									FROM dbo.fhsmConfigurations AS c
									WHERE (1 = 1)
										AND ((c.[Key]   LIKE ''''''''%'''''''' + @Key   + ''''''''%'''''''') OR (@Key = ''''''''''''''''))
										AND ((c.[Value] LIKE ''''''''%'''''''' + @Value + ''''''''%'''''''') OR (@Value = ''''''''''''''''))
									ORDER BY c.[Key];
								END
			'';
			SET @stmt += ''
								ELSE IF (@Command = ''''''''rename'''''''')
								BEGIN
									IF (@Key = ''''''''AgentJobName'''''''')
									BEGIN
										IF (@NewValue = '''''''''''''''')
										BEGIN
											SET @message = ''''''''New name must be set @NewValue:'''''''''''''''''''''''' + COALESCE(@NewValue, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
											RAISERROR(@message, 0, 1) WITH NOWAIT;
											RETURN -11;
										END;

										IF NOT EXISTS (
											SELECT *
											FROM msdb.dbo.sysjobs AS sj
											WHERE (sj.name = @Value)
										)
										BEGIN
											SET @message = ''''''''Agent job does not exists @Value:'''''''''''''''''''''''' + COALESCE(@Value, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
											RAISERROR(@message, 0, 1) WITH NOWAIT;
											RETURN -12;
										END;

										IF EXISTS (
											SELECT *
											FROM msdb.dbo.sysjobs AS sj
											WHERE (sj.name = @NewValue)
										)
										BEGIN
											SET @message = ''''''''Agent job name is alreay used @NewValue:'''''''''''''''''''''''' + COALESCE(@NewValue, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
											RAISERROR(@message, 0, 1) WITH NOWAIT;
											RETURN -13;
										END;
			'';
			SET @stmt += ''
										--
										-- Rename job
										--
										BEGIN
											SET @message = ''''''''Renaming agent job to '''''''''''''''''''''''' + @NewValue + '''''''' from '''''''''''''''''''''''' + @Value + '''''''''''''''''''''''''''''''';
											EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Debug'''''''', @message = @message;

											EXEC msdb.dbo.sp_update_job @job_name = @Value, @new_name = @NewValue;

											SET @message = ''''''''Renamed agent job to '''''''''''''''''''''''' + @NewValue + '''''''' from '''''''''''''''''''''''' + @Value + '''''''''''''''''''''''''''''''';
											EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
										END;

										--
										-- Register new name
										--
										BEGIN
											WITH
											cfg([Key], Value) AS(
												SELECT
													''''''''AgentJobName''''''''
													,@NewValue
											)
											MERGE dbo.fhsmConfigurations AS tgt
											USING cfg AS src ON (src.[Key] = tgt.[Key])
											WHEN MATCHED
												THEN UPDATE
													SET tgt.Value = src.Value
											WHEN NOT MATCHED BY TARGET
												THEN INSERT([Key], Value)
												VALUES(src.[Key], src.Value);
										END;

										--
										-- Rename schedule but only if job has one schedule
										--
										BEGIN
											IF ((
												SELECT COUNT(*)
												FROM msdb.dbo.sysjobs AS sj
												INNER JOIN msdb.dbo.sysjobschedules AS sjs ON (sjs.job_id = sj.job_id)
												WHERE (sj.name = @NewValue)
											) > 1)
											BEGIN
												SET @message = ''''''''Can not rename schedules for agent job as more than one schedule exists'''''''';
												RAISERROR(@message, 0, 1) WITH NOWAIT;
												RETURN -14;
											END
											ELSE BEGIN
												SET @scheduleId = (
													SELECT sjs.schedule_id
													FROM msdb.dbo.sysjobs AS sj
													INNER JOIN msdb.dbo.sysjobschedules AS sjs ON (sjs.job_id = sj.job_id)
													WHERE (sj.name = @NewValue)
												);

												SET @message = ''''''''Renaming agent job schedule to '''''''''''''''''''''''' + @NewValue + '''''''' for scheduleId:'''''''''''''''''''''''' + COALESCE(CAST(@scheduleId AS nvarchar), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
												EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Debug'''''''', @message = @message;

												EXEC msdb.dbo.sp_update_schedule @schedule_id = @scheduleId, @new_name = @NewValue;

												SET @message = ''''''''Renamed agent job schedule to '''''''''''''''''''''''' + @NewValue + '''''''' for scheduleId:'''''''''''''''''''''''' + COALESCE(CAST(@scheduleId AS nvarchar), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
												EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
											END;
										END;
									END
									ELSE BEGIN
										SET @message = ''''''''Set is not allowed for Configuration @Key:'''''''''''''''''''''''' + COALESCE(@Key, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -15;
									END;
								END
			'';
			SET @stmt += ''
								ELSE IF (@Command = ''''''''set'''''''')
								BEGIN
									IF (@Key = ''''''''AgentJobName'''''''')
									BEGIN
										IF NOT EXISTS (
											SELECT *
											FROM msdb.dbo.sysjobs AS sj
											WHERE (sj.name = @Value)
										)
										BEGIN
											SET @message = ''''''''Agent job does not exists @Value:'''''''''''''''''''''''' + COALESCE(@Value, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
											RAISERROR(@message, 0, 1) WITH NOWAIT;
											RETURN -16;
										END;

										WITH
										cfg([Key], Value) AS(
											SELECT
												''''''''AgentJobName''''''''
												,@Value
										)
										MERGE dbo.fhsmConfigurations AS tgt
										USING cfg AS src ON (src.[Key] = tgt.[Key])
										WHEN MATCHED
											THEN UPDATE
												SET tgt.Value = src.Value
										WHEN NOT MATCHED BY TARGET
											THEN INSERT([Key], Value)
											VALUES(src.[Key], src.Value);

										SET @message = ''''''''Registered agent job name to '''''''''''''''''''''''' + @Value + '''''''''''''''''''''''''''''''';
										EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
									END
									ELSE IF (@Key = ''''''''BlockedProcessThreshold'''''''')
									BEGIN
										EXEC dbo.fhsmSPControlBlocksAndDeadlocks @Type = @Type, @Command = @Command, @Key = @Key, @Value = @Value;
									END
									ELSE BEGIN
										SET @message = ''''''''Set is not allowed for Configuration @Key:'''''''''''''''''''''''' + COALESCE(@Key, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -17;
									END;
								END
								ELSE BEGIN
									RAISERROR(''''''''Internal error - @Command not processed'''''''', 0, 1) WITH NOWAIT;
									RETURN -19;
								END;
							END
			'';
			SET @stmt += ''
							ELSE IF (@Type = ''''''''parameter'''''''')
							BEGIN
								IF (@Command = ''''''''list'''''''')
								BEGIN
									SELECT
										s.Task,
										s.Name,
										s.Parameter
									FROM dbo.fhsmSchedules AS s
									WHERE (1 = 1)
										AND ((s.Name      LIKE ''''''''%'''''''' + @Name      + ''''''''%'''''''') OR (@Name = ''''''''''''''''))
										AND ((s.Parameter LIKE ''''''''%'''''''' + @Parameter + ''''''''%'''''''') OR (@Parameter = ''''''''''''''''))
										AND ((s.Task      LIKE ''''''''%'''''''' + @Task      + ''''''''%'''''''') OR (@Task = ''''''''''''''''))
									ORDER BY s.Task, s.Name;
								END
								ELSE IF (@Command = ''''''''set'''''''')
								BEGIN
									IF NOT EXISTS (
										SELECT *
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
									)
									BEGIN
										SET @message = ''''''''Invalid @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''' and @Name:'''''''''''''''''''''''' + COALESCE(NULLIF(@Name, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -21;
									END;

									IF (CHARINDEX(''''''''fhsmSP'''''''', @Task) = 1)
									BEGIN
										SET @spControl = ''''''''dbo.fhsmSPControl'''''''' + SUBSTRING(@Task, LEN(''''''''fhsmSP'''''''') + 1, LEN(@Task));
										IF (OBJECT_ID(@spControl) IS NOT NULL)
										BEGIN
											SET @stmt = ''''''''
												EXEC '''''''' + @spControl + '''''''' @Type = '''''''''''''''''''''''' + @Type + '''''''''''''''''''''''', @Command = '''''''''''''''''''''''' + @Command + '''''''''''''''''''''''', @Task = '''''''''''''''''''''''' + @Task + '''''''''''''''''''''''', @Name = '''''''''''''''''''''''' + @Name + '''''''''''''''''''''''', @Parameter = '''''''''''''''''''''''' + @Parameter + '''''''''''''''''''''''';
											'''''''';
											EXEC(@stmt);
										END
										ELSE BEGIN
											SET @message = ''''''''Control procedure does not exists for @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
											RAISERROR(@message, 0, 1) WITH NOWAIT;
											RETURN -22;
										END;
									END
									ELSE BEGIN
										SET @message = ''''''''Task name is not correct configured @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -28;
									END;
								END
								ELSE BEGIN
									RAISERROR(''''''''Internal error - @Command not processed'''''''', 0, 1) WITH NOWAIT;
									RETURN -29;
								END;
							END
			'';
			SET @stmt += ''
							ELSE IF (@Type = ''''''''retention'''''''')
							BEGIN
								IF (@Command = ''''''''list'''''''')
								BEGIN
									SELECT
										r.TableName,
										r.Enabled,
										r.Sequence,
										r.TimeColumn,
										r.IsUtc,
										r.Days,
										r.Filter
									FROM dbo.fhsmRetentions AS r
									WHERE (1 = 1)
										AND ((r.Filter     LIKE ''''''''%'''''''' + @Filter     + ''''''''%'''''''') OR (@Filter = ''''''''''''''''))
										AND ((r.TableName  LIKE ''''''''%'''''''' + @TableName  + ''''''''%'''''''') OR (@TableName = ''''''''''''''''))
										AND ((r.TimeColumn LIKE ''''''''%'''''''' + @TimeColumn + ''''''''%'''''''') OR (@TimeColumn = ''''''''''''''''))
										AND ((r.Days    <= @Days)     OR (@Days     IS NULL))
										AND ((r.Enabled  = @Enabled)  OR (@Enabled  IS NULL))
										AND ((r.IsUtc    = @IsUtc)    OR (@IsUtc    IS NULL))
										AND ((r.Sequence = @Sequence) OR (@Sequence IS NULL))
									ORDER BY r.TableName;
								END
								ELSE IF (@Command = ''''''''set'''''''')
								BEGIN
									IF NOT EXISTS (
										SELECT *
										FROM dbo.fhsmRetentions AS r
										WHERE (r.TableName = @TableName) AND (r.Sequence = @Sequence)
									)
									BEGIN
										SET @message = ''''''''Invalid @TableName:'''''''''''''''''''''''' + COALESCE(NULLIF(@TableName, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''' and @Sequence:'''''''''''''''''''''''' + COALESCE(CAST(@Sequence AS nvarchar), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -31;
									END;

									--
									-- Register configuration changes
									--
									BEGIN
										WITH
										conf(Id, Days, Enabled) AS(
											SELECT
												r.Id,
												COALESCE(@Days,    r.Days)    AS Days,
												COALESCE(@Enabled, r.Enabled) AS Enabled
											FROM dbo.fhsmRetentions AS r
											WHERE (r.TableName = @TableName) AND (r.Sequence = @Sequence)
										)
										MERGE dbo.fhsmRetentions AS tgt
										USING conf AS src ON (src.Id = tgt.Id)
										-- Not testing for NULL as a NULL parameter is not allowed
										WHEN MATCHED AND ((tgt.Days <> src.Days) OR (tgt.Enabled <> src.Enabled))
											THEN UPDATE
												SET
													tgt.Days    = src.Days,
													tgt.Enabled = src.Enabled
										OUTPUT
											$action,
											deleted.Days,
											deleted.Enabled,
											inserted.Days,
											inserted.Enabled
										INTO @retentionChanges;

										IF (@@ROWCOUNT <> 0)
										BEGIN
											SET @message = (
												SELECT ''''''''Retention for @TableName:'''''''''''''''''''''''' + @TableName + '''''''''''''''''''''''' - @Sequence:'''''''''''''''''''''''' + CAST(@Sequence AS nvarchar) + '''''''''''''''''''''''' is ''''
													+ ''''@Days:'''''''''''''''''''''''' + CAST(src.InsertedDays AS nvarchar) + '''''''''''''''''''''''' and ''''
													+ ''''@Enabled:'''''''''''''''''''''''' + CAST(src.InsertedEnabled AS nvarchar) + '''''''''''''''''''''''' ''''
													+ ''''- changed from ''''
													+ ''''@Days:'''''''''''''''''''''''' + CAST(src.DeletedDays AS nvarchar) + '''''''''''''''''''''''' and ''''
													+ ''''@Enabled:'''''''''''''''''''''''' + CAST(src.DeletedEnabled AS nvarchar) + ''''''''''''''''''''''''''''''''
												FROM @retentionChanges AS src
											);
											IF (@message IS NOT NULL)
											BEGIN
												EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
											END;
										END;
									END;
								END
								ELSE BEGIN
									RAISERROR(''''''''Internal error - @Command not processed'''''''', 0, 1) WITH NOWAIT;
									RETURN -39;
								END;
							END
			'';
			SET @stmt += ''
							ELSE IF (@Type = ''''''''schedule'''''''')
							BEGIN
								IF (@Command = ''''''''list'''''''')
								BEGIN
									SELECT
										s.Task,
										s.Name,
										s.Enabled,
										s.ExecutionDelaySec,
										s.FromTime,
										s.ToTime,
										s.Monday,
										s.Tuesday,
										s.Wednesday,
										s.Thursday,
										s.Friday,
										s.Saturday,
										s.Sunday
									FROM dbo.fhsmSchedules AS s
									WHERE (1 = 1)
										AND ((s.Name LIKE ''''''''%'''''''' + @Name + ''''''''%'''''''') OR (@Name = ''''''''''''''''))
										AND ((s.Task LIKE ''''''''%'''''''' + @Task + ''''''''%'''''''') OR (@Task = ''''''''''''''''))
										AND ((s.Enabled            = @Enabled)           OR (@Enabled           IS NULL))
										AND ((s.ExecutionDelaySec <= @ExecutionDelaySec) OR (@ExecutionDelaySec IS NULL))
										AND ((CONVERT(nvarchar, s.FromTime, 24) >= @FromTime) OR (@FromTime = ''''''''''''''''))
										AND ((CONVERT(nvarchar, s.ToTime,   24) <= @ToTime)   OR (@ToTime   = ''''''''''''''''))
										AND ((s.Monday    = @Monday)    OR (@Monday    IS NULL))
										AND ((s.Tuesday   = @Tuesday)   OR (@Tuesday   IS NULL))
										AND ((s.Wednesday = @Wednesday) OR (@Wednesday IS NULL))
										AND ((s.Thursday  = @Thursday)  OR (@Thursday  IS NULL))
										AND ((s.Friday    = @Friday)    OR (@Friday    IS NULL))
										AND ((s.Saturday  = @Saturday)  OR (@Saturday  IS NULL))
										AND ((s.Sunday    = @Sunday)    OR (@Sunday    IS NULL))
									ORDER BY s.Task, s.Name;
								END
			'';
			SET @stmt += ''
								ELSE IF (@Command = ''''''''set'''''''')
								BEGIN
									IF NOT EXISTS (
										SELECT *
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
									)
									BEGIN
										SET @message = ''''''''Invalid @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''' and @Name:'''''''''''''''''''''''' + COALESCE(NULLIF(@Name, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -41;
									END;
			'';
			SET @stmt += ''
									--
									-- Register configuration changes
									--
									BEGIN
										WITH
										conf(Id, Enabled, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday) AS(
											SELECT
												s.Id,
												COALESCE(@Enabled,                    s.Enabled)           AS Enabled,
												COALESCE(@ExecutionDelaySec,          s.ExecutionDelaySec) AS ExecutionDelaySec,
												COALESCE(NULLIF(@FromTime, ''''''''''''''''), s.FromTime)          AS FromTime,
												COALESCE(NULLIF(@ToTime, ''''''''''''''''),   s.ToTime)            AS ToTime,
												COALESCE(@Monday,                     s.Monday)            AS Monday,
												COALESCE(@Tuesday,                    s.Tuesday)           AS Tuesday,
												COALESCE(@Wednesday,                  s.Wednesday)         AS Wednesday,
												COALESCE(@Thursday,                   s.Thursday)          AS Thursday,
												COALESCE(@Friday,                     s.Friday)            AS Friday,
												COALESCE(@Saturday,                   s.Saturday)          AS Saturday,
												COALESCE(@Sunday,                     s.Sunday)            AS Sunday
											FROM dbo.fhsmSchedules AS s
											WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
										)
										MERGE dbo.fhsmSchedules AS tgt
										USING conf AS src ON (src.Id = tgt.Id)
										-- Not testing for NULL as a NULL parameter is not allowed
										WHEN MATCHED AND (
											(tgt.Enabled              <> src.Enabled)
											OR (tgt.ExecutionDelaySec <> src.ExecutionDelaySec)
											OR (tgt.FromTime          <> src.FromTime)
											OR (tgt.ToTime            <> src.ToTime)
											OR (tgt.Monday            <> src.Monday)
											OR (tgt.Tuesday           <> src.Tuesday)
											OR (tgt.Wednesday         <> src.Wednesday)
											OR (tgt.Thursday          <> src.Thursday)
											OR (tgt.Friday            <> src.Friday)
											OR (tgt.Saturday          <> src.Saturday)
											OR (tgt.Sunday            <> src.Sunday)
										)
											THEN UPDATE
												SET
													tgt.Enabled           = src.Enabled,
													tgt.ExecutionDelaySec = src.ExecutionDelaySec,
													tgt.FromTime          = src.FromTime,
													tgt.ToTime            = src.ToTime,
													tgt.Monday            = src.Monday,
													tgt.Tuesday           = src.Tuesday,
													tgt.Wednesday         = src.Wednesday,
													tgt.Thursday          = src.Thursday,
													tgt.Friday            = src.Friday,
													tgt.Saturday          = src.Saturday,
													tgt.Sunday            = src.Sunday
			'';
			SET @stmt += ''
										OUTPUT
											$action,
											deleted.Enabled,
											deleted.ExecutionDelaySec,
											deleted.FromTime,
											deleted.ToTime,
											deleted.Monday,
											deleted.Tuesday,
											deleted.Wednesday,
											deleted.Thursday,
											deleted.Friday,
											deleted.Saturday,
											deleted.Sunday,
											inserted.Enabled,
											inserted.ExecutionDelaySec,
											inserted.FromTime,
											inserted.ToTime,
											inserted.Monday,
											inserted.Tuesday,
											inserted.Wednesday,
											inserted.Thursday,
											inserted.Friday,
											inserted.Saturday,
											inserted.Sunday
										INTO @scheduleChanges;

										IF (@@ROWCOUNT <> 0)
										BEGIN
											SET @message = (
												SELECT ''''''''Schedule for @Task:'''''''''''''''''''''''' + @Task + '''''''''''''''''''''''' - @Name:'''''''''''''''''''''''' + @Name + '''''''''''''''''''''''' is ''''
													+ ''''@Enabled:''''''''''''''''''''''''           + CAST(src.InsertedEnabled AS nvarchar)           + '''''''''''''''''''''''', ''''
													+ ''''@ExecutionDelaySec:'''''''''''''''''''''''' + CAST(src.InsertedExecutionDelaySec AS nvarchar) + '''''''''''''''''''''''', ''''
													+ ''''@FromTime:''''''''''''''''''''''''          + CAST(src.InsertedFromTime AS nvarchar)          + '''''''''''''''''''''''', ''''
													+ ''''@ToTime:''''''''''''''''''''''''            + CAST(src.InsertedToTime AS nvarchar)            + '''''''''''''''''''''''', ''''
													+ ''''@Monday:''''''''''''''''''''''''            + CAST(src.InsertedMonday AS nvarchar)            + '''''''''''''''''''''''', ''''
													+ ''''@Tuesday:''''''''''''''''''''''''           + CAST(src.InsertedTuesday AS nvarchar)           + '''''''''''''''''''''''', ''''
													+ ''''@Wednesday:''''''''''''''''''''''''         + CAST(src.InsertedWednesday AS nvarchar)         + '''''''''''''''''''''''', ''''
													+ ''''@Thursday:''''''''''''''''''''''''          + CAST(src.InsertedThursday AS nvarchar)          + '''''''''''''''''''''''', ''''
													+ ''''@Friday:''''''''''''''''''''''''            + CAST(src.InsertedFriday AS nvarchar)            + '''''''''''''''''''''''', ''''
													+ ''''@Saturday:''''''''''''''''''''''''          + CAST(src.InsertedSaturday AS nvarchar)          + '''''''''''''''''''''''', ''''
													+ ''''@Sunday:''''''''''''''''''''''''            + CAST(src.InsertedSunday AS nvarchar)            + '''''''''''''''''''''''', ''''
													+ ''''- changed from ''''
													+ ''''@Enabled:''''''''''''''''''''''''           + CAST(src.DeletedEnabled AS nvarchar)            + '''''''''''''''''''''''', ''''
													+ ''''@ExecutionDelaySec:'''''''''''''''''''''''' + CAST(src.DeletedExecutionDelaySec AS nvarchar)  + '''''''''''''''''''''''', ''''
													+ ''''@FromTime:''''''''''''''''''''''''          + CAST(src.DeletedFromTime AS nvarchar)           + '''''''''''''''''''''''', ''''
													+ ''''@ToTime:''''''''''''''''''''''''            + CAST(src.DeletedToTime AS nvarchar)             + '''''''''''''''''''''''', ''''
													+ ''''@Monday:''''''''''''''''''''''''            + CAST(src.DeletedMonday AS nvarchar)             + '''''''''''''''''''''''', ''''
													+ ''''@Tuesday:''''''''''''''''''''''''           + CAST(src.DeletedTuesday AS nvarchar)            + '''''''''''''''''''''''', ''''
													+ ''''@Wednesday:''''''''''''''''''''''''         + CAST(src.DeletedWednesday AS nvarchar)          + '''''''''''''''''''''''', ''''
													+ ''''@Thursday:''''''''''''''''''''''''          + CAST(src.DeletedThursday AS nvarchar)           + '''''''''''''''''''''''', ''''
													+ ''''@Friday:''''''''''''''''''''''''            + CAST(src.DeletedFriday AS nvarchar)             + '''''''''''''''''''''''', ''''
													+ ''''@Saturday:''''''''''''''''''''''''          + CAST(src.DeletedSaturday AS nvarchar)           + '''''''''''''''''''''''', ''''
													+ ''''@Sunday:''''''''''''''''''''''''            + CAST(src.DeletedSunday AS nvarchar)             + ''''''''''''''''''''''''''''''''
												FROM @scheduleChanges AS src
											);
											IF (@message IS NOT NULL)
											BEGIN
												EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
											END;
										END;
									END;
								END
								ELSE BEGIN
									RAISERROR(''''''''Internal error - @Command not processed'''''''', 0, 1) WITH NOWAIT;
									RETURN -49;
								END;
							END
			'';
			SET @stmt += ''
							ELSE IF (@Type = ''''''''uninstall'''''''')
							BEGIN
								IF (@task = ''''''''all'''''''')
								BEGIN
									DECLARE oCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
									SELECT o.name
									FROM sys.schemas AS sch 
									INNER JOIN sys.objects AS o ON (o.schema_id = sch.schema_id)
									WHERE (sch.name = ''''''''dbo'''''''') AND (o.type = ''''''''P'''''''') AND (o.name LIKE ''''''''fhsmSPControl%'''''''') AND (o.name <> ''''''''fhsmSPControl'''''''')
									ORDER BY o.name;

									OPEN oCur;

									WHILE (1 = 1)
									BEGIN
										FETCH NEXT FROM oCur
										INTO @spControl;

										IF (@@FETCH_STATUS <> 0)
										BEGIN
											BREAK;
										END;

										SET @spControl = ''''''''dbo.'''''''' + @spControl;

										PRINT @spControl;

										SET @stmt = ''''''''
											EXEC '''''''' + @spControl + '''''''' @Type = '''''''''''''''''''''''' + @Type + '''''''''''''''''''''''', @Command = '''''''''''''''''''''''' + @Command + '''''''''''''''''''''''', @Task = '''''''''''''''''''''''' + @Task + '''''''''''''''''''''''', @Name = '''''''''''''''''''''''' + @Name + '''''''''''''''''''''''', @Parameter = '''''''''''''''''''''''' + @Parameter + '''''''''''''''''''''''';
										'''''''';
										EXEC(@stmt);
									END;

									CLOSE oCur;
									DEALLOCATE oCur;
								END
								ELSE IF (CHARINDEX(''''''''fhsmSP'''''''', @Task) = 1)
								BEGIN
									IF NOT EXISTS (
										SELECT *
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Task = @Task) AND (s.DeploymentStatus <> -1)
									)
									BEGIN
										SET @message = ''''''''Invalid @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -51;
									END;

									SET @spControl = ''''''''dbo.fhsmSPControl'''''''' + SUBSTRING(@Task, LEN(''''''''fhsmSP'''''''') + 1, LEN(@Task));
									IF (OBJECT_ID(@spControl) IS NOT NULL)
									BEGIN
										SET @stmt = ''''''''
											EXEC '''''''' + @spControl + '''''''' @Type = '''''''''''''''''''''''' + @Type + '''''''''''''''''''''''', @Command = '''''''''''''''''''''''' + @Command + '''''''''''''''''''''''', @Task = '''''''''''''''''''''''' + @Task + '''''''''''''''''''''''', @Name = '''''''''''''''''''''''' + @Name + '''''''''''''''''''''''', @Parameter = '''''''''''''''''''''''' + @Parameter + '''''''''''''''''''''''';
										'''''''';
										EXEC(@stmt);
									END
									ELSE BEGIN
										SET @message = ''''''''Control procedure does not exists for @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -52;
									END;
								END
								ELSE BEGIN
									SET @message = ''''''''Invalid task - @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
									RAISERROR(@message, 0, 1) WITH NOWAIT;
									RETURN -59;
								END;
							END
			'';
			SET @stmt += ''
							ELSE BEGIN
								RAISERROR(''''''''Internal error - @Type not processed'''''''', 0, 1) WITH NOWAIT;
								RETURN -999;
							END;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPControl
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPControl'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPControlCleanup
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPControlCleanup'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPControlCleanup'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPControlCleanup AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPControlCleanup
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPControlCleanup'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPControlCleanup(
							@Type nvarchar(16)
							,@Command nvarchar(16)
							,@Name nvarchar(128) = NULL
							,@Parameter nvarchar(max) = NULL
							,@Task nvarchar(128) = NULL
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							DECLARE @message nvarchar(max);
							DECLARE @parameterChanges TABLE(
								Action nvarchar(10),
								DeletedTask nvarchar(128),
								DeletedName nvarchar(128),
								DeletedParameter nvarchar(max),
								InsertedTask nvarchar(128),
								InsertedName nvarchar(128),
								InsertedParameter nvarchar(max)
							);
							DECLARE @thisTask nvarchar(128);
							DECLARE @version nvarchar(128);

							SET @thisTask = OBJECT_NAME(@@PROCID);
							SET @version = '''''''''' + @version + '''''''''';
			'';
			SET @stmt += ''
							IF (@Type = ''''''''Parameter'''''''')
							BEGIN
								IF (@Command = ''''''''set'''''''')
								BEGIN
									SET @Parameter = NULLIF(@Parameter, '''''''''''''''');

									IF NOT EXISTS (
										SELECT *
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
									)
									BEGIN
										SET @message = ''''''''Invalid @Task:'''''''''''''''''''''''' + COALESCE(NULLIF(@Task, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''' and @Name:'''''''''''''''''''''''' + COALESCE(NULLIF(@Name, ''''''''''''''''), ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
										RAISERROR(@message, 0, 1) WITH NOWAIT;
										RETURN -11;
									END;

									--
									-- Register configuration changes
									--
									BEGIN
										WITH
										conf(Task, Name, Parameter) AS(
											SELECT
												@Task AS Task
												,@Name AS Name
												,@Parameter AS Parameter
										)
										MERGE dbo.fhsmSchedules AS tgt
										USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
										-- Not testing for NULL as a NULL parameter is not allowed
										WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
											THEN UPDATE
												SET tgt.Parameter = src.Parameter
										WHEN NOT MATCHED BY TARGET
											THEN INSERT(Task, Name, Parameter)
											VALUES(src.Task, src.Name, src.Parameter)
										OUTPUT
											$action,
											deleted.Task,
											deleted.Name,
											deleted.Parameter,
											inserted.Task,
											inserted.Name,
											inserted.Parameter
										INTO @parameterChanges;

										IF (@@ROWCOUNT <> 0)
										BEGIN
											SET @message = (
												SELECT ''''''''Parameter is '''''''''''''''''''''''' + COALESCE(src.InsertedParameter, ''''''''<NULL>'''''''') + '''''''''''''''''''''''' - changed from '''''''''''''''''''''''' + COALESCE(src.DeletedParameter, ''''''''<NULL>'''''''') + ''''''''''''''''''''''''''''''''
												FROM @parameterChanges AS src
											);
											IF (@message IS NOT NULL)
											BEGIN
												EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
											END;
										END;
									END;
			'';
			SET @stmt += ''
								END
								ELSE BEGIN
									SET @message = ''''''''Illegal Combination of @Type:'''''''''''''''''''''''' + COALESCE(@Type, ''''''''<NULL>'''''''') + '''''''''''''''''''''''' and @Command:'''''''''''''''''''''''' + COALESCE(@Command, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
									RAISERROR(@message, 0, 1) WITH NOWAIT;
									RETURN -19;
								END;
							END
			'';
			SET @stmt += ''
							ELSE IF (@Type = ''''''''Uninstall'''''''')
							BEGIN
								--
								-- Place holder
								--
								SET @Type = @Type;
							END
			'';
			SET @stmt += ''
							ELSE BEGIN
								SET @message = ''''''''Illegal @Type:'''''''''''''''''''''''' + COALESCE(@Type, ''''''''<NULL>'''''''') + '''''''''''''''''''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -999;
							END;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPControlCleanup
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPControlCleanup'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPLog
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPLog'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPLog'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPLog AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPLog
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPLog'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPLog(
							@name nvarchar(128)
							,@version nvarchar(128) = NULL
							,@task nvarchar(128)
							,@type nvarchar(16)
							,@message nvarchar(max)
							,@id int = NULL OUTPUT
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							DECLARE @printMessage nvarchar(max);

							SET @printMessage = @name + '''''''': '''''''' + COALESCE(@version, ''''''''N.A.'''''''') + '''''''': '''''''' + @task + '''''''': '''''''' + @type + '''''''': '''''''' + @message;
							PRINT @printMessage;

							IF (@id IS NULL)
							BEGIN
								INSERT INTO dbo.fhsmLog(Name, Version, Task, Type, Message)
								VALUES (@name, @version, @task, @type, @message);

								SET @id = SCOPE_IDENTITY();
							END
							ELSE BEGIN
								UPDATE l
								SET
									l.Version = @version
								FROM dbo.fhsmLog AS l
								WHERE (l.Id = @id);
							END;

							RETURN @id;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPLog
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPLog'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPProcessing
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPProcessing'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPProcessing'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPProcessing AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPProcessing
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPProcessing'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPProcessing(
							@name nvarchar(128)
							,@task nvarchar(128)
							,@version nvarchar(128)
							,@type int
							,@timestampUTC datetime
							,@timestamp datetime
							,@id int = NULL OUTPUT
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							IF (@id IS NULL)
							BEGIN
								INSERT INTO dbo.fhsmProcessing(Name, Task, Version, Type, StartedTimestampUTC, StartedTimestamp)
								SELECT @name, @task, @version, @type, @timestampUTC, @timestamp;

								SET @id = SCOPE_IDENTITY();
							END
							ELSE BEGIN
								UPDATE p
								SET
									p.Version           = @version,
									p.EndedTimestampUTC = @timestampUTC,
									p.EndedTimestamp    = @timestamp
								FROM dbo.fhsmProcessing AS p
								WHERE (p.Id = @id);
							END;

							RETURN @id;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPProcessing
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPProcessing'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPCleanup
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPCleanup'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPCleanup'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPCleanup AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			SET @stmt += ''
				--
				-- Alter dbo.fhsmSPCleanup
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPCleanup'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPCleanup(
							@name nvarchar(128)
							,@version nvarchar(128) OUTPUT
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							DECLARE @bulkSize int;
							DECLARE @bulkSizeStr nvarchar(128);
							DECLARE @days int;
							DECLARE @defaultBulkSize int;
							DECLARE @filter nvarchar(max);
							DECLARE @id int;
							DECLARE @message nvarchar(max);
							DECLARE @parameter nvarchar(max);
							DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
							DECLARE @rowsDeleted int;
							DECLARE @rowsDeletedTotal int;
							DECLARE @sequence tinyint;
							DECLARE @stmt nvarchar(max);
							DECLARE @tableName nvarchar(128);
							DECLARE @thisTask nvarchar(128);
							DECLARE @timeColumn nvarchar(128);

							SET @defaultBulkSize = 5000;
							SET @thisTask = OBJECT_NAME(@@PROCID);
							SET @version = '''''''''' + @version + '''''''''';

							--
							-- Get the parameter for the command
							--
							BEGIN
								SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

								INSERT INTO @parameterTable([Key], Value)
								SELECT
									(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''''''='''''''') AS s WHERE (s.Part = 1)) AS [Key]
									,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''''''='''''''') AS s WHERE (s.Part = 2)) AS Value
								FROM dbo.fhsmFNSplitString(@parameter, '''''''';'''''''') AS p;

								SET @bulkSizeStr = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''''''@BulkSize''''''''));
								SET @bulkSize = dbo.fhsmFNTryParseAsInt(@bulkSizeStr);

								IF (@bulkSize < 1) OR (@bulkSize IS NULL)
								BEGIN
									SET @bulkSize = @defaultBulkSize;
								END;
							END;

							DECLARE tCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT r.Id, r.TableName, r.Sequence, r.TimeColumn, r.Days, NULLIF(RTRIM(LTRIM(r.Filter)), '''''''''''''''')
							FROM dbo.fhsmRetentions AS r
							WHERE (r.Enabled = 1)
							ORDER BY r.TableName, r.Sequence;

							OPEN tCur;
			'';
			SET @stmt += ''

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM tCur
								INTO @id, @tableName, @sequence, @timeColumn, @days, @filter;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								IF (OBJECT_ID(@tableName) IS NULL)
								BEGIN
									SET @message = ''''''''Table '''''''''''''''''''''''' + @tableName + '''''''''''''''''''''''' does not exist'''''''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''''''Warning'''''''', @message = @message;
								END
								ELSE IF NOT EXISTS(SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(@tableName)) AND (c.name = '''''''''''''''' + @timeColumn + ''''''''''''''''))
								BEGIN
									SET @message = ''''''''Column '''''''''''''''''''''''' + @timeColumn + '''''''''''''''''''''''' in Table '''''''''''''''''''''''' + @tableName + '''''''''''''''''''''''' does not exist'''''''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''''''Warning'''''''', @message = @message;
								END
								ELSE BEGIN
									SET @stmt = ''''''''
										DECLARE @latestDate datetime;
										DECLARE @timeLimit datetime;

										SET @latestDate = (SELECT MAX(t.'''''''' + @timeColumn + '''''''') FROM '''''''' + @tableName + '''''''' AS t);
										SET @timeLimit = DATEADD(DAY, ABS(@days) * -1, @latestDate);

										BEGIN TRANSACTION;
											DELETE TOP(@bulkSize) t
											FROM '''''''' + @tableName + '''''''' AS t
											WHERE (t.'''''''' + @timeColumn + '''''''' < @timeLimit)'''''''' + COALESCE('''''''' AND ('''''''' + @filter + '''''''')'''''''', '''''''''''''''') + '''''''';

											SET @rowsDeleted = @@ROWCOUNT;
										COMMIT TRANSACTION;

										CHECKPOINT;
									'''''''';

									UPDATE r
									SET r.LastStartedUTC = SYSUTCDATETIME()
									FROM dbo.fhsmRetentions AS r
									WHERE (r.Id = @id);

									SET @rowsDeletedTotal = 0;

									WHILE (1 = 1)
									BEGIN
										EXEC sp_executesql
											@stmt
											,N''''''''@days int, @bulkSize int, @rowsDeleted int OUTPUT''''''''
											,@days = @days
											,@bulkSize = @bulkSize
											,@rowsDeleted = @rowsDeleted OUTPUT;

										IF (@rowsDeleted = 0)
										BEGIN
											BREAK;
										END;

										SET @rowsDeletedTotal += @rowsDeleted;

										UPDATE r
										SET r.LastExecutedUTC = SYSUTCDATETIME()
										FROM dbo.fhsmRetentions AS r
										WHERE (r.Id = @id);

										SET @message = ''''''''Deleted ''''''''
											+ CAST(@rowsDeleted AS nvarchar) + '''''''' records in table '''''''' + @tableName + '''''''' sequence '''''''' + CAST(@sequence AS nvarchar) + COALESCE('''''''' Filter:['''''''' + @filter + '''''''']'''''''', '''''''''''''''')
											+ '''''''' older than '''''''' + CAST(@days AS nvarchar) + '''''''' days'''''''';
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
									END;

									UPDATE r
									SET r.LastExecutedUTC = SYSUTCDATETIME()
									FROM dbo.fhsmRetentions AS r
									WHERE (r.Id = @id);

									IF (@rowsDeletedTotal > 0)
									BEGIN
										SET @message = ''''''''Deleted in total ''''''''
											+ CAST(@rowsDeletedTotal AS nvarchar) + '''''''' records in table '''''''' + @tableName + '''''''' sequence '''''''' + CAST(@sequence AS nvarchar) + COALESCE('''''''' Filter:['''''''' + @filter + '''''''']'''''''', '''''''''''''''')
											+ '''''''' older than '''''''' + CAST(@days AS nvarchar) + '''''''' days'''''''';
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''''''Info'''''''', @message = @message;
									END
									ELSE BEGIN
										SET @message = ''''''''No records deleted in table '''''''' + @tableName + '''''''' older than '''''''' + CAST(@days AS nvarchar) + '''''''' days'''''''';
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''''''Debug'''''''', @message = @message;
									END
								END;
							END;

							CLOSE tCur;
							DEALLOCATE tCur;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPCleanup
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPCleanup'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;

		--
		-- Register schedule for dbo.fhsmSPCleanup
		--
		BEGIN
			-- Every day between 23:00 and 24:00
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				WITH
				schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
					SELECT
						1													AS Enabled
						,0													AS DeploymentStatus
						,''''Cleanup data''''									AS Name
						,PARSENAME(''''dbo.fhsmSPCleanup'''', 1)				AS Task
						,12 * 60 * 60										AS ExecutionDelaySec
						,CAST(''''1900-1-1T23:00:00.0000'''' AS datetime2(0))	AS FromTime
						,CAST(''''1900-1-1T23:59:59.0000'''' AS datetime2(0))	AS ToTime
						,1, 1, 1, 1, 1, 1, 1								-- Monday..Sunday
						,''''@BulkSize = 5000''''								AS Parameter
				)
				MERGE dbo.fhsmSchedules AS tgt
				USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
				WHEN NOT MATCHED BY TARGET
					THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
					VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
			'';
			EXEC(@stmt);
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPSchedules
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPSchedules'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPSchedules'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPSchedules AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPSchedules
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPSchedules'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPSchedules (
							@test bit = 0
						)
						AS
						BEGIN
							SET NOCOUNT ON;

							DECLARE @enabled bit;
							DECLARE @errorMsg nvarchar(max);
							DECLARE @executionDelaySec int;
							DECLARE @fromTime time(0);
							DECLARE @id int;
							DECLARE @lastExecutedUTC datetime;
							DECLARE @lastStartedUTC datetime;
							DECLARE @logId int;
							DECLARE @message nvarchar(max);
							DECLARE @monday bit, @tuesday bit, @wednesday bit, @thursday bit, @friday bit, @saturday bit, @sunday bit;
							DECLARE @name nvarchar(128);
							DECLARE @now datetime;
							DECLARE @nowUTC datetime;
							DECLARE @parameter nvarchar(max);
							DECLARE @processingEnded datetime;
							DECLARE @processingEndedUTC datetime;
							DECLARE @processingId int;
							DECLARE @stmt nvarchar(max);
							DECLARE @task nvarchar(128);
							DECLARE @thisTask nvarchar(128);
							DECLARE @timeNow time(0);
							DECLARE @toTime time(0);
							DECLARE @version nvarchar(128);

							SET @thisTask = OBJECT_NAME(@@PROCID);

							DECLARE sCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT s.Enabled, s.Id, s.Name, s.Task, s.Parameter, s.ExecutionDelaySec, s.FromTime, s.ToTime, s.Monday, s.Tuesday, s.Wednesday, s.Thursday, s.Friday, s.Saturday, s.Sunday, s.LastStartedUTC, s.LastExecutedUTC
							FROM dbo.fhsmSchedules AS s
							WHERE (s.DeploymentStatus = 0)
							ORDER BY s.Task, s.Name;

							OPEN sCur;
			'';
			SET @stmt += ''

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM sCur
								INTO @enabled, @id, @name, @task, @parameter, @executionDelaySec, @fromTime, @toTime, @monday, @tuesday, @wednesday, @thursday, @friday, @saturday, @sunday, @lastStartedUTC, @lastExecutedUTC;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								--
								-- NULL parameter if it is an empty string. Makes the log nicer
								--
								SET @parameter = NULLIF(@parameter, '''''''''''''''');

								-- Update time for every loop
								SELECT
									@now = SYSDATETIME()
									,@nowUTC = SYSUTCDATETIME();
								SET @timeNow = CAST(@now AS time(0));

								IF	(@test = 1)
									OR (
										(@enabled = 1)
										AND (@timeNow >= @fromTime) AND (@timeNow <= @toTime)
										AND (
											(@lastStartedUTC IS NULL)
											OR (DATEADD(SECOND, ABS(@executionDelaySec), DATEADD(MILLISECOND, -DATEPART(MILLISECOND, @lastStartedUTC), @lastStartedUTC)) < @nowUTC)
										)
										AND ((
											CASE DATEPART(WEEKDAY, @now)
												WHEN 1 THEN @sunday
												WHEN 2 THEN @monday
												WHEN 3 THEN @tuesday
												WHEN 4 THEN @wednesday
												WHEN 5 THEN @thursday
												WHEN 6 THEN @friday
												WHEN 7 THEN @saturday
											END
										) = 1)
									)
								BEGIN
			'';
			SET @stmt += ''
									BEGIN TRY;
										UPDATE s
										SET s.LastStartedUTC = @nowUTC
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Id = @id);

										--
										-- Insert Processing record and remember the @id in the variable @processingId
										--
										SET @processingId = NULL;
										EXEC dbo.fhsmSPProcessing @name = @name, @task = @task, @version = NULL, @type = 0, @timestampUTC = @nowUTC, @timestamp = @now, @id = @processingId OUTPUT;

										--
										-- Insert Debug message and remember the @id in the variable @logId
										--
										SET @logId = NULL;
										SET @message = @thisTask + CASE WHEN (@test = 1) THEN '''''''' TEST'''''''' ELSE '''''''''''''''' END + '''''''' executing '''''''' + @task + '''''''' - '''''''' + @name + COALESCE('''''''' - '''''''' + @parameter, '''''''''''''''');
										EXEC dbo.fhsmSPLog @name = @name, @version = NULL, @task = @task, @type = ''''''''Debug'''''''', @message = @message, @id = @logId OUTPUT;

										SET @stmt = ''''''''EXEC '''''''' + @task + '''''''' @name = @name, @version = @version OUTPUT;'''''''';
										EXEC sp_executesql
											@stmt
											,N''''''''@name nvarchar(128), @version nvarchar(128) OUTPUT''''''''
											,@name = @name, @version = @version OUTPUT;

										UPDATE s
										SET
											s.LastExecutedUTC = SYSUTCDATETIME()
											,s.LastErrorMessage = NULL
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Id = @id);

										--
										-- Update Processing record from before execution with @version, @processingEndedUTC and @processingEnded
										--
										SELECT
											@processingEndedUTC = SYSUTCDATETIME()
											,@processingEnded = SYSDATETIME();
										EXEC dbo.fhsmSPProcessing @name = @name, @task = @task, @version = @version, @type = 0, @timestampUTC = @processingEndedUTC, @timestamp = @processingEnded, @id = @processingId OUTPUT;

										--
										-- Update Debug log from before execution with @version
										--
										SET @message = @thisTask + CASE WHEN (@test = 1) THEN '''''''' TEST'''''''' ELSE '''''''''''''''' END + '''''''' executing '''''''' + @task + '''''''' - '''''''' + @name + COALESCE('''''''' - '''''''' + @parameter, '''''''''''''''');
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @task, @type = ''''''''Debug'''''''', @message = @message, @id = @logId OUTPUT;

										--
										-- Insert Info message
										--
										SET @message = @thisTask + CASE WHEN (@test = 1) THEN '''''''' TEST'''''''' ELSE '''''''''''''''' END + '''''''' executed '''''''' + @task + '''''''' - '''''''' + @name + COALESCE('''''''' - '''''''' + @parameter, '''''''''''''''');
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @task, @type = ''''''''Info'''''''', @message = @message;
									END TRY
									BEGIN CATCH
										SET @errorMsg = ERROR_MESSAGE();

										UPDATE s
										SET
											s.LastExecutedUTC = SYSUTCDATETIME()
											,s.LastErrorMessage = @errorMsg
										FROM dbo.fhsmSchedules AS s
										WHERE (s.Id = @id);

										SET @message = @thisTask + '''''''' executing '''''''' + @task + '''''''' - '''''''' + @name + '''''''' failed due to - '''''''' + @errorMsg;
										EXEC dbo.fhsmSPLog @name = @name, @task = @task, @type = ''''''''Error'''''''', @message = @message;
									END CATCH;
								END;
							END;

							CLOSE sCur;
							DEALLOCATE sCur;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPSchedules
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPSchedules'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create or alter stored procedure dbo.fhsmSPUpdateDimensions
	--
	BEGIN
		BEGIN
			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

				DECLARE @stmt nvarchar(max);

				IF OBJECT_ID(''''dbo.fhsmSPUpdateDimensions'''', ''''P'''') IS NULL
				BEGIN
					RAISERROR(''''Creating stub stored procedure dbo.fhsmSPUpdateDimensions'''', 0, 1) WITH NOWAIT;

					EXEC(''''CREATE PROC dbo.fhsmSPUpdateDimensions AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;

				--
				-- Alter dbo.fhsmSPUpdateDimensions
				--
				BEGIN
					RAISERROR(''''Alter stored procedure dbo.fhsmSPUpdateDimensions'''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER PROC dbo.fhsmSPUpdateDimensions(
							@table nvarchar(128) = NULL
						)
						AS
						BEGIN
							SET NOCOUNT ON;
			'';
			SET @stmt += ''

							DECLARE @currentDimensionName nvarchar(128);
							DECLARE @dimensionKey nvarchar(128);
							DECLARE @dimensionName nvarchar(128);
							DECLARE @dimensionStmt nvarchar(max);
							DECLARE @edition nvarchar(128);
							DECLARE @firstTable bit;
							DECLARE @indexName nvarchar(128);
							DECLARE @indexStmt nvarchar(max);
							DECLARE @myUserName nvarchar(128);
							DECLARE @nowUTC datetime;
							DECLARE @nowUTCStr nvarchar(128);
							DECLARE @outputColumn1 nvarchar(128);
							DECLARE @outputColumn2 nvarchar(128);
							DECLARE @outputColumn3 nvarchar(128);
							DECLARE @outputColumn4 nvarchar(128);
							DECLARE @outputColumn5 nvarchar(128);
							DECLARE @outputColumn6 nvarchar(128);
							DECLARE @pbiSchema nvarchar(128);
							DECLARE @productEndPos int;
							DECLARE @productStartPos int;
							DECLARE @productVersion nvarchar(128);
							DECLARE @productVersion1 int;
							DECLARE @productVersion2 int;
							DECLARE @productVersion3 int;
							DECLARE @srcAlias nvarchar(128);
							DECLARE @srcColumn1 nvarchar(128);
							DECLARE @srcColumn2 nvarchar(128);
							DECLARE @srcColumn3 nvarchar(128);
							DECLARE @srcColumn4 nvarchar(128);
							DECLARE @srcColumn5 nvarchar(128);
							DECLARE @srcColumn6 nvarchar(128);
							DECLARE @srcDateColumn nvarchar(128);
							DECLARE @srcTable nvarchar(128);
							DECLARE @srcWhere nvarchar(max);
							DECLARE @tableCompressionStmt nvarchar(max);
							DECLARE @version nvarchar(128);

							SET @myUserName = SUSER_NAME();
							SET @nowUTC = SYSUTCDATETIME();
							SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
							SET @version = '''''''''' + @version + '''''''''';

							SET @productVersion = CAST(SERVERPROPERTY(''''''''ProductVersion'''''''') AS nvarchar);
							SET @productStartPos = 1;
							SET @productEndPos = CHARINDEX(''''''''.'''''''', @productVersion, @productStartPos);
							SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
							SET @productStartPos = @productEndPos + 1;
							SET @productEndPos = CHARINDEX(''''''''.'''''''', @productVersion, @productStartPos);
							SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
							SET @productStartPos = @productEndPos + 1;
							SET @productEndPos = CHARINDEX(''''''''.'''''''', @productVersion, @productStartPos);
							SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

							SET @pbiSchema = dbo.fhsmFNGetConfiguration(''''''''PBISchema'''''''');
			'';
			SET @stmt += ''
							--
							-- Check if SQL version allows to use data compression
							--
							BEGIN
								SET @tableCompressionStmt = '''''''''''''''';

								SET @edition = CAST(SERVERPROPERTY(''''''''Edition'''''''') AS nvarchar);

								IF (@edition = ''''''''SQL Azure'''''''')
									OR (SUBSTRING(@edition, 1, CHARINDEX('''''''' '''''''', @edition)) = ''''''''Developer'''''''')
									OR (SUBSTRING(@edition, 1, CHARINDEX('''''''' '''''''', @edition)) = ''''''''Enterprise'''''''')
									OR (@productVersion1 > 13)
									OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
									OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
								BEGIN
									SET @tableCompressionStmt = '''''''' WITH (DATA_COMPRESSION = PAGE)'''''''';
								END;
							END;
			'';
			SET @stmt += ''
							--
							-- Create indexes based upon dbo.fhsmDimensions
							--
							BEGIN
								DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
								SELECT DISTINCT d.SrcTable, d.SrcColumn1, d.SrcColumn2, d.SrcColumn3, d.SrcColumn4, d.SrcColumn5, d.SrcColumn6
								FROM dbo.fhsmDimensions AS d
								INNER JOIN (
									SELECT DISTINCT d.DimensionName
									FROM dbo.fhsmDimensions AS d
								) AS modifiedSrcTables ON (modifiedSrcTables.DimensionName = d.DimensionName)
								ORDER BY d.SrcTable, d.SrcColumn6 DESC, d.SrcColumn5 DESC, d.SrcColumn4 DESC, d.SrcColumn3 DESC, d.SrcColumn2 DESC, d.SrcColumn1 DESC;

								OPEN dCur;

								SET @currentDimensionName = '''''''';
								SET @dimensionStmt = '''''''';
								SET @firstTable = 1;

								WHILE (1 = 1)
								BEGIN
									FETCH NEXT FROM dCur
									INTO @srcTable, @srcColumn1, @srcColumn2, @srcColumn3, @srcColumn4, @srcColumn5, @srcColumn6

									IF (@@FETCH_STATUS <> 0)
									BEGIN
										BREAK;
									END;

									SET @srcColumn1 = dbo.[fhsmFNParseDimensionColumn](@srcColumn1);
									SET @srcColumn2 = dbo.[fhsmFNParseDimensionColumn](@srcColumn2);
									SET @srcColumn3 = dbo.[fhsmFNParseDimensionColumn](@srcColumn3);
									SET @srcColumn4 = dbo.[fhsmFNParseDimensionColumn](@srcColumn4);
									SET @srcColumn5 = dbo.[fhsmFNParseDimensionColumn](@srcColumn5);
									SET @srcColumn6 = dbo.[fhsmFNParseDimensionColumn](@srcColumn6);

									SET @indexName =
										''''''''NCAuto_'''''''' + PARSENAME(@srcTable, 1) + ''''''''_''''''''
											+ PARSENAME(@srcColumn1, 1)
											+ COALESCE(''''''''_'''''''' + PARSENAME(@srcColumn2, 1), '''''''''''''''')
											+ COALESCE(''''''''_'''''''' + PARSENAME(@srcColumn3, 1), '''''''''''''''')
											+ COALESCE(''''''''_'''''''' + PARSENAME(@srcColumn4, 1), '''''''''''''''')
											+ COALESCE(''''''''_'''''''' + PARSENAME(@srcColumn5, 1), '''''''''''''''')
											+ COALESCE(''''''''_'''''''' + PARSENAME(@srcColumn6, 1), '''''''''''''''');

									SET @indexStmt = ''''''''
										SET ANSI_WARNINGS OFF;

										DECLARE @coveringIndexExists int;
										DECLARE @indexName nvarchar(128);
										DECLARE @stmt nvarchar(max);
			'';
			SET @stmt += ''
										DECLARE iCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
										SELECT i.name AS IndexName
										FROM '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.indexes AS i
										INNER JOIN '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.objects AS o ON (o.object_id = i.object_id)
										INNER JOIN '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.schemas AS sch ON (sch.schema_id = o.schema_id)
										WHERE (sch.name = '''''''''''''''''''''''' + PARSENAME(@srcTable, 2) + '''''''''''''''''''''''') AND (o.name = '''''''''''''''''''''''' + PARSENAME(@srcTable, 1) + '''''''''''''''''''''''')
										ORDER BY i.name;

										OPEN iCur;

										SET @coveringIndexExists = 0;

										WHILE (1 = 1)
										BEGIN
											FETCH NEXT FROM iCur
											INTO @indexName;

											IF (@@FETCH_STATUS <> 0)
											BEGIN
												BREAK;
											END;

											IF EXISTS (
												SELECT *
												FROM (
													SELECT
														i.name,
														MAX(CASE WHEN (ic.key_ordinal = 1) THEN c.name END) AS Column1,
														MAX(CASE WHEN (ic.key_ordinal = 2) THEN c.name END) AS Column2,
														MAX(CASE WHEN (ic.key_ordinal = 3) THEN c.name END) AS Column3,
														MAX(CASE WHEN (ic.key_ordinal = 4) THEN c.name END) AS Column4,
														MAX(CASE WHEN (ic.key_ordinal = 5) THEN c.name END) AS Column5,
														MAX(CASE WHEN (ic.key_ordinal = 6) THEN c.name END) AS Column6
														  FROM '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.indexes AS i
													INNER JOIN '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.index_columns AS ic ON (ic.object_id = i.object_id) AND (ic.index_id = i.index_id)
													INNER JOIN '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
													INNER JOIN '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.objects AS o ON (o.object_id = c.object_id)
													INNER JOIN '''''''' + COALESCE(QUOTENAME(PARSENAME(@srcTable, 3)) + ''''''''.'''''''', '''''''''''''''') + ''''''''sys.schemas AS sch ON (sch.schema_id = o.schema_id)
													WHERE (sch.name = '''''''''''''''''''''''' + PARSENAME(@srcTable, 2) + '''''''''''''''''''''''') AND (o.name = '''''''''''''''''''''''' + PARSENAME(@srcTable, 1) + '''''''''''''''''''''''') AND (i.name = @indexName)
													GROUP BY i.name
												) AS a
												WHERE (1 = 1)
													AND (a.Column1 = PARSENAME(@srcColumn1, 1))
													AND ((a.Column2 = PARSENAME(@srcColumn2, 1)) OR (PARSENAME(@srcColumn2, 1) IS NULL))
													AND ((a.Column3 = PARSENAME(@srcColumn3, 1)) OR (PARSENAME(@srcColumn3, 1) IS NULL))
													AND ((a.Column4 = PARSENAME(@srcColumn4, 1)) OR (PARSENAME(@srcColumn4, 1) IS NULL))
													AND ((a.Column5 = PARSENAME(@srcColumn5, 1)) OR (PARSENAME(@srcColumn5, 1) IS NULL))
													AND ((a.Column6 = PARSENAME(@srcColumn6, 1)) OR (PARSENAME(@srcColumn6, 1) IS NULL))
											)
											BEGIN
												SET @coveringIndexExists = 1;
												BREAK;
											END;
										END;

										CLOSE iCur;
										DEALLOCATE iCur;
			'';
			SET @stmt += ''
										IF (@coveringIndexExists = 0)
										BEGIN
											SET @stmt = ''''''''''''''''Adding index ['''''''' + @indexName + ''''''''] to table '''''''' + @srcTable + '''''''''''''''''''''''';
											RAISERROR(@stmt, 0, 1) WITH NOWAIT;

											SET @stmt = ''''''''''''''''
												CREATE NONCLUSTERED INDEX ''''''''
												+ ''''''''['''''''' + @indexName + ''''''''] ON '''''''' + @srcTable
												+ ''''''''(''''''''
													+ PARSENAME(@srcColumn1, 1)
													+ COALESCE('''''''', '''''''' + PARSENAME(@srcColumn2, 1), '''''''''''''''')
													+ COALESCE('''''''', '''''''' + PARSENAME(@srcColumn3, 1), '''''''''''''''')
													+ COALESCE('''''''', '''''''' + PARSENAME(@srcColumn4, 1), '''''''''''''''')
													+ COALESCE('''''''', '''''''' + PARSENAME(@srcColumn5, 1), '''''''''''''''')
													+ COALESCE('''''''', '''''''' + PARSENAME(@srcColumn6, 1), '''''''''''''''')
												+ '''''''')'''''''' + @tableCompressionStmt + '''''''';
											'''''''''''''''';
											EXEC(@stmt);
										END;
									'''''''';

									EXEC sp_executesql
										@indexStmt
										,N''''''''@srcColumn1 nvarchar(128), @srcColumn2 nvarchar(128), @srcColumn3 nvarchar(128), @srcColumn4 nvarchar(128), @srcColumn5 nvarchar(128), @srcColumn6 nvarchar(128)''''''''
										,@srcColumn1 = @srcColumn1
										,@srcColumn2 = @srcColumn2
										,@srcColumn3 = @srcColumn3
										,@srcColumn4 = @srcColumn4
										,@srcColumn5 = @srcColumn5
										,@srcColumn6 = @srcColumn6;
								END;

								CLOSE dCur;
								DEALLOCATE dCur;
							END;
			'';
			SET @stmt += ''
							--
							-- Create Time dimension if it does not exist
							--
							BEGIN
								SET @dimensionStmt = ''''''''
									DECLARE @stmt nvarchar(max);

									IF OBJECT_ID('''''''''''''''''''''''' + QUOTENAME(@pbiSchema) + ''''''''.Time'''''''''''''''', ''''''''''''''''V'''''''''''''''') IS NULL
									BEGIN
										SET @stmt = ''''''''''''''''
											EXEC(''''''''''''''''''''''''''''''''CREATE VIEW '''''''' + QUOTENAME(@pbiSchema) + ''''''''.Time AS SELECT ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''dummy'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' AS Txt'''''''''''''''''''''''''''''''');
										'''''''''''''''';
										EXEC(@stmt);
									END;

									--
									-- Alter fact Time
									--
									SET @stmt = ''''''''''''''''
										ALTER VIEW '''''''' + QUOTENAME(@pbiSchema) + ''''''''.Time
										AS
										--
										-- This view is auto generated by dbo.fhsmSPUpdateDimensions
										--
										WITH
										L0 AS (SELECT 1 AS c UNION ALL SELECT 1)
										,L1 AS (SELECT 1 AS c FROM L0 AS A CROSS JOIN L0 AS B)
										,L2 AS (SELECT 1 AS c FROM L1 AS A CROSS JOIN L1 AS B)
										,L3 AS (SELECT 1 AS c FROM L2 AS A CROSS JOIN L2 AS B)
										,L4 AS (SELECT 1 AS c FROM L3 AS A CROSS JOIN L3 AS B)
										,L5 AS (SELECT 1 AS c FROM L4 AS A CROSS JOIN L4 AS B)
										,Nums AS(SELECT ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS n FROM L5)
										,RawTime AS (
											SELECT
												Nums.n - 1 AS TimeKey
												,(Nums.n - 1) / (60 * 60) AS Hour
												,((Nums.n - 1) / 60) % 60 AS Minute
												,(Nums.n - 1) % 60 AS Second
											FROM Nums
											WHERE Nums.n <= (24 * 60 * 60)
										)
										SELECT
											rt.TimeKey
											,rt.Hour
											,rt.Minute
											,rt.Second
											,RIGHT(''''''''''''''''''''''''''''''''0'''''''''''''''''''''''''''''''' + CAST(rt.Hour AS nvarchar), 2)
												+ '''''''''''''''''''''''''''''''':''''''''''''''''''''''''''''''''
												+ RIGHT(''''''''''''''''''''''''''''''''0'''''''''''''''''''''''''''''''' + CAST(rt.Minute AS nvarchar), 2)
												+ '''''''''''''''''''''''''''''''':''''''''''''''''''''''''''''''''
												+ RIGHT(''''''''''''''''''''''''''''''''0'''''''''''''''''''''''''''''''' + CAST(rt.Second AS nvarchar), 2)
											AS Time
										FROM RawTime AS rt
									'''''''''''''''';
									EXEC(@stmt);
			'';
			SET @stmt += ''
									--
									-- Register extended properties
									--
									EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''''''''''View'''''''''''''''', @level0name = @pbiSchema, @level1name = ''''''''''''''''Time'''''''''''''''', @updateIfExists = 1, @propertyName = ''''''''''''''''FHSMVersion'''''''''''''''', @propertyValue = @version;
									EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''''''''''View'''''''''''''''', @level0name = @pbiSchema, @level1name = ''''''''''''''''Time'''''''''''''''', @updateIfExists = 0, @propertyName = ''''''''''''''''FHSMCreated'''''''''''''''', @propertyValue = @nowUTCStr;
									EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''''''''''View'''''''''''''''', @level0name = @pbiSchema, @level1name = ''''''''''''''''Time'''''''''''''''', @updateIfExists = 0, @propertyName = ''''''''''''''''FHSMCreatedBy'''''''''''''''', @propertyValue = @myUserName;
									EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''''''''''View'''''''''''''''', @level0name = @pbiSchema, @level1name = ''''''''''''''''Time'''''''''''''''', @updateIfExists = 1, @propertyName = ''''''''''''''''FHSMModified'''''''''''''''', @propertyValue = @nowUTCStr;
									EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''''''''''View'''''''''''''''', @level0name = @pbiSchema, @level1name = ''''''''''''''''Time'''''''''''''''', @updateIfExists = 1, @propertyName = ''''''''''''''''FHSMModifiedBy'''''''''''''''', @propertyValue = @myUserName;
								'''''''';
								EXEC sp_executesql
									@dimensionStmt
									,N''''''''@myUserName nvarchar(128), @nowUTCStr nvarchar(128), @pbiSchema nvarchar(128), @version nvarchar(128)''''''''
									,@myUserName = @myUserName
									,@nowUTCStr = @nowUTCStr
									,@pbiSchema = @pbiSchema
									,@version = @version;
							END;
			'';
			SET @stmt += ''

							--
							-- Create date dimension based upon dbo.fhsmDimensions
							--
							BEGIN
								-- Group by just in case different SrcDateColumn writings are registered for the same SrcTable
								DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
								SELECT
									d.SrcTable
									,MAX(d.SrcAlias) AS SrcAlias
									,MAX(d.SrcDateColumn) AS SrcDateColumn
								FROM dbo.fhsmDimensions AS d
								GROUP BY d.SrcTable
								ORDER BY d.SrcTable;

								OPEN dCur;

								SET @dimensionStmt = '''''''''''''''';
								SET @firstTable = 1;

								WHILE (1 = 1)
								BEGIN
									FETCH NEXT FROM dCur
									INTO @srcTable, @srcAlias, @srcDateColumn;
				'';
				SET @stmt += ''

									IF (@@FETCH_STATUS <> 0)
									BEGIN
										IF (@dimensionStmt <> '''''''''''''''')
										BEGIN
											--
											-- Terminate view statement
											--
											SET @dimensionStmt += ''''''''
													) AS a
												)
												,L0 AS (SELECT 1 AS c UNION ALL SELECT 1)
												,L1 AS (SELECT 1 AS c FROM L0 AS A CROSS JOIN L0 AS B)
												,L2 AS (SELECT 1 AS c FROM L1 AS A CROSS JOIN L1 AS B)
												,L3 AS (SELECT 1 AS c FROM L2 AS A CROSS JOIN L2 AS B)
												,L4 AS (SELECT 1 AS c FROM L3 AS A CROSS JOIN L3 AS B)
												,Nums AS(SELECT ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS n FROM L4)
												SELECT
													a.DateKey AS Date
													,DATEPART(YEAR, a.DateKey) * 100 + DATEPART(MONTH, a.DateKey) AS YearMonthKey
													,weekdays.DayNumberOfWeek
													,DATEPART(DAY, a.DateKey) AS DayNumberOfMonth
													,DATEPART(DY, a.DateKey) AS DayNumberOfYear
													,DATEPART(ISO_WEEK, a.DateKey) AS WeekNumber
													,''''''''''''''''Week '''''''''''''''' + CAST(DATEPART(ISO_WEEK, a.DateKey) AS nvarchar) AS WeekName
													,CASE WHEN weekdays.SQLWeekDay IN (7, 1) THEN 1 ELSE 0 END AS IsWeekend
													,weekdays.WeekdayName
													,weekdays.WeekdayAbbreviation
													,months.MonthNumber AS MonthNumber
													,months.MonthName
													,months.MonthAbbreviation
													,DATEPART(QUARTER, a.DateKey) AS QuarterNumber
													,''''''''''''''''Q'''''''''''''''' + CAST(DATEPART(QUARTER, a.DateKey) AS varchar) AS QuarterLabel
													,YEAR(a.DateKey) AS Year
													,months.MonthAbbreviation + ''''''''''''''''-'''''''''''''''' + CAST(YEAR(a.DateKey) AS nvarchar) AS MonthYearLabel
													,-1 * DATEDIFF(DAY, SYSDATETIME(), a.DateKey) AS DayIndex
				'';
				SET @stmt += ''
												FROM (
													SELECT
														DATEADD(DAY, Nums.n - 1, CAST((CAST(YearRange.MinYear AS nvarchar) + ''''''''''''''''-01-01T00:00:00.000'''''''''''''''') AS date)) AS DateKey
													FROM Nums
													CROSS APPLY YearRange
													WHERE (YEAR(DATEADD(DAY, Nums.n - 1,  CAST((CAST(YearRange.MinYear AS nvarchar) + ''''''''''''''''-01-01T00:00:00.000'''''''''''''''') AS date))) <= YearRange.MaxYear)
												) AS a
												LEFT OUTER JOIN (
													VALUES  (2, 1, ''''''''''''''''Monday'''''''''''''''',    ''''''''''''''''Mon''''''''''''''''),	
															(3, 2, ''''''''''''''''Tuesday'''''''''''''''',   ''''''''''''''''Tue''''''''''''''''),
															(4, 3, ''''''''''''''''Wednesday'''''''''''''''', ''''''''''''''''Wed''''''''''''''''),
															(5, 4, ''''''''''''''''Thursday'''''''''''''''',  ''''''''''''''''Thu''''''''''''''''),
															(6, 5, ''''''''''''''''Friday'''''''''''''''',    ''''''''''''''''Fri''''''''''''''''),
															(7, 6, ''''''''''''''''Saturday'''''''''''''''',  ''''''''''''''''Sat''''''''''''''''),
															(1, 7, ''''''''''''''''Sunday'''''''''''''''',    ''''''''''''''''Sun'''''''''''''''')
												) AS weekdays (SQLWeekDay, DayNumberOfWeek, WeekdayName, WeekdayAbbreviation)
													ON (weekdays.SQLWeekDay = DATEPART(WEEKDAY, a.DateKey))
												LEFT OUTER JOIN (
													VALUES  (1,  ''''''''''''''''January'''''''''''''''',   ''''''''''''''''Jan''''''''''''''''),
															(2,  ''''''''''''''''February'''''''''''''''',  ''''''''''''''''Feb''''''''''''''''),
															(3,  ''''''''''''''''March'''''''''''''''',     ''''''''''''''''Mar''''''''''''''''),
															(4,  ''''''''''''''''April'''''''''''''''',     ''''''''''''''''Apr''''''''''''''''),
															(5,  ''''''''''''''''May'''''''''''''''',       ''''''''''''''''May''''''''''''''''),
															(6,  ''''''''''''''''June'''''''''''''''',      ''''''''''''''''Jun''''''''''''''''),
															(7,  ''''''''''''''''July'''''''''''''''',      ''''''''''''''''Jul''''''''''''''''),
															(8,  ''''''''''''''''August'''''''''''''''',    ''''''''''''''''Aug''''''''''''''''),
															(9,  ''''''''''''''''September'''''''''''''''', ''''''''''''''''Sep''''''''''''''''),
															(10, ''''''''''''''''October'''''''''''''''',   ''''''''''''''''Oct''''''''''''''''),
															(11, ''''''''''''''''November'''''''''''''''',  ''''''''''''''''Nov''''''''''''''''),
															(12, ''''''''''''''''December'''''''''''''''',  ''''''''''''''''Dec'''''''''''''''')
												) AS months (MonthNumber, MonthName, MonthAbbreviation)
													ON (months.MonthNumber = DATEPART(MONTH, a.DateKey));
											'''''''';
				'';
				SET @stmt += ''

											--
											-- Create dimension
											--
											EXEC(@dimensionStmt);

											--
											-- Register extended properties
											--
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = ''''''''Date'''''''', @updateIfExists = 1, @propertyName = ''''''''FHSMVersion'''''''', @propertyValue = @version;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = ''''''''Date'''''''', @updateIfExists = 0, @propertyName = ''''''''FHSMCreated'''''''', @propertyValue = @nowUTCStr;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = ''''''''Date'''''''', @updateIfExists = 0, @propertyName = ''''''''FHSMCreatedBy'''''''', @propertyValue = @myUserName;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = ''''''''Date'''''''', @updateIfExists = 1, @propertyName = ''''''''FHSMModified'''''''', @propertyValue = @nowUTCStr;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = ''''''''Date'''''''', @updateIfExists = 1, @propertyName = ''''''''FHSMModifiedBy'''''''', @propertyValue = @myUserName;
										END;

										BREAK;
									END;
				'';
				SET @stmt += ''

									--
									-- Set header of view
									--
									IF (@dimensionStmt = '''''''''''''''')
									BEGIN
										SET @dimensionStmt = ''''''''
											IF OBJECT_ID('''''''''''''''''''''''' + QUOTENAME(@pbiSchema) + ''''''''.Date'''''''''''''''', ''''''''''''''''V'''''''''''''''') IS NULL
											BEGIN
												EXEC(''''''''''''''''CREATE VIEW '''''''' + QUOTENAME(@pbiSchema) + ''''''''.Date AS SELECT ''''''''''''''''''''''''''''''''dummy'''''''''''''''''''''''''''''''' AS Txt'''''''''''''''');
											END;
										'''''''';
										EXEC(@dimensionStmt);

										SET @dimensionStmt = ''''''''
											ALTER VIEW '''''''' + QUOTENAME(@pbiSchema) + ''''''''.Date
											AS
											--
											-- This view is auto generated by dbo.fhsmSPUpdateDimensions
											--
											WITH YearRange AS
											(
												SELECT
													MIN(a.MinYear) AS MinYear
													,MAX(a.MaxYear) AS MaxYear
												FROM (
										'''''''';
									END;
				'';
				SET @stmt += ''

									IF (@firstTable = 0)
									BEGIN
										SET @dimensionStmt += ''''''''
											UNION
										'''''''';
									END;

									SET @firstTable = 0;

									SET @dimensionStmt += ''''''''
										SELECT
											DATEPART(YEAR, COALESCE(MIN('''''''' + @srcDateColumn + ''''''''), SYSDATETIME())) AS MinYear
											,DATEPART(YEAR, COALESCE(MAX('''''''' + @srcDateColumn + ''''''''), SYSDATETIME())) AS MaxYear
										FROM '''''''' + @srcTable + '''''''' AS '''''''' + @srcAlias + ''''''''
									'''''''';
								END;

								CLOSE dCur;
								DEALLOCATE dCur;
							END;

							--
							-- Create dynamic dimension based upon dbo.fhsmDimensions
							--
							BEGIN
								DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
								SELECT d.DimensionName, d.DimensionKey, d.SrcTable, d.SrcAlias, d.SrcWhere, d.SrcColumn1, d.SrcColumn2, d.SrcColumn3, d.SrcColumn4, d.SrcColumn5, d.SrcColumn6, d.OutputColumn1, d.OutputColumn2, d.OutputColumn3, d.OutputColumn4, d.OutputColumn5, d.OutputColumn6
								FROM dbo.fhsmDimensions AS d
								INNER JOIN (
									SELECT DISTINCT d.DimensionName
									FROM dbo.fhsmDimensions AS d
									WHERE ((d.SrcTable = @table) OR (@table IS NULL))
								) AS modifiedSrcTables ON (modifiedSrcTables.DimensionName = d.DimensionName)
								ORDER BY d.DimensionName, d.SrcTable;

								OPEN dCur;

								SET @currentDimensionName = '''''''''''''''';
								SET @dimensionStmt = '''''''''''''''';
								SET @firstTable = 1;
				'';
				SET @stmt += ''

								WHILE (1 = 1)
								BEGIN
									FETCH NEXT FROM dCur
									INTO @dimensionName, @dimensionKey, @srcTable, @srcAlias, @srcWhere, @srcColumn1, @srcColumn2, @srcColumn3, @srcColumn4, @srcColumn5, @srcColumn6, @outputColumn1, @outputColumn2, @outputColumn3, @outputColumn4, @outputColumn5, @outputColumn6;

									IF (@@FETCH_STATUS <> 0)
									BEGIN
										IF (@currentDimensionName <> '''''''''''''''')
										BEGIN
											--
											-- Terminate view statement
											--
											SET @dimensionStmt += ''''''''
												) AS a;
											'''''''';

											--
											-- Create @currentDimensionName
											--
											EXEC(@dimensionStmt);

											--
											-- Register extended properties
											--
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 1, @propertyName = ''''''''FHSMVersion'''''''', @propertyValue = @version;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 0, @propertyName = ''''''''FHSMCreated'''''''', @propertyValue = @nowUTCStr;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 0, @propertyName = ''''''''FHSMCreatedBy'''''''', @propertyValue = @myUserName;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 1, @propertyName = ''''''''FHSMModified'''''''', @propertyValue = @nowUTCStr;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 1, @propertyName = ''''''''FHSMModifiedBy'''''''', @propertyValue = @myUserName;

											-- Zero variable
											SET @dimensionStmt = '''''''''''''''';
											SET @firstTable = 1;
										END;

										BREAK;
									END;
				'';
				SET @stmt += ''
									IF (@dimensionName <> @currentDimensionName)
									BEGIN
										IF (@currentDimensionName <> '''''''''''''''')
										BEGIN
											--
											-- Terminate view statement
											--
											SET @dimensionStmt += ''''''''
												) AS a;
											'''''''';

											--
											-- Create @currentDimensionName
											--
											EXEC(@dimensionStmt);

											--
											-- Register extended properties
											--
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 1, @propertyName = ''''''''FHSMVersion'''''''', @propertyValue = @version;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 0, @propertyName = ''''''''FHSMCreated'''''''', @propertyValue = @nowUTCStr;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 0, @propertyName = ''''''''FHSMCreatedBy'''''''', @propertyValue = @myUserName;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 1, @propertyName = ''''''''FHSMModified'''''''', @propertyValue = @nowUTCStr;
											EXEC dbo.fhsmSPExtendedProperties @objectType = ''''''''View'''''''', @level0name = @pbiSchema, @level1name = @currentDimensionName, @updateIfExists = 1, @propertyName = ''''''''FHSMModifiedBy'''''''', @propertyValue = @myUserName;

											-- Zero variable
											SET @dimensionStmt = '''''''''''''''';
											SET @firstTable = 1;
										END;
				'';
				SET @stmt += ''

										--
										-- Setup new view - create stub and prepare the statement for the real view
										--
										BEGIN
											SET @dimensionStmt = ''''''''
												IF OBJECT_ID('''''''''''''''''''''''' + QUOTENAME(@pbiSchema) + ''''''''.'''''''' + QUOTENAME(@dimensionName) + '''''''''''''''''''''''', ''''''''''''''''V'''''''''''''''') IS NULL
												BEGIN
													EXEC(''''''''''''''''CREATE VIEW '''''''' + QUOTENAME(@pbiSchema) + ''''''''.'''''''' + QUOTENAME(@dimensionName) + '''''''' AS SELECT ''''''''''''''''''''''''''''''''dummy'''''''''''''''''''''''''''''''' AS Txt'''''''''''''''');
												END;
											'''''''';
											EXEC(@dimensionStmt);

											SET @dimensionStmt = ''''''''
												ALTER VIEW '''''''' + QUOTENAME(@pbiSchema) + ''''''''.'''''''' + QUOTENAME(@dimensionName) + ''''''''
												AS
												--
												-- This view is auto generated by dbo.fhsmSPUpdateDimensions
												--
												SELECT
													a.'''''''' + QUOTENAME(@outputColumn1)
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn2), '''''''''''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn3), '''''''''''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn4), '''''''''''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn5), '''''''''''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn6), '''''''''''''''') + ''''''''
													,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.'''''''' + QUOTENAME(@outputColumn1)
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn2), '''''''', DEFAULT'''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn3), '''''''', DEFAULT'''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn4), '''''''', DEFAULT'''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn5), '''''''', DEFAULT'''''''')
														+ COALESCE('''''''', a.'''''''' + QUOTENAME(@outputColumn6), '''''''', DEFAULT'''''''')
													+ '''''''') AS k) AS '''''''' + QUOTENAME(@dimensionKey) + ''''''''
												FROM (
											'''''''';
										END;
									END;
				'';
				SET @stmt += ''
									IF (@firstTable = 0)
									BEGIN
										-- Second time we are here
										SET @dimensionStmt += ''''''''
											UNION
										'''''''';
									END;

									SET @dimensionStmt += ''''''''
										SELECT
											DISTINCT
											'''''''' + @srcColumn1 + '''''''' COLLATE DATABASE_DEFAULT AS '''''''' + QUOTENAME(@outputColumn1)
												+ COALESCE('''''''', '''''''' + @srcColumn2 + '''''''' COLLATE DATABASE_DEFAULT AS '''''''' + QUOTENAME(@outputColumn2), '''''''''''''''')
												+ COALESCE('''''''', '''''''' + @srcColumn3 + '''''''' COLLATE DATABASE_DEFAULT AS '''''''' + QUOTENAME(@outputColumn3), '''''''''''''''')
												+ COALESCE('''''''', '''''''' + @srcColumn4 + '''''''' COLLATE DATABASE_DEFAULT AS '''''''' + QUOTENAME(@outputColumn4), '''''''''''''''')
												+ COALESCE('''''''', '''''''' + @srcColumn5 + '''''''' COLLATE DATABASE_DEFAULT AS '''''''' + QUOTENAME(@outputColumn5), '''''''''''''''')
												+ COALESCE('''''''', '''''''' + @srcColumn6 + '''''''' COLLATE DATABASE_DEFAULT AS '''''''' + QUOTENAME(@outputColumn6), '''''''''''''''') + ''''''''
										FROM '''''''' + @srcTable + '''''''' AS '''''''' + @srcAlias + ''''''''
										'''''''' + COALESCE(@srcWhere, '''''''''''''''') + ''''''''
									'''''''';

									SET @currentDimensionName = @dimensionName;
									SET @firstTable = 0;
								END;

								CLOSE dCur;
								DEALLOCATE dCur;
							END;

							RETURN 0;
						END;
					'''';
					EXEC(@stmt);
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPUpdateDimensions
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPUpdateDimensions'';

			SET @stmt = ''
				USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
				DECLARE @objName nvarchar(128);
				DECLARE @schName nvarchar(128);

				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''''Procedure'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
			'';
			EXEC sp_executesql
				@stmt
				,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
				,@objectName = @objectName
				,@version = @version
				,@nowUTCStr = @nowUTCStr
				,@myUserName = @myUserName;
		END;
	END;

	--
	-- Create views
	--
	BEGIN
		--
		-- Create view @pbiSchema.[Configurations]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Configurations'') + '''''', ''''V'''') IS NULL
					BEGIN
						RAISERROR(''''Creating stub view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Configurations'') + '''''', 0, 1) WITH NOWAIT;

						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Configurations'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @stmt nvarchar(max);

					RAISERROR(''''Alter view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Configurations'') + '''''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Configurations'') + ''
						AS
						SELECT
							c.[Key]
							,c.Value
						FROM dbo.fhsmConfigurations AS c;
					'''';
					EXEC(@stmt);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Configurations]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Configurations'');

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @objName nvarchar(128);
					DECLARE @schName nvarchar(128);

					SET @objName = PARSENAME(@objectName, 1);
					SET @schName = PARSENAME(@objectName, 2);

					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
				'';
				EXEC sp_executesql
					@stmt
					,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
					,@objectName = @objectName
					,@version = @version
					,@nowUTCStr = @nowUTCStr
					,@myUserName = @myUserName;
			END;
		END;

		--
		-- Create view @pbiSchema.[Log]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Log'') + '''''', ''''V'''') IS NULL
					BEGIN
						RAISERROR(''''Creating stub view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Log'') + '''''', 0, 1) WITH NOWAIT;

						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Log'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @stmt nvarchar(max);

					RAISERROR(''''Alter view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Log'') + '''''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Log'') + ''
						AS
						SELECT
							l.Id
							,l.Name
							,l.Task
							,l.Type
							,l.Message
							,l.TimestampUTC, l.Timestamp
							,CAST(l.Timestamp AS date) AS Date
							,(DATEPART(HOUR, l.Timestamp) * 60 * 60) + (DATEPART(MINUTE, l.Timestamp) * 60) + (DATEPART(SECOND, l.Timestamp)) AS TimeKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(l.Task, l.Name, l.Version, DEFAULT, DEFAULT, DEFAULT) AS k) AS TaskNameVersionKey
						FROM dbo.fhsmLog AS l
						WHERE (1 = 1)
							AND (l.TimestampUTC > DATEADD(DAY, -1, (SELECT MAX(lMax.TimestampUTC) FROM dbo.fhsmLog AS lMax)))
							AND (
								(l.Type <> ''''''''Debug'''''''')
								OR (
									(l.Type = ''''''''Debug'''''''')
									AND (l.Version IS NOT NULL)
								)
							);
					'''';
					EXEC(@stmt);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Log]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Log'');

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @objName nvarchar(128);
					DECLARE @schName nvarchar(128);

					SET @objName = PARSENAME(@objectName, 1);
					SET @schName = PARSENAME(@objectName, 2);

					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
				'';
				EXEC sp_executesql
					@stmt
					,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
					,@objectName = @objectName
					,@version = @version
					,@nowUTCStr = @nowUTCStr
					,@myUserName = @myUserName;
			END;
		END;

		--
		-- Create view @pbiSchema.[Processing]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Processing'') + '''''', ''''V'''') IS NULL
					BEGIN
						RAISERROR(''''Creating stub view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Processing'') + '''''', 0, 1) WITH NOWAIT;

						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Processing'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @stmt nvarchar(max);

					RAISERROR(''''Alter view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Processing'') + '''''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Processing'') + ''
						AS
						SELECT
							p.Id
							,p.Type
							,DATEDIFF(MILLISECOND, p.StartedTimestampUTC, p.EndedTimestampUTC) AS DurationInMSec
							,CAST(p.StartedTimestamp AS date) AS Date
							,(DATEPART(HOUR, p.StartedTimestamp) * 60 * 60) + (DATEPART(MINUTE, p.StartedTimestamp) * 60) + (DATEPART(SECOND, p.StartedTimestamp)) AS TimeKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(p.Task, p.Name, p.Version, DEFAULT, DEFAULT, DEFAULT) AS k) AS TaskNameVersionKey
						FROM dbo.fhsmProcessing AS p
						WHERE (p.EndedTimestampUTC IS NOT NULL);
					'''';
					EXEC(@stmt);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Processing]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Processing'');

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @objName nvarchar(128);
					DECLARE @schName nvarchar(128);

					SET @objName = PARSENAME(@objectName, 1);
					SET @schName = PARSENAME(@objectName, 2);

					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
				'';
				EXEC sp_executesql
					@stmt
					,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
					,@objectName = @objectName
					,@version = @version
					,@nowUTCStr = @nowUTCStr
					,@myUserName = @myUserName;
			END;
		END;

		--
		-- Create view @pbiSchema.[Retentions]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Retentions'') + '''''', ''''V'''') IS NULL
					BEGIN
						RAISERROR(''''Creating stub view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Retentions'') + '''''', 0, 1) WITH NOWAIT;

						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Retentions'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @stmt nvarchar(max);

					RAISERROR(''''Alter view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Retentions'') + '''''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Retentions'') + ''
						AS
						SELECT
							r.Enabled
							,r.TableName AS [Table]
							,r.TimeColumn AS [Time column]
							,r.IsUtc AS [Is UTC]
							,r.Days
							,r.LastStartedUTC AS [Last started UTC]
							,r.LastExecutedUTC AS [Last executed UTC]
						FROM dbo.fhsmRetentions AS r;
					'''';
					EXEC(@stmt);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Retentions]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Retentions'');

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @objName nvarchar(128);
					DECLARE @schName nvarchar(128);

					SET @objName = PARSENAME(@objectName, 1);
					SET @schName = PARSENAME(@objectName, 2);

					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
				'';
				EXEC sp_executesql
					@stmt
					,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
					,@objectName = @objectName
					,@version = @version
					,@nowUTCStr = @nowUTCStr
					,@myUserName = @myUserName;
			END;
		END;

		--
		-- Create view @pbiSchema.[Schedules]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Schedules'') + '''''', ''''V'''') IS NULL
					BEGIN
						RAISERROR(''''Creating stub view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Schedules'') + '''''', 0, 1) WITH NOWAIT;

						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Schedules'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @stmt nvarchar(max);

					RAISERROR(''''Alter view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Schedules'') + '''''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Schedules'') + ''
						AS
						SELECT
							s.Enabled
							,s.Name
							,s.Task
							,s.Parameter
							,s.ExecutionDelaySec AS [Execution delay in sec.]
							,s.FromTime AS [From time]
							,s.ToTime AS [To time]
							,s.Monday, s.Tuesday, s.Wednesday, s.Thursday, s.Friday, s.Saturday, s.Sunday
							,s.LastStartedUTC AS [Last started UTC]
							,s.LastExecutedUTC AS [Last executed UTC]
							,s.LastErrorMessage
						FROM dbo.fhsmSchedules AS s
						WHERE (s.DeploymentStatus = 0);
					'''';
					EXEC(@stmt);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Schedules]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Schedules'');

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @objName nvarchar(128);
					DECLARE @schName nvarchar(128);

					SET @objName = PARSENAME(@objectName, 1);
					SET @schName = PARSENAME(@objectName, 2);

					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
				'';
				EXEC sp_executesql
					@stmt
					,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
					,@objectName = @objectName
					,@version = @version
					,@nowUTCStr = @nowUTCStr
					,@myUserName = @myUserName;
			END;
		END;

		--
		-- Create view @pbiSchema.[Junk dimensions]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';
			
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Junk dimensions'') + '''''', ''''V'''') IS NULL
					BEGIN
						RAISERROR(''''Creating stub view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Junk dimensions'') + '''''', 0, 1) WITH NOWAIT;

						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Junk dimensions'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @stmt nvarchar(max);

					RAISERROR(''''Alter view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Junk dimensions'') + '''''', 0, 1) WITH NOWAIT;

					SET @stmt = ''''
						ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Junk dimensions'') + ''
						AS
						SELECT
							 junkType.Category
							 ,junkType.Name
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(junkType.Category, junkType.Type, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS [Key]
						FROM (
									  SELECT 1 AS Category, ''''''''D'''''''' AS Type, ''''''''Database'''''''' AS Name
							UNION ALL SELECT 1 AS Category, ''''''''I'''''''' AS Type, ''''''''Differential database'''''''' AS Name
							UNION ALL SELECT 1 AS Category, ''''''''L'''''''' AS Type, ''''''''Log'''''''' AS Name
							UNION ALL SELECT 1 AS Category, ''''''''F'''''''' AS Type, ''''''''File/filegroup'''''''' AS Name
							UNION ALL SELECT 1 AS Category, ''''''''G'''''''' AS Type, ''''''''Differential file'''''''' AS Name
							UNION ALL SELECT 1 AS Category, ''''''''P'''''''' AS Type, ''''''''Partial'''''''' AS Name
							UNION ALL SELECT 1 AS Category, ''''''''Q'''''''' AS Type, ''''''''Differential partial'''''''' AS Name
						) AS junkType;
					'''';
					EXEC(@stmt);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Junk dimensions]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Junk dimensions'');

				SET @stmt = ''
					USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

					DECLARE @objName nvarchar(128);
					DECLARE @schName nvarchar(128);

					SET @objName = PARSENAME(@objectName, 1);
					SET @schName = PARSENAME(@objectName, 2);

					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMVersion'''', @propertyValue = @version;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreated'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''''FHSMCreatedBy'''', @propertyValue = @myUserName;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModified'''', @propertyValue = @nowUTCStr;
					EXEC dbo.fhsmSPExtendedProperties @objectType = ''''View'''', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''''FHSMModifiedBy'''', @propertyValue = @myUserName;
				'';
				EXEC sp_executesql
					@stmt
					,N''@objectName nvarchar(128), @version sql_variant, @nowUTCStr sql_variant, @myUserName sql_variant''
					,@objectName = @objectName
					,@version = @version
					,@nowUTCStr = @nowUTCStr
					,@myUserName = @myUserName;
			END;
		END;
	END;

	--
	-- Create SQL agent job if it not already exists
	--
	IF (@createSQLAgentJob = 1)
		AND NOT EXISTS (
			SELECT *
			FROM msdb.dbo.sysjobs AS sj
			WHERE (sj.name = @fhsqlAgentJobName)
		)
	BEGIN
		SET @stmt = ''
			RAISERROR(''''Creating SQL agent job '' + @fhSQLMonitorDatabase + '''''', 0, 1) WITH NOWAIT;

			EXEC msdb.dbo.sp_add_job
				@job_name = N'''''' + @fhsqlAgentJobName + ''''''
				,@enabled = 0
				,@notify_level_eventlog = 0
				,@notify_level_email = 2
				,@notify_level_page = 2
				,@delete_level = 0;

			EXEC msdb.dbo.sp_add_jobserver
				@job_name=N'''''' + @fhsqlAgentJobName + ''''''
				,@server_name = N'''''' + @@SERVERNAME + '''''';

			EXEC msdb.dbo.sp_add_jobstep
				@job_name = N'''''' + @fhsqlAgentJobName + ''''''
				,@step_name = N''''Run FHSQLMonitor''''
				,@step_id = 1
				,@cmdexec_success_code = 0
				,@on_success_action = 1
				,@on_fail_action = 2
				,@retry_attempts = 0
				,@retry_interval = 0
				,@os_run_priority = 0
				,@subsystem = N''''TSQL''''
				,@command = N''''EXEC dbo.fhsmSPSchedules;''''
				,@database_name = N'''''' + @fhSQLMonitorDatabase + ''''''
				,@flags = 0;

			EXEC msdb.dbo.sp_update_job
				@job_name = N'''''' + @fhsqlAgentJobName + ''''''
				,@enabled = 0
				,@start_step_id = 1
				,@notify_level_eventlog = 0
				,@notify_level_email = 2
				,@notify_level_page = 2
				,@delete_level = 0
				,@description = N''''''''
				,@notify_email_operator_name = N''''''''
				,@notify_page_operator_name = N'''''''';

			EXEC msdb.dbo.sp_add_jobschedule
				@job_name = N'''''' + @fhsqlAgentJobName + ''''''
				,@name = N'''''' + @fhsqlAgentJobName + ''''''
				,@enabled = 1
				,@freq_type = 4
				,@freq_interval = 1
				,@freq_subday_type = 2	-- seconds
				,@freq_subday_interval = 30
				,@freq_relative_interval = 0
				,@freq_recurrence_factor = 1
				,@active_start_date = 20200910
				,@active_end_date = 99991231
				,@active_start_time = 0
				,@active_end_time = 235959;
		'';
		EXEC(@stmt);
	END;

	--
	-- Register the agent job name in dbo.fhsmConfigurations
	--
	BEGIN
		SET @stmt = ''
			USE '' + QUOTENAME(@fhSQLMonitorDatabase) + '';

			WITH
			cfg([Key], Value) AS(
				SELECT
					''''AgentJobName''''
					,'''''' + @fhsqlAgentJobName + ''''''
			)
			MERGE dbo.fhsmConfigurations AS tgt
			USING cfg AS src ON (src.[Key] = tgt.[Key])
			WHEN MATCHED
				THEN UPDATE
					SET tgt.Value = src.Value
			WHEN NOT MATCHED BY TARGET
				THEN INSERT([Key], Value)
				VALUES(src.[Key], src.Value);
		'';
		EXEC(@stmt);
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @createSQLAgentJob = 1;',                                'SET @createSQLAgentJob = ' + CAST(@createSQLAgentJob AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @fhSQLMonitorDatabase = ''FHSQLMonitor'';',              'SET @fhSQLMonitorDatabase = ''' + @fhSQLMonitorDatabase + ''';');
SET @stmt = REPLACE(@stmt, 'SET @fhsqlAgentJobName = ''FHSQLMonitor in FHSQLMonitor'';', 'SET @fhsqlAgentJobName = ''' + @fhsqlAgentJobName + ''';');
SET @stmt = REPLACE(@stmt, 'SET @pbiSchema = ''FHSM'';',                                 'SET @pbiSchema = ''' + @pbiSchema + ''';');
SET @stmt = REPLACE(@stmt, 'SET @buildTimeStr = ''YYYY.MM.DD HH.MM.SS'';',               'SET @buildTimeStr = ''2025.08.05 19.42.19'';');
EXEC(@stmt);

--
-- File part:IndexOptimize-001-OlaHallengren-CommandLog.sql modified: 2025.06.16 09.09.14
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexOptimize-001'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
END;

--
-- Check if SQL version allows to use data compression
--
BEGIN
	SET @tableCompressionStmt = '''';

	SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

	SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);

	SET @productStartPos = 1;
	SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
	SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

	SET @productStartPos = @productEndPos + 1;
	SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
	SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

	SET @productStartPos = @productEndPos + 1;
	SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
	SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));

	IF (@edition = ''SQL Azure'')
		OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
		OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
		OR (@productVersion1 > 13)
		OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
		OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
	BEGIN
		SET @tableCompressionStmt = '', DATA_COMPRESSION = PAGE'';
	END;
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[CommandLog]'') AND type in (N''U''))
BEGIN
SET @stmt = ''
CREATE TABLE [dbo].[CommandLog](
  [ID] [int] IDENTITY(1,1) NOT NULL,
  [DatabaseName] [sysname] NULL,
  [SchemaName] [sysname] NULL,
  [ObjectName] [sysname] NULL,
  [ObjectType] [char](2) NULL,
  [IndexName] [sysname] NULL,
  [IndexType] [tinyint] NULL,
  [StatisticsName] [sysname] NULL,
  [PartitionNumber] [int] NULL,
  [ExtendedInfo] [xml] NULL,
  [Command] [nvarchar](max) NOT NULL,
  [CommandType] [nvarchar](60) NOT NULL,
  [StartTime] [datetime2](7) NOT NULL,
  [EndTime] [datetime2](7) NULL,
  [ErrorNumber] [int] NULL,
  [ErrorMessage] [nvarchar](max) NULL,
 CONSTRAINT [PK_CommandLog] PRIMARY KEY CLUSTERED
(
  [ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON'' + @tableCompressionStmt + '')
)
'';
EXEC(@stmt);
END
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:IndexOptimize-002-OlaHallengren-CommandExecute.sql modified: 2025.06.16 09.11.46
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexOptimize-002'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @returnValue int;
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[CommandExecute]'') AND type in (N''P'', N''PC''))
BEGIN
EXEC dbo.sp_executesql @statement = N''CREATE PROCEDURE [dbo].[CommandExecute] AS''
END

DECLARE @stmt nvarchar(max);
SET @stmt = ''
ALTER PROCEDURE [dbo].[CommandExecute]

@DatabaseContext nvarchar(max),
@Command nvarchar(max),
@CommandType nvarchar(max),
@Mode int,
@Comment nvarchar(max) = NULL,
@DatabaseName nvarchar(max) = NULL,
@SchemaName nvarchar(max) = NULL,
@ObjectName nvarchar(max) = NULL,
@ObjectType nvarchar(max) = NULL,
@IndexName nvarchar(max) = NULL,
@IndexType int = NULL,
@StatisticsName nvarchar(max) = NULL,
@PartitionNumber int = NULL,
@ExtendedInfo xml = NULL,
@LockMessageSeverity int = 16,
@ExecuteAsUser nvarchar(max) = NULL,
@LogToTable nvarchar(max),
@Execute nvarchar(max)

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source:  https://ola.hallengren.com                                                        //--
  --// License: https://ola.hallengren.com/license.html                                           //--
  --// GitHub:  https://github.com/olahallengren/sql-server-maintenance-solution                  //--
  --// Version: 2025-06-14 16:13:00                                                               //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)
  DECLARE @ErrorMessageOriginal nvarchar(max)
  DECLARE @Severity int

  DECLARE @Errors TABLE (ID int IDENTITY PRIMARY KEY,
                         [Message] nvarchar(max) NOT NULL,
                         Severity int NOT NULL,
                         [State] int)

  DECLARE @CurrentMessage nvarchar(max)
  DECLARE @CurrentSeverity int
  DECLARE @CurrentState int

  DECLARE @sp_executesql nvarchar(max) = QUOTENAME(@DatabaseContext) + ''''.sys.sp_executesql''''

  DECLARE @StartTime datetime2
  DECLARE @EndTime datetime2

  DECLARE @ID int

  DECLARE @Error int = 0
  DECLARE @ReturnCode int = 0

  DECLARE @EmptyLine nvarchar(max) = CHAR(9)

  DECLARE @RevertCommand nvarchar(max)

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT (SELECT [compatibility_level] FROM sys.databases WHERE [name] = DB_NAME()) >= 90
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The database '''' + QUOTENAME(DB_NAME()) + '''' has to be in compatibility level 90 or higher.'''', 16, 1
  END

  IF NOT (SELECT uses_ansi_nulls FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''ANSI_NULLS has to be set to ON for the stored procedure.'''', 16, 1
  END

  IF NOT (SELECT uses_quoted_identifier FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''QUOTED_IDENTIFIER has to be set to ON for the stored procedure.'''', 16, 1
  END

  IF @LogToTable = ''''Y'''' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = ''''U'''' AND schemas.[name] = ''''dbo'''' AND objects.[name] = ''''CommandLog'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The table CommandLog is missing. Download https://ola.hallengren.com/scripts/CommandLog.sql.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF @DatabaseContext IS NULL OR NOT EXISTS (SELECT * FROM sys.databases WHERE name = @DatabaseContext)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @DatabaseContext is not supported.'''', 16, 1
  END

  IF @Command IS NULL OR @Command = ''''''''
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Command is not supported.'''', 16, 1
  END

  IF @CommandType IS NULL OR @CommandType = '''''''' OR LEN(@CommandType) > 60
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @CommandType is not supported.'''', 16, 1
  END

  IF @Mode NOT IN(1,2) OR @Mode IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Mode is not supported.'''', 16, 1
  END

  IF @LockMessageSeverity NOT IN(10,16) OR @LockMessageSeverity IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @LockMessageSeverity is not supported.'''', 16, 1
  END

  IF LEN(@ExecuteAsUser) > 128
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @ExecuteAsUser is not supported.'''', 16, 1
  END

  IF @LogToTable NOT IN(''''Y'''',''''N'''') OR @LogToTable IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @LogToTable is not supported.'''', 16, 1
  END

  IF @Execute NOT IN(''''Y'''',''''N'''') OR @Execute IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Execute is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Raise errors                                                                               //--
  ----------------------------------------------------------------------------------------------------

  DECLARE ErrorCursor CURSOR FAST_FORWARD FOR SELECT [Message], Severity, [State] FROM @Errors ORDER BY [ID] ASC

  OPEN ErrorCursor

  FETCH ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState

  WHILE @@FETCH_STATUS = 0
  BEGIN
    RAISERROR(''''%s'''', @CurrentSeverity, @CurrentState, @CurrentMessage) WITH NOWAIT
    RAISERROR(@EmptyLine, 10, 1) WITH NOWAIT

    FETCH NEXT FROM ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState
  END

  CLOSE ErrorCursor

  DEALLOCATE ErrorCursor

  IF EXISTS (SELECT * FROM @Errors WHERE Severity >= 16)
  BEGIN
    SET @ReturnCode = 50000
    GOTO ReturnCode
  END

  ----------------------------------------------------------------------------------------------------
  --// Execute as user                                                                            //--
  ----------------------------------------------------------------------------------------------------

  IF @ExecuteAsUser IS NOT NULL
  BEGIN
    SET @Command = ''''EXECUTE AS USER = '''''''''''' + REPLACE(@ExecuteAsUser,'''''''''''''''','''''''''''''''''''''''') + ''''''''''''; '''' + @Command + ''''; REVERT;''''

    SET @RevertCommand = ''''REVERT''''
  END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @StartTime = SYSDATETIME()

  SET @StartMessage = ''''Date and time: '''' + CONVERT(nvarchar,@StartTime,120)
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Database context: '''' + QUOTENAME(@DatabaseContext)
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Command: '''' + @Command
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  IF @Comment IS NOT NULL
  BEGIN
    SET @StartMessage = ''''Comment: '''' + @Comment
    RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT
  END

  IF @LogToTable = ''''Y''''
  BEGIN
    INSERT INTO dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime)
    VALUES (@DatabaseName, @SchemaName, @ObjectName, @ObjectType, @IndexName, @IndexType, @StatisticsName, @PartitionNumber, @ExtendedInfo, @CommandType, @Command, @StartTime)
  END

  SET @ID = SCOPE_IDENTITY()

  ----------------------------------------------------------------------------------------------------
  --// Execute command                                                                            //--
  ----------------------------------------------------------------------------------------------------

  IF @Mode = 1 AND @Execute = ''''Y''''
  BEGIN
    EXECUTE @sp_executesql @stmt = @Command
    SET @Error = @@ERROR
    SET @ReturnCode = @Error
  END

  IF @Mode = 2 AND @Execute = ''''Y''''
  BEGIN
    BEGIN TRY
      EXECUTE @sp_executesql @stmt = @Command
    END TRY
    BEGIN CATCH
      SET @Error = ERROR_NUMBER()
      SET @ErrorMessageOriginal = ERROR_MESSAGE()

      SET @ErrorMessage = ''''Msg '''' + CAST(ERROR_NUMBER() AS nvarchar) + '''', '''' + ISNULL(ERROR_MESSAGE(),'''''''')
      SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
      RAISERROR(''''%s'''',@Severity,1,@ErrorMessage) WITH NOWAIT

      IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
      BEGIN
        SET @ReturnCode = ERROR_NUMBER()
      END

      IF @ExecuteAsUser IS NOT NULL
      BEGIN
        EXECUTE @sp_executesql @RevertCommand
      END
    END CATCH
  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  SET @EndTime = SYSDATETIME()

  SET @EndMessage = ''''Outcome: '''' + CASE WHEN @Execute = ''''N'''' THEN ''''Not Executed'''' WHEN @Error = 0 THEN ''''Succeeded'''' ELSE ''''Failed'''' END
  RAISERROR(''''%s'''',10,1,@EndMessage) WITH NOWAIT

  SET @EndMessage = ''''Duration: '''' + CASE WHEN (DATEDIFF(SECOND,@StartTime,@EndTime) / (24 * 3600)) > 0 THEN CAST((DATEDIFF(SECOND,@StartTime,@EndTime) / (24 * 3600)) AS nvarchar) + ''''.'''' ELSE '''''''' END + CONVERT(nvarchar,DATEADD(SECOND,DATEDIFF(SECOND,@StartTime,@EndTime),''''1900-01-01''''),108)
  RAISERROR(''''%s'''',10,1,@EndMessage) WITH NOWAIT

  SET @EndMessage = ''''Date and time: '''' + CONVERT(nvarchar,@EndTime,120)
  RAISERROR(''''%s'''',10,1,@EndMessage) WITH NOWAIT

  RAISERROR(@EmptyLine,10,1) WITH NOWAIT

  IF @LogToTable = ''''Y''''
  BEGIN
    UPDATE dbo.CommandLog
    SET EndTime = @EndTime,
        ErrorNumber = CASE WHEN @Execute = ''''N'''' THEN NULL ELSE @Error END,
        ErrorMessage = @ErrorMessageOriginal
    WHERE ID = @ID
  END

  ReturnCode:
  IF @ReturnCode <> 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
'';
EXEC(@stmt);
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:IndexOptimize-003-OlaHallengren-IndexOptimize.sql modified: 2025.06.16 09.14.58
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexOptimize-003'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @returnValue int;
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[IndexOptimize]'') AND type in (N''P'', N''PC''))
BEGIN
EXEC dbo.sp_executesql @statement = N''CREATE PROCEDURE [dbo].[IndexOptimize] AS''
END

DECLARE @stmt nvarchar(max);
SET @stmt = ''
ALTER PROCEDURE [dbo].[IndexOptimize]

@Databases nvarchar(max) = NULL,
@FragmentationLow nvarchar(max) = NULL,
@FragmentationMedium nvarchar(max) = ''''INDEX_REORGANIZE,INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE'''',
@FragmentationHigh nvarchar(max) = ''''INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE'''',
@FragmentationLevel1 int = 5,
@FragmentationLevel2 int = 30,
@MinNumberOfPages int = 1000,
@MaxNumberOfPages int = NULL,
@SortInTempdb nvarchar(max) = ''''N'''',
@MaxDOP int = NULL,
@FillFactor int = NULL,
@PadIndex nvarchar(max) = NULL,
@LOBCompaction nvarchar(max) = ''''Y'''',
@UpdateStatistics nvarchar(max) = NULL,
@OnlyModifiedStatistics nvarchar(max) = ''''N'''',
@StatisticsModificationLevel int = NULL,
@StatisticsSample int = NULL,
@StatisticsResample nvarchar(max) = ''''N'''',
@PartitionLevel nvarchar(max) = ''''Y'''',
@MSShippedObjects nvarchar(max) = ''''N'''',
@Indexes nvarchar(max) = NULL,
@TimeLimit int = NULL,
@Delay int = NULL,
@WaitAtLowPriorityMaxDuration int = NULL,
@WaitAtLowPriorityAbortAfterWait nvarchar(max) = NULL,
@Resumable nvarchar(max) = ''''N'''',
@AvailabilityGroups nvarchar(max) = NULL,
@LockTimeout int = NULL,
@LockMessageSeverity int = 16,
@StringDelimiter nvarchar(max) = '''','''',
@DatabaseOrder nvarchar(max) = NULL,
@DatabasesInParallel nvarchar(max) = ''''N'''',
@ExecuteAsUser nvarchar(max) = NULL,
@LogToTable nvarchar(max) = ''''N'''',
@Execute nvarchar(max) = ''''Y''''

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source:  https://ola.hallengren.com                                                        //--
  --// License: https://ola.hallengren.com/license.html                                           //--
  --// GitHub:  https://github.com/olahallengren/sql-server-maintenance-solution                  //--
  --// Version: 2025-06-14 16:13:00                                                               //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  SET ARITHABORT ON

  SET NUMERIC_ROUNDABORT OFF

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @DatabaseMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)
  DECLARE @Severity int

  DECLARE @StartTime datetime2 = SYSDATETIME()
  DECLARE @SchemaName nvarchar(max) = OBJECT_SCHEMA_NAME(@@PROCID)
  DECLARE @ObjectName nvarchar(max) = OBJECT_NAME(@@PROCID)
  DECLARE @VersionTimestamp nvarchar(max) = SUBSTRING(OBJECT_DEFINITION(@@PROCID),CHARINDEX(''''--// Version: '''',OBJECT_DEFINITION(@@PROCID)) + LEN(''''--// Version: '''') + 1, 19)
  DECLARE @Parameters nvarchar(max)

  DECLARE @HostPlatform nvarchar(max)

  DECLARE @PartitionLevelStatistics bit

  DECLARE @QueueID int
  DECLARE @QueueStartTime datetime2

  DECLARE @CurrentDBID int
  DECLARE @CurrentDatabaseName nvarchar(max)

  DECLARE @CurrentDatabase_sp_executesql nvarchar(max)

  DECLARE @CurrentExecuteAsUserExists bit
  DECLARE @CurrentUserAccess nvarchar(max)
  DECLARE @CurrentIsReadOnly bit
  DECLARE @CurrentDatabaseState nvarchar(max)
  DECLARE @CurrentInStandby bit
  DECLARE @CurrentRecoveryModel nvarchar(max)

  DECLARE @CurrentReplicaID uniqueidentifier
  DECLARE @CurrentAvailabilityGroupID uniqueidentifier
  DECLARE @CurrentAvailabilityGroup nvarchar(max)
  DECLARE @CurrentAvailabilityGroupRole nvarchar(max)
  DECLARE @CurrentDatabaseMirroringRole nvarchar(max)

  DECLARE @CurrentDatabaseContext nvarchar(max)
  DECLARE @CurrentCommand nvarchar(max)
  DECLARE @CurrentCommandOutput int
  DECLARE @CurrentCommandType nvarchar(max)
  DECLARE @CurrentComment nvarchar(max)
  DECLARE @CurrentExtendedInfo xml

  DECLARE @Errors TABLE (ID int IDENTITY PRIMARY KEY,
                         [Message] nvarchar(max) NOT NULL,
                         Severity int NOT NULL,
                         [State] int)

  DECLARE @CurrentMessage nvarchar(max)
  DECLARE @CurrentSeverity int
  DECLARE @CurrentState int

  DECLARE @CurrentIxID int
  DECLARE @CurrentIxOrder int
  DECLARE @CurrentSchemaID int
  DECLARE @CurrentSchemaName nvarchar(max)
  DECLARE @CurrentObjectID int
  DECLARE @CurrentObjectName nvarchar(max)
  DECLARE @CurrentObjectType nvarchar(max)
  DECLARE @CurrentIsMemoryOptimized bit
  DECLARE @CurrentIndexID int
  DECLARE @CurrentIndexName nvarchar(max)
  DECLARE @CurrentIndexType int
  DECLARE @CurrentStatisticsID int
  DECLARE @CurrentStatisticsName nvarchar(max)
  DECLARE @CurrentPartitionID bigint
  DECLARE @CurrentPartitionNumber int
  DECLARE @CurrentPartitionCount int
  DECLARE @CurrentIsPartition bit
  DECLARE @CurrentIndexExists bit
  DECLARE @CurrentStatisticsExists bit
  DECLARE @CurrentIsImageText bit
  DECLARE @CurrentIsNewLOB bit
  DECLARE @CurrentIsFileStream bit
  DECLARE @CurrentHasColumnstore bit
  DECLARE @CurrentIsComputed bit
  DECLARE @CurrentIsClusteredIndexComputed bit
  DECLARE @CurrentIsTimestamp bit
  DECLARE @CurrentAllowPageLocks bit
  DECLARE @CurrentHasFilter bit
  DECLARE @CurrentNoRecompute bit
  DECLARE @CurrentIsIncremental bit
  DECLARE @CurrentRowCount bigint
  DECLARE @CurrentModificationCounter bigint
  DECLARE @CurrentOnReadOnlyFileGroup bit
  DECLARE @CurrentResumableIndexOperation bit
  DECLARE @CurrentFragmentationLevel float
  DECLARE @CurrentPageCount bigint
  DECLARE @CurrentFragmentationGroup nvarchar(max)
  DECLARE @CurrentAction nvarchar(max)
  DECLARE @CurrentMaxDOP int
  DECLARE @CurrentUpdateStatistics nvarchar(max)
  DECLARE @CurrentStatisticsSample int
  DECLARE @CurrentStatisticsResample nvarchar(max)
  DECLARE @CurrentDelay datetime

  DECLARE @tmpDatabases TABLE (ID int IDENTITY,
                               DatabaseName nvarchar(max),
                               DatabaseType nvarchar(max),
                               AvailabilityGroup bit,
                               StartPosition int,
                               DatabaseSize bigint,
                               [Order] int,
                               Selected bit,
                               Completed bit,
                               PRIMARY KEY(Selected, Completed, [Order], ID))

  DECLARE @tmpAvailabilityGroups TABLE (ID int IDENTITY PRIMARY KEY,
                                        AvailabilityGroupName nvarchar(max),
                                        StartPosition int,
                                        Selected bit)

  DECLARE @tmpDatabasesAvailabilityGroups TABLE (DatabaseName nvarchar(max),
                                                 AvailabilityGroupName nvarchar(max))

  DECLARE @tmpIndexesStatistics TABLE (ID int IDENTITY,
                                       SchemaID int,
                                       SchemaName nvarchar(max),
                                       ObjectID int,
                                       ObjectName nvarchar(max),
                                       ObjectType nvarchar(max),
                                       IsMemoryOptimized bit,
                                       IndexID int,
                                       IndexName nvarchar(max),
                                       IndexType int,
                                       AllowPageLocks bit,
                                       HasFilter bit,
                                       IsImageText bit,
                                       IsNewLOB bit,
                                       IsFileStream bit,
                                       HasColumnstore bit,
                                       IsComputed bit,
                                       IsClusteredIndexComputed bit,
                                       IsTimestamp bit,
                                       OnReadOnlyFileGroup bit,
                                       ResumableIndexOperation bit,
                                       StatisticsID int,
                                       StatisticsName nvarchar(max),
                                       [NoRecompute] bit,
                                       IsIncremental bit,
                                       PartitionID bigint,
                                       PartitionNumber int,
                                       PartitionCount int,
                                       StartPosition int,
                                       [Order] int,
                                       Selected bit,
                                       Completed bit,
                                       PRIMARY KEY(Selected, Completed, [Order], ID))

  DECLARE @SelectedDatabases TABLE (DatabaseName nvarchar(max),
                                    DatabaseType nvarchar(max),
                                    AvailabilityGroup nvarchar(max),
                                    StartPosition int,
                                    Selected bit)

  DECLARE @SelectedAvailabilityGroups TABLE (AvailabilityGroupName nvarchar(max),
                                             StartPosition int,
                                             Selected bit)

  DECLARE @SelectedIndexes TABLE (DatabaseName nvarchar(max),
                                  SchemaName nvarchar(max),
                                  ObjectName nvarchar(max),
                                  IndexName nvarchar(max),
                                  StartPosition int,
                                  Selected bit)

  DECLARE @Actions TABLE ([Action] nvarchar(max))

  INSERT INTO @Actions([Action]) VALUES(''''INDEX_REBUILD_ONLINE'''')
  INSERT INTO @Actions([Action]) VALUES(''''INDEX_REBUILD_OFFLINE'''')
  INSERT INTO @Actions([Action]) VALUES(''''INDEX_REORGANIZE'''')

  DECLARE @ActionsPreferred TABLE (FragmentationGroup nvarchar(max),
                                   [Priority] int,
                                   [Action] nvarchar(max))

  DECLARE @CurrentActionsAllowed TABLE ([Action] nvarchar(max))

  DECLARE @CurrentAlterIndexWithClauseArguments TABLE (ID int IDENTITY,
                                                       Argument nvarchar(max),
                                                       Added bit DEFAULT 0)

  DECLARE @CurrentAlterIndexArgumentID int
  DECLARE @CurrentAlterIndexArgument nvarchar(max)
  DECLARE @CurrentAlterIndexWithClause nvarchar(max)

  DECLARE @CurrentUpdateStatisticsWithClauseArguments TABLE (ID int IDENTITY,
                                                             Argument nvarchar(max),
                                                             Added bit DEFAULT 0)

  DECLARE @CurrentUpdateStatisticsArgumentID int
  DECLARE @CurrentUpdateStatisticsArgument nvarchar(max)
  DECLARE @CurrentUpdateStatisticsWithClause nvarchar(max)

  DECLARE @Error int = 0
  DECLARE @ReturnCode int = 0

  DECLARE @EmptyLine nvarchar(max) = CHAR(9)

  DECLARE @Version numeric(18,10) = CAST(LEFT(CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max)),CHARINDEX(''''.'''',CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max))) - 1) + ''''.'''' + REPLACE(RIGHT(CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max))) - CHARINDEX(''''.'''',CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max)))),''''.'''','''''''') AS numeric(18,10))

  IF @Version >= 14
  BEGIN
    SELECT @HostPlatform = host_platform
    FROM sys.dm_os_host_info
  END
  ELSE
  BEGIN
    SET @HostPlatform = ''''Windows''''
  END

  DECLARE @AmazonRDS bit = CASE WHEN SERVERPROPERTY(''''EngineEdition'''') IN (5, 8) THEN 0 WHEN EXISTS (SELECT * FROM sys.databases WHERE [name] = ''''rdsadmin'''') AND SUSER_SNAME(0x01) = ''''rdsa'''' THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @Parameters = ''''@Databases = '''' + ISNULL('''''''''''''''' + REPLACE(@Databases,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @FragmentationLow = '''' + ISNULL('''''''''''''''' + REPLACE(@FragmentationLow,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @FragmentationMedium = '''' + ISNULL('''''''''''''''' + REPLACE(@FragmentationMedium,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @FragmentationHigh = '''' + ISNULL('''''''''''''''' + REPLACE(@FragmentationHigh,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @FragmentationLevel1 = '''' + ISNULL(CAST(@FragmentationLevel1 AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @FragmentationLevel2 = '''' + ISNULL(CAST(@FragmentationLevel2 AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @MinNumberOfPages = '''' + ISNULL(CAST(@MinNumberOfPages AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @MaxNumberOfPages = '''' + ISNULL(CAST(@MaxNumberOfPages AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @SortInTempdb = '''' + ISNULL('''''''''''''''' + REPLACE(@SortInTempdb,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @MaxDOP = '''' + ISNULL(CAST(@MaxDOP AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @FillFactor = '''' + ISNULL(CAST(@FillFactor AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @PadIndex = '''' + ISNULL('''''''''''''''' + REPLACE(@PadIndex,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @LOBCompaction = '''' + ISNULL('''''''''''''''' + REPLACE(@LOBCompaction,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @UpdateStatistics = '''' + ISNULL('''''''''''''''' + REPLACE(@UpdateStatistics,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @OnlyModifiedStatistics = '''' + ISNULL('''''''''''''''' + REPLACE(@OnlyModifiedStatistics,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @StatisticsModificationLevel = '''' + ISNULL(CAST(@StatisticsModificationLevel AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @StatisticsSample = '''' + ISNULL(CAST(@StatisticsSample AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @StatisticsResample = '''' + ISNULL('''''''''''''''' + REPLACE(@StatisticsResample,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @PartitionLevel = '''' + ISNULL('''''''''''''''' + REPLACE(@PartitionLevel,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @MSShippedObjects = '''' + ISNULL('''''''''''''''' + REPLACE(@MSShippedObjects,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @Indexes = '''' + ISNULL('''''''''''''''' + REPLACE(@Indexes,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @TimeLimit = '''' + ISNULL(CAST(@TimeLimit AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @Delay = '''' + ISNULL(CAST(@Delay AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @WaitAtLowPriorityMaxDuration = '''' + ISNULL(CAST(@WaitAtLowPriorityMaxDuration AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @WaitAtLowPriorityAbortAfterWait = '''' + ISNULL('''''''''''''''' + REPLACE(@WaitAtLowPriorityAbortAfterWait,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @Resumable = '''' + ISNULL('''''''''''''''' + REPLACE(@Resumable,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @AvailabilityGroups = '''' + ISNULL('''''''''''''''' + REPLACE(@AvailabilityGroups,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @LockTimeout = '''' + ISNULL(CAST(@LockTimeout AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @LockMessageSeverity = '''' + ISNULL(CAST(@LockMessageSeverity AS nvarchar),''''NULL'''')
  SET @Parameters += '''', @StringDelimiter = '''' + ISNULL('''''''''''''''' + REPLACE(@StringDelimiter,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @DatabaseOrder = '''' + ISNULL('''''''''''''''' + REPLACE(@DatabaseOrder,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @DatabasesInParallel = '''' + ISNULL('''''''''''''''' + REPLACE(@DatabasesInParallel,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @ExecuteAsUser = '''' + ISNULL('''''''''''''''' + REPLACE(@ExecuteAsUser,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @LogToTable = '''' + ISNULL('''''''''''''''' + REPLACE(@LogToTable,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')
  SET @Parameters += '''', @Execute = '''' + ISNULL('''''''''''''''' + REPLACE(@Execute,'''''''''''''''','''''''''''''''''''''''') + '''''''''''''''',''''NULL'''')

  SET @StartMessage = ''''Date and time: '''' + CONVERT(nvarchar,@StartTime,120)
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Server: '''' + CAST(SERVERPROPERTY(''''ServerName'''') AS nvarchar(max))
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Version: '''' + CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max))
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Edition: '''' + CAST(SERVERPROPERTY(''''Edition'''') AS nvarchar(max))
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Platform: '''' + @HostPlatform
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Procedure: '''' + QUOTENAME(DB_NAME()) + ''''.'''' + QUOTENAME(@SchemaName) + ''''.'''' + QUOTENAME(@ObjectName)
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Parameters: '''' + @Parameters
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Version: '''' + @VersionTimestamp
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = ''''Source: https://ola.hallengren.com''''
  RAISERROR(''''%s'''',10,1,@StartMessage) WITH NOWAIT

  RAISERROR(@EmptyLine,10,1) WITH NOWAIT

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT (SELECT [compatibility_level] FROM sys.databases WHERE [name] = DB_NAME()) >= 90
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The database '''' + QUOTENAME(DB_NAME()) + '''' has to be in compatibility level 90 or higher.'''', 16, 1
  END

  IF NOT (SELECT uses_ansi_nulls FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''ANSI_NULLS has to be set to ON for the stored procedure.'''', 16, 1
  END

  IF NOT (SELECT uses_quoted_identifier FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''QUOTED_IDENTIFIER has to be set to ON for the stored procedure.'''', 16, 1
  END

  IF NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = ''''P'''' AND schemas.[name] = ''''dbo'''' AND objects.[name] = ''''CommandExecute'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The stored procedure CommandExecute is missing. Download https://ola.hallengren.com/scripts/CommandExecute.sql.'''', 16, 1
  END

  IF EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = ''''P'''' AND schemas.[name] = ''''dbo'''' AND objects.[name] = ''''CommandExecute'''' AND OBJECT_DEFINITION(objects.[object_id]) NOT LIKE ''''%@DatabaseContext%'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The stored procedure CommandExecute needs to be updated. Download https://ola.hallengren.com/scripts/CommandExecute.sql.'''', 16, 1
  END

  IF @LogToTable = ''''Y'''' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = ''''U'''' AND schemas.[name] = ''''dbo'''' AND objects.[name] = ''''CommandLog'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The table CommandLog is missing. Download https://ola.hallengren.com/scripts/CommandLog.sql.'''', 16, 1
  END

  IF @DatabasesInParallel = ''''Y'''' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = ''''U'''' AND schemas.[name] = ''''dbo'''' AND objects.[name] = ''''Queue'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The table Queue is missing. Download https://ola.hallengren.com/scripts/Queue.sql.'''', 16, 1
  END

  IF @DatabasesInParallel = ''''Y'''' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = ''''U'''' AND schemas.[name] = ''''dbo'''' AND objects.[name] = ''''QueueDatabase'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The table QueueDatabase is missing. Download https://ola.hallengren.com/scripts/QueueDatabase.sql.'''', 16, 1
  END

  IF @@TRANCOUNT <> 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The transaction count is not 0.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Select databases                                                                           //--
  ----------------------------------------------------------------------------------------------------

  SET @Databases = REPLACE(@Databases, CHAR(10), '''''''')
  SET @Databases = REPLACE(@Databases, CHAR(13), '''''''')

  WHILE CHARINDEX(@StringDelimiter + '''' '''', @Databases) > 0 SET @Databases = REPLACE(@Databases, @StringDelimiter + '''' '''', @StringDelimiter)
  WHILE CHARINDEX('''' '''' + @StringDelimiter, @Databases) > 0 SET @Databases = REPLACE(@Databases, '''' '''' + @StringDelimiter, @StringDelimiter)

  SET @Databases = LTRIM(RTRIM(@Databases));

  WITH Databases1 (StartPosition, EndPosition, DatabaseItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, 1), 0), LEN(@Databases) + 1) - 1) AS DatabaseItem
  WHERE @Databases IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) - EndPosition - 1) AS DatabaseItem
  FROM Databases1
  WHERE EndPosition < LEN(@Databases) + 1
  ),
  Databases2 (DatabaseItem, StartPosition, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem LIKE ''''-%'''' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem,
         StartPosition,
         CASE WHEN DatabaseItem LIKE ''''-%'''' THEN 0 ELSE 1 END AS Selected
  FROM Databases1
  ),
  Databases3 (DatabaseItem, DatabaseType, AvailabilityGroup, StartPosition, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem IN(''''ALL_DATABASES'''',''''SYSTEM_DATABASES'''',''''USER_DATABASES'''',''''AVAILABILITY_GROUP_DATABASES'''') THEN ''''%'''' ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem = ''''SYSTEM_DATABASES'''' THEN ''''S'''' WHEN DatabaseItem = ''''USER_DATABASES'''' THEN ''''U'''' ELSE NULL END AS DatabaseType,
         CASE WHEN DatabaseItem = ''''AVAILABILITY_GROUP_DATABASES'''' THEN 1 ELSE NULL END AvailabilityGroup,
         StartPosition,
         Selected
  FROM Databases2
  ),
  Databases4 (DatabaseName, DatabaseType, AvailabilityGroup, StartPosition, Selected) AS
  (
  SELECT CASE WHEN LEFT(DatabaseItem,1) = ''''['''' AND RIGHT(DatabaseItem,1) = '''']'''' THEN PARSENAME(DatabaseItem,1) ELSE DatabaseItem END AS DatabaseItem,
         DatabaseType,
         AvailabilityGroup,
         StartPosition,
         Selected
  FROM Databases3
  )
  INSERT INTO @SelectedDatabases (DatabaseName, DatabaseType, AvailabilityGroup, StartPosition, Selected)
  SELECT DatabaseName,
         DatabaseType,
         AvailabilityGroup,
         StartPosition,
         Selected
  FROM Databases4
  OPTION (MAXRECURSION 0)

  IF @Version >= 11 AND SERVERPROPERTY(''''IsHadrEnabled'''') = 1
  BEGIN
    INSERT INTO @tmpAvailabilityGroups (AvailabilityGroupName, Selected)
    SELECT name AS AvailabilityGroupName,
           0 AS Selected
    FROM sys.availability_groups

    INSERT INTO @tmpDatabasesAvailabilityGroups (DatabaseName, AvailabilityGroupName)
    SELECT databases.name,
           availability_groups.name
    FROM sys.databases databases
    INNER JOIN sys.availability_replicas availability_replicas ON databases.replica_id = availability_replicas.replica_id
    INNER JOIN sys.availability_groups availability_groups ON availability_replicas.group_id = availability_groups.group_id
  END

  INSERT INTO @tmpDatabases (DatabaseName, DatabaseType, AvailabilityGroup, [Order], Selected, Completed)
  SELECT [name] AS DatabaseName,
         CASE WHEN name IN(''''master'''',''''msdb'''',''''model'''') OR is_distributor = 1 THEN ''''S'''' ELSE ''''U'''' END AS DatabaseType,
         NULL AS AvailabilityGroup,
         0 AS [Order],
         0 AS Selected,
         0 AS Completed
  FROM sys.databases
  WHERE [name] <> ''''tempdb''''
  AND source_database_id IS NULL
  ORDER BY [name] ASC

  UPDATE tmpDatabases
  SET AvailabilityGroup = CASE WHEN EXISTS (SELECT * FROM @tmpDatabasesAvailabilityGroups WHERE DatabaseName = tmpDatabases.DatabaseName) THEN 1 ELSE 0 END
  FROM @tmpDatabases tmpDatabases

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,''''_'''',''''[_]'''')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)
  WHERE SelectedDatabases.Selected = 1

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,''''_'''',''''[_]'''')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)
  WHERE SelectedDatabases.Selected = 0

  UPDATE tmpDatabases
  SET tmpDatabases.StartPosition = SelectedDatabases2.StartPosition
  FROM @tmpDatabases tmpDatabases
  INNER JOIN (SELECT tmpDatabases.DatabaseName, MIN(SelectedDatabases.StartPosition) AS StartPosition
              FROM @tmpDatabases tmpDatabases
              INNER JOIN @SelectedDatabases SelectedDatabases
              ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,''''_'''',''''[_]'''')
              AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
              AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)
              WHERE SelectedDatabases.Selected = 1
              GROUP BY tmpDatabases.DatabaseName) SelectedDatabases2
  ON tmpDatabases.DatabaseName = SelectedDatabases2.DatabaseName

  IF @Databases IS NOT NULL AND (NOT EXISTS(SELECT * FROM @SelectedDatabases) OR EXISTS(SELECT * FROM @SelectedDatabases WHERE DatabaseName IS NULL OR DATALENGTH(DatabaseName) = 0))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Databases is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Select availability groups                                                                 //--
  ----------------------------------------------------------------------------------------------------

  IF @AvailabilityGroups IS NOT NULL AND @Version >= 11 AND SERVERPROPERTY(''''IsHadrEnabled'''') = 1
  BEGIN

    SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, CHAR(10), '''''''')
    SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, CHAR(13), '''''''')

    WHILE CHARINDEX(@StringDelimiter + '''' '''', @AvailabilityGroups) > 0 SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, @StringDelimiter + '''' '''', @StringDelimiter)
    WHILE CHARINDEX('''' '''' + @StringDelimiter, @AvailabilityGroups) > 0 SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, '''' '''' + @StringDelimiter, @StringDelimiter)

    SET @AvailabilityGroups = LTRIM(RTRIM(@AvailabilityGroups));

    WITH AvailabilityGroups1 (StartPosition, EndPosition, AvailabilityGroupItem) AS
    (
    SELECT 1 AS StartPosition,
           ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, 1), 0), LEN(@AvailabilityGroups) + 1) AS EndPosition,
           SUBSTRING(@AvailabilityGroups, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, 1), 0), LEN(@AvailabilityGroups) + 1) - 1) AS AvailabilityGroupItem
    WHERE @AvailabilityGroups IS NOT NULL
    UNION ALL
    SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
           ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, EndPosition + 1), 0), LEN(@AvailabilityGroups) + 1) AS EndPosition,
           SUBSTRING(@AvailabilityGroups, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, EndPosition + 1), 0), LEN(@AvailabilityGroups) + 1) - EndPosition - 1) AS AvailabilityGroupItem
    FROM AvailabilityGroups1
    WHERE EndPosition < LEN(@AvailabilityGroups) + 1
    ),
    AvailabilityGroups2 (AvailabilityGroupItem, StartPosition, Selected) AS
    (
    SELECT CASE WHEN AvailabilityGroupItem LIKE ''''-%'''' THEN RIGHT(AvailabilityGroupItem,LEN(AvailabilityGroupItem) - 1) ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,
           StartPosition,
           CASE WHEN AvailabilityGroupItem LIKE ''''-%'''' THEN 0 ELSE 1 END AS Selected
    FROM AvailabilityGroups1
    ),
    AvailabilityGroups3 (AvailabilityGroupItem, StartPosition, Selected) AS
    (
    SELECT CASE WHEN AvailabilityGroupItem = ''''ALL_AVAILABILITY_GROUPS'''' THEN ''''%'''' ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,
           StartPosition,
           Selected
    FROM AvailabilityGroups2
    ),
    AvailabilityGroups4 (AvailabilityGroupName, StartPosition, Selected) AS
    (
    SELECT CASE WHEN LEFT(AvailabilityGroupItem,1) = ''''['''' AND RIGHT(AvailabilityGroupItem,1) = '''']'''' THEN PARSENAME(AvailabilityGroupItem,1) ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,
           StartPosition,
           Selected
    FROM AvailabilityGroups3
    )
    INSERT INTO @SelectedAvailabilityGroups (AvailabilityGroupName, StartPosition, Selected)
    SELECT AvailabilityGroupName, StartPosition, Selected
    FROM AvailabilityGroups4
    OPTION (MAXRECURSION 0)

    UPDATE tmpAvailabilityGroups
    SET tmpAvailabilityGroups.Selected = SelectedAvailabilityGroups.Selected
    FROM @tmpAvailabilityGroups tmpAvailabilityGroups
    INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups
    ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,''''_'''',''''[_]'''')
    WHERE SelectedAvailabilityGroups.Selected = 1

    UPDATE tmpAvailabilityGroups
    SET tmpAvailabilityGroups.Selected = SelectedAvailabilityGroups.Selected
    FROM @tmpAvailabilityGroups tmpAvailabilityGroups
    INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups
    ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,''''_'''',''''[_]'''')
    WHERE SelectedAvailabilityGroups.Selected = 0

    UPDATE tmpAvailabilityGroups
    SET tmpAvailabilityGroups.StartPosition = SelectedAvailabilityGroups2.StartPosition
    FROM @tmpAvailabilityGroups tmpAvailabilityGroups
    INNER JOIN (SELECT tmpAvailabilityGroups.AvailabilityGroupName, MIN(SelectedAvailabilityGroups.StartPosition) AS StartPosition
                FROM @tmpAvailabilityGroups tmpAvailabilityGroups
                INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups
                ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,''''_'''',''''[_]'''')
                WHERE SelectedAvailabilityGroups.Selected = 1
                GROUP BY tmpAvailabilityGroups.AvailabilityGroupName) SelectedAvailabilityGroups2
    ON tmpAvailabilityGroups.AvailabilityGroupName = SelectedAvailabilityGroups2.AvailabilityGroupName

    UPDATE tmpDatabases
    SET tmpDatabases.StartPosition = tmpAvailabilityGroups.StartPosition,
        tmpDatabases.Selected = 1
    FROM @tmpDatabases tmpDatabases
    INNER JOIN @tmpDatabasesAvailabilityGroups tmpDatabasesAvailabilityGroups ON tmpDatabases.DatabaseName = tmpDatabasesAvailabilityGroups.DatabaseName
    INNER JOIN @tmpAvailabilityGroups tmpAvailabilityGroups ON tmpDatabasesAvailabilityGroups.AvailabilityGroupName = tmpAvailabilityGroups.AvailabilityGroupName
    WHERE tmpAvailabilityGroups.Selected = 1

  END

  IF @AvailabilityGroups IS NOT NULL AND (NOT EXISTS(SELECT * FROM @SelectedAvailabilityGroups) OR EXISTS(SELECT * FROM @SelectedAvailabilityGroups WHERE AvailabilityGroupName IS NULL OR AvailabilityGroupName = '''''''') OR @Version < 11 OR SERVERPROPERTY(''''IsHadrEnabled'''') = 0)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @AvailabilityGroups is not supported.'''', 16, 1
  END

  IF (@Databases IS NULL AND @AvailabilityGroups IS NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''You need to specify one of the parameters @Databases and @AvailabilityGroups.'''', 16, 2
  END

  IF (@Databases IS NOT NULL AND @AvailabilityGroups IS NOT NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''You can only specify one of the parameters @Databases and @AvailabilityGroups.'''', 16, 3
  END

  ----------------------------------------------------------------------------------------------------
  --// Select indexes                                                                             //--
  ----------------------------------------------------------------------------------------------------

  SET @Indexes = REPLACE(@Indexes, CHAR(10), '''''''')
  SET @Indexes = REPLACE(@Indexes, CHAR(13), '''''''')

  WHILE CHARINDEX(@StringDelimiter + '''' '''', @Indexes) > 0 SET @Indexes = REPLACE(@Indexes, @StringDelimiter + '''' '''', @StringDelimiter)
  WHILE CHARINDEX('''' '''' + @StringDelimiter, @Indexes) > 0 SET @Indexes = REPLACE(@Indexes, '''' '''' + @StringDelimiter, @StringDelimiter)

  SET @Indexes = LTRIM(RTRIM(@Indexes));

  WITH Indexes1 (StartPosition, EndPosition, IndexItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, 1), 0), LEN(@Indexes) + 1) AS EndPosition,
         SUBSTRING(@Indexes, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, 1), 0), LEN(@Indexes) + 1) - 1) AS IndexItem
  WHERE @Indexes IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, EndPosition + 1), 0), LEN(@Indexes) + 1) AS EndPosition,
         SUBSTRING(@Indexes, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, EndPosition + 1), 0), LEN(@Indexes) + 1) - EndPosition - 1) AS IndexItem
  FROM Indexes1
  WHERE EndPosition < LEN(@Indexes) + 1
  ),
  Indexes2 (IndexItem, StartPosition, Selected) AS
  (
  SELECT CASE WHEN IndexItem LIKE ''''-%'''' THEN RIGHT(IndexItem,LEN(IndexItem) - 1) ELSE IndexItem END AS IndexItem,
         StartPosition,
         CASE WHEN IndexItem LIKE ''''-%'''' THEN 0 ELSE 1 END AS Selected
  FROM Indexes1
  ),
  Indexes3 (IndexItem, StartPosition, Selected) AS
  (
  SELECT CASE WHEN IndexItem = ''''ALL_INDEXES'''' THEN ''''%.%.%.%'''' ELSE IndexItem END AS IndexItem,
         StartPosition,
         Selected
  FROM Indexes2
  ),
  Indexes4 (DatabaseName, SchemaName, ObjectName, IndexName, StartPosition, Selected) AS
  (
  SELECT CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,3) ELSE PARSENAME(IndexItem,4) END AS DatabaseName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,2) ELSE PARSENAME(IndexItem,3) END AS SchemaName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,1) ELSE PARSENAME(IndexItem,2) END AS ObjectName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN ''''%'''' ELSE PARSENAME(IndexItem,1) END AS IndexName,
         StartPosition,
         Selected
  FROM Indexes3
  )
  INSERT INTO @SelectedIndexes (DatabaseName, SchemaName, ObjectName, IndexName, StartPosition, Selected)
  SELECT DatabaseName, SchemaName, ObjectName, IndexName, StartPosition, Selected
  FROM Indexes4
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Select actions                                                                             //--
  ----------------------------------------------------------------------------------------------------

  SET @FragmentationLow = REPLACE(@FragmentationLow, @StringDelimiter + '''' '''', @StringDelimiter);

  WITH FragmentationLow (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, 1), 0), LEN(@FragmentationLow) + 1) AS EndPosition,
         SUBSTRING(@FragmentationLow, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, 1), 0), LEN(@FragmentationLow) + 1) - 1) AS [Action]
  WHERE @FragmentationLow IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, EndPosition + 1), 0), LEN(@FragmentationLow) + 1) AS EndPosition,
         SUBSTRING(@FragmentationLow, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, EndPosition + 1), 0), LEN(@FragmentationLow) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationLow
  WHERE EndPosition < LEN(@FragmentationLow) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT ''''Low'''' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationLow
  OPTION (MAXRECURSION 0)

  SET @FragmentationMedium = REPLACE(@FragmentationMedium, @StringDelimiter + '''' '''', @StringDelimiter);

  WITH FragmentationMedium (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, 1), 0), LEN(@FragmentationMedium) + 1) AS EndPosition,
         SUBSTRING(@FragmentationMedium, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, 1), 0), LEN(@FragmentationMedium) + 1) - 1) AS [Action]
  WHERE @FragmentationMedium IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, EndPosition + 1), 0), LEN(@FragmentationMedium) + 1) AS EndPosition,
         SUBSTRING(@FragmentationMedium, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, EndPosition + 1), 0), LEN(@FragmentationMedium) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationMedium
  WHERE EndPosition < LEN(@FragmentationMedium) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT ''''Medium'''' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationMedium
  OPTION (MAXRECURSION 0)

  SET @FragmentationHigh = REPLACE(@FragmentationHigh, @StringDelimiter + '''' '''', @StringDelimiter);

  WITH FragmentationHigh (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, 1), 0), LEN(@FragmentationHigh) + 1) AS EndPosition,
         SUBSTRING(@FragmentationHigh, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, 1), 0), LEN(@FragmentationHigh) + 1) - 1) AS [Action]
  WHERE @FragmentationHigh IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, EndPosition + 1), 0), LEN(@FragmentationHigh) + 1) AS EndPosition,
         SUBSTRING(@FragmentationHigh, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, EndPosition + 1), 0), LEN(@FragmentationHigh) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationHigh
  WHERE EndPosition < LEN(@FragmentationHigh) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT ''''High'''' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationHigh
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = ''''Low'''' AND [Action] NOT IN(SELECT * FROM @Actions))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationLow is not supported.'''', 16, 1
  END

  IF EXISTS (SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = ''''Low'''' GROUP BY [Action] HAVING COUNT(*) > 1)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationLow is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = ''''Medium'''' AND [Action] NOT IN(SELECT * FROM @Actions))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationMedium is not supported.'''', 16, 1
  END

  IF EXISTS (SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = ''''Medium'''' GROUP BY [Action] HAVING COUNT(*) > 1)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationMedium is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = ''''High'''' AND [Action] NOT IN(SELECT * FROM @Actions))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationHigh is not supported.'''', 16, 1
  END

  IF EXISTS (SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = ''''High'''' GROUP BY [Action] HAVING COUNT(*) > 1)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationHigh is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @FragmentationLevel1 <= 0 OR @FragmentationLevel1 >= 100 OR @FragmentationLevel1 IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationLevel1 is not supported.'''', 16, 1
  END

  IF @FragmentationLevel1 >= @FragmentationLevel2
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationLevel1 is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @FragmentationLevel2 <= 0 OR @FragmentationLevel2 >= 100 OR @FragmentationLevel2 IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationLevel2 is not supported.'''', 16, 1
  END

  IF @FragmentationLevel2 <= @FragmentationLevel1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FragmentationLevel2 is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @MinNumberOfPages < 0 OR @MinNumberOfPages IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @MinNumberOfPages is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @MaxNumberOfPages < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @MaxNumberOfPages is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @SortInTempdb NOT IN(''''Y'''',''''N'''') OR @SortInTempdb IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @SortInTempdb is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @MaxDOP < 0 OR @MaxDOP > 64
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @MaxDOP is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @FillFactor <= 0 OR @FillFactor > 100
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @FillFactor is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @PadIndex NOT IN(''''Y'''',''''N'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @PadIndex is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @LOBCompaction NOT IN(''''Y'''',''''N'''') OR @LOBCompaction IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @LOBCompaction is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @UpdateStatistics NOT IN(''''ALL'''',''''COLUMNS'''',''''INDEX'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @UpdateStatistics is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @OnlyModifiedStatistics NOT IN(''''Y'''',''''N'''') OR @OnlyModifiedStatistics IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @OnlyModifiedStatistics is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StatisticsModificationLevel <= 0 OR @StatisticsModificationLevel > 100
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @StatisticsModificationLevel is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @OnlyModifiedStatistics = ''''Y'''' AND @StatisticsModificationLevel IS NOT NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''You can only specify one of the parameters @OnlyModifiedStatistics and @StatisticsModificationLevel.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StatisticsSample <= 0 OR @StatisticsSample  > 100
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @StatisticsSample is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StatisticsResample NOT IN(''''Y'''',''''N'''') OR @StatisticsResample IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @StatisticsResample is not supported.'''', 16, 1
  END

  IF @StatisticsResample = ''''Y'''' AND @StatisticsSample IS NOT NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @StatisticsResample is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @PartitionLevel NOT IN(''''Y'''',''''N'''') OR @PartitionLevel IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @PartitionLevel is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @MSShippedObjects NOT IN(''''Y'''',''''N'''') OR @MSShippedObjects IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @MSShippedObjects is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS(SELECT * FROM @SelectedIndexes WHERE DatabaseName IS NULL OR SchemaName IS NULL OR ObjectName IS NULL OR IndexName IS NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Indexes is not supported.'''', 16, 1
  END

  IF @Indexes IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedIndexes)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Indexes is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @TimeLimit < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @TimeLimit is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @Delay < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Delay is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @WaitAtLowPriorityMaxDuration < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @WaitAtLowPriorityMaxDuration is not supported.'''', 16, 1
  END

  IF @WaitAtLowPriorityMaxDuration IS NOT NULL AND @Version < 12
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @WaitAtLowPriorityMaxDuration is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @WaitAtLowPriorityAbortAfterWait NOT IN(''''NONE'''',''''SELF'''',''''BLOCKERS'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @WaitAtLowPriorityAbortAfterWait is not supported.'''', 16, 1
  END

  IF @WaitAtLowPriorityAbortAfterWait IS NOT NULL AND @Version < 12
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @WaitAtLowPriorityAbortAfterWait is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF (@WaitAtLowPriorityAbortAfterWait IS NOT NULL AND @WaitAtLowPriorityMaxDuration IS NULL) OR (@WaitAtLowPriorityAbortAfterWait IS NULL AND @WaitAtLowPriorityMaxDuration IS NOT NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The parameters @WaitAtLowPriorityMaxDuration and @WaitAtLowPriorityAbortAfterWait can only be used together.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @Resumable NOT IN(''''Y'''',''''N'''') OR @Resumable IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Resumable is not supported.'''', 16, 1
  END

  IF @Resumable = ''''Y'''' AND NOT (@Version >= 14 OR SERVERPROPERTY(''''EngineEdition'''') IN (5, 8))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Resumable is not supported.'''', 16, 2
  END

  IF @Resumable = ''''Y'''' AND @SortInTempdb = ''''Y''''
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''You can only specify one of the parameters @Resumable and @SortInTempdb.'''', 16, 3
  END

  ----------------------------------------------------------------------------------------------------

  IF @LockTimeout < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @LockTimeout is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @LockMessageSeverity NOT IN(10, 16)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @LockMessageSeverity is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StringDelimiter IS NULL OR LEN(@StringDelimiter) > 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @StringDelimiter is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @DatabaseOrder NOT IN(''''DATABASE_NAME_ASC'''',''''DATABASE_NAME_DESC'''',''''DATABASE_SIZE_ASC'''',''''DATABASE_SIZE_DESC'''')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @DatabaseOrder is not supported.'''', 16, 1
  END

  IF @DatabaseOrder IS NOT NULL AND SERVERPROPERTY(''''EngineEdition'''') = 5
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @DatabaseOrder is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @DatabasesInParallel NOT IN(''''Y'''',''''N'''') OR @DatabasesInParallel IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @DatabasesInParallel is not supported.'''', 16, 1
  END

  IF @DatabasesInParallel = ''''Y'''' AND SERVERPROPERTY(''''EngineEdition'''') = 5
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @DatabasesInParallel is not supported.'''', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF LEN(@ExecuteAsUser) > 128
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @ExecuteAsUser is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @LogToTable NOT IN(''''Y'''',''''N'''') OR @LogToTable IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @LogToTable is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @Execute NOT IN(''''Y'''',''''N'''') OR @Execute IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The value for the parameter @Execute is not supported.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS(SELECT * FROM @Errors)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The documentation is available at https://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html.'''', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Check that selected databases and availability groups exist                                //--
  ----------------------------------------------------------------------------------------------------

  SET @ErrorMessage = ''''''''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + '''', ''''
  FROM @SelectedDatabases
  WHERE DatabaseName NOT LIKE ''''%[%]%''''
  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The following databases in the @Databases parameter do not exist: '''' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + ''''.'''', 10, 1
  END

  SET @ErrorMessage = ''''''''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + '''', ''''
  FROM @SelectedIndexes
  WHERE DatabaseName NOT LIKE ''''%[%]%''''
  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The following databases in the @Indexes parameter do not exist: '''' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + ''''.'''', 10, 1
  END

  SET @ErrorMessage = ''''''''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(AvailabilityGroupName) + '''', ''''
  FROM @SelectedAvailabilityGroups
  WHERE AvailabilityGroupName NOT LIKE ''''%[%]%''''
  AND AvailabilityGroupName NOT IN (SELECT AvailabilityGroupName FROM @tmpAvailabilityGroups)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The following availability groups do not exist: '''' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + ''''.'''', 10, 1
  END

  SET @ErrorMessage = ''''''''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + '''', ''''
  FROM @SelectedIndexes
  WHERE DatabaseName NOT LIKE ''''%[%]%''''
  AND DatabaseName IN (SELECT DatabaseName FROM @tmpDatabases)
  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases WHERE Selected = 1)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT ''''The following databases have been selected in the @Indexes parameter, but not in the @Databases or @AvailabilityGroups parameters: '''' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + ''''.'''', 10, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Raise errors                                                                               //--
  ----------------------------------------------------------------------------------------------------

  DECLARE ErrorCursor CURSOR FAST_FORWARD FOR SELECT [Message], Severity, [State] FROM @Errors ORDER BY [ID] ASC

  OPEN ErrorCursor

  FETCH ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState

  WHILE @@FETCH_STATUS = 0
  BEGIN
    RAISERROR(''''%s'''', @CurrentSeverity, @CurrentState, @CurrentMessage) WITH NOWAIT
    RAISERROR(@EmptyLine, 10, 1) WITH NOWAIT

    FETCH NEXT FROM ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState
  END

  CLOSE ErrorCursor

  DEALLOCATE ErrorCursor

  IF EXISTS (SELECT * FROM @Errors WHERE Severity >= 16)
  BEGIN
    SET @ReturnCode = 50000
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Should statistics be updated on the partition level?                                       //--
  ----------------------------------------------------------------------------------------------------

  SET @PartitionLevelStatistics = CASE WHEN @PartitionLevel = ''''Y'''' AND ((@Version >= 12.05 AND @Version < 13) OR @Version >= 13.04422 OR SERVERPROPERTY(''''EngineEdition'''') IN (5,8)) THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Update database order                                                                      //--
  ----------------------------------------------------------------------------------------------------

  IF @DatabaseOrder IN(''''DATABASE_SIZE_ASC'''',''''DATABASE_SIZE_DESC'''')
  BEGIN
    UPDATE tmpDatabases
    SET DatabaseSize = (SELECT SUM(CAST(size AS bigint)) FROM sys.master_files WHERE [type] = 0 AND database_id = DB_ID(tmpDatabases.DatabaseName))
    FROM @tmpDatabases tmpDatabases
  END

  IF @DatabaseOrder IS NULL
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY StartPosition ASC, DatabaseName ASC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = ''''DATABASE_NAME_ASC''''
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseName ASC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = ''''DATABASE_NAME_DESC''''
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseName DESC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = ''''DATABASE_SIZE_ASC''''
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseSize ASC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = ''''DATABASE_SIZE_DESC''''
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseSize DESC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END

  ----------------------------------------------------------------------------------------------------
  --// Update the queue                                                                           //--
  ----------------------------------------------------------------------------------------------------

  IF @DatabasesInParallel = ''''Y''''
  BEGIN

    BEGIN TRY

      SELECT @QueueID = QueueID
      FROM dbo.[Queue]
      WHERE SchemaName = @SchemaName
      AND ObjectName = @ObjectName
      AND [Parameters] = @Parameters

      IF @QueueID IS NULL
      BEGIN
        BEGIN TRANSACTION

        SELECT @QueueID = QueueID
        FROM dbo.[Queue] WITH (UPDLOCK, HOLDLOCK)
        WHERE SchemaName = @SchemaName
        AND ObjectName = @ObjectName
        AND [Parameters] = @Parameters

        IF @QueueID IS NULL
        BEGIN
          INSERT INTO dbo.[Queue] (SchemaName, ObjectName, [Parameters])
          SELECT @SchemaName, @ObjectName, @Parameters

          SET @QueueID = SCOPE_IDENTITY()
        END

        COMMIT TRANSACTION
      END

      BEGIN TRANSACTION

      UPDATE [Queue]
      SET QueueStartTime = SYSDATETIME(),
          SessionID = @@SPID,
          RequestID = (SELECT request_id FROM sys.dm_exec_requests WHERE session_id = @@SPID),
          RequestStartTime = (SELECT start_time FROM sys.dm_exec_requests WHERE session_id = @@SPID)
      FROM dbo.[Queue] [Queue]
      WHERE QueueID = @QueueID
      AND NOT EXISTS (SELECT *
                      FROM sys.dm_exec_requests
                      WHERE session_id = [Queue].SessionID
                      AND request_id = [Queue].RequestID
                      AND start_time = [Queue].RequestStartTime)
      AND NOT EXISTS (SELECT *
                      FROM dbo.QueueDatabase QueueDatabase
                      INNER JOIN sys.dm_exec_requests ON QueueDatabase.SessionID = session_id AND QueueDatabase.RequestID = request_id AND QueueDatabase.RequestStartTime = start_time
                      WHERE QueueDatabase.QueueID = @QueueID)

      IF @@ROWCOUNT = 1
      BEGIN
        INSERT INTO dbo.QueueDatabase (QueueID, DatabaseName)
        SELECT @QueueID AS QueueID,
               DatabaseName
        FROM @tmpDatabases tmpDatabases
        WHERE Selected = 1
        AND NOT EXISTS (SELECT * FROM dbo.QueueDatabase WHERE DatabaseName = tmpDatabases.DatabaseName AND QueueID = @QueueID)

        DELETE QueueDatabase
        FROM dbo.QueueDatabase QueueDatabase
        WHERE QueueID = @QueueID
        AND NOT EXISTS (SELECT * FROM @tmpDatabases tmpDatabases WHERE DatabaseName = QueueDatabase.DatabaseName AND Selected = 1)

        UPDATE QueueDatabase
        SET DatabaseOrder = tmpDatabases.[Order]
        FROM dbo.QueueDatabase QueueDatabase
        INNER JOIN @tmpDatabases tmpDatabases ON QueueDatabase.DatabaseName = tmpDatabases.DatabaseName
        WHERE QueueID = @QueueID
      END

      COMMIT TRANSACTION

      SELECT @QueueStartTime = QueueStartTime
      FROM dbo.[Queue]
      WHERE QueueID = @QueueID

    END TRY

    BEGIN CATCH
      IF XACT_STATE() <> 0
      BEGIN
        ROLLBACK TRANSACTION
      END
      SET @ErrorMessage = ''''Msg '''' + CAST(ERROR_NUMBER() AS nvarchar) + '''', '''' + ISNULL(ERROR_MESSAGE(),'''''''')
      RAISERROR(''''%s'''',16,1,@ErrorMessage) WITH NOWAIT
      RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      SET @ReturnCode = ERROR_NUMBER()
      GOTO Logging
    END CATCH

  END

  ----------------------------------------------------------------------------------------------------
  --// Execute commands                                                                           //--
  ----------------------------------------------------------------------------------------------------

  WHILE (1 = 1)
  BEGIN

    IF @DatabasesInParallel = ''''Y''''
    BEGIN
      UPDATE QueueDatabase
      SET DatabaseStartTime = NULL,
          SessionID = NULL,
          RequestID = NULL,
          RequestStartTime = NULL
      FROM dbo.QueueDatabase QueueDatabase
      WHERE QueueID = @QueueID
      AND DatabaseStartTime IS NOT NULL
      AND DatabaseEndTime IS NULL
      AND NOT EXISTS (SELECT * FROM sys.dm_exec_requests WHERE session_id = QueueDatabase.SessionID AND request_id = QueueDatabase.RequestID AND start_time = QueueDatabase.RequestStartTime)

      UPDATE QueueDatabase
      SET DatabaseStartTime = SYSDATETIME(),
          DatabaseEndTime = NULL,
          SessionID = @@SPID,
          RequestID = (SELECT request_id FROM sys.dm_exec_requests WHERE session_id = @@SPID),
          RequestStartTime = (SELECT start_time FROM sys.dm_exec_requests WHERE session_id = @@SPID),
          @CurrentDatabaseName = DatabaseName
      FROM (SELECT TOP 1 DatabaseStartTime,
                         DatabaseEndTime,
                         SessionID,
                         RequestID,
                         RequestStartTime,
                         DatabaseName
            FROM dbo.QueueDatabase
            WHERE QueueID = @QueueID
            AND (DatabaseStartTime < @QueueStartTime OR DatabaseStartTime IS NULL)
            AND NOT (DatabaseStartTime IS NOT NULL AND DatabaseEndTime IS NULL)
            ORDER BY DatabaseOrder ASC
            ) QueueDatabase
    END
    ELSE
    BEGIN
      SELECT TOP 1 @CurrentDBID = ID,
                   @CurrentDatabaseName = DatabaseName
      FROM @tmpDatabases
      WHERE Selected = 1
      AND Completed = 0
      ORDER BY [Order] ASC
    END

    IF @@ROWCOUNT = 0
    BEGIN
      BREAK
    END

    SET @CurrentDatabase_sp_executesql = QUOTENAME(@CurrentDatabaseName) + ''''.sys.sp_executesql''''

    BEGIN
      SET @DatabaseMessage = ''''Date and time: '''' + CONVERT(nvarchar,SYSDATETIME(),120)
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = ''''Database: '''' + QUOTENAME(@CurrentDatabaseName)
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT
    END

    SELECT @CurrentUserAccess = user_access_desc,
           @CurrentIsReadOnly = is_read_only,
           @CurrentDatabaseState = state_desc,
           @CurrentInStandby = is_in_standby,
           @CurrentRecoveryModel = recovery_model_desc
    FROM sys.databases
    WHERE [name] = @CurrentDatabaseName

    BEGIN
      SET @DatabaseMessage = ''''State: '''' + @CurrentDatabaseState
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = ''''Standby: '''' + CASE WHEN @CurrentInStandby = 1 THEN ''''Yes'''' ELSE ''''No'''' END
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = ''''Updateability: '''' + CASE WHEN @CurrentIsReadOnly = 1 THEN ''''READ_ONLY'''' WHEN  @CurrentIsReadOnly = 0 THEN ''''READ_WRITE'''' END
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = ''''User access: '''' + @CurrentUserAccess
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = ''''Recovery model: '''' + @CurrentRecoveryModel
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT
    END

    IF @Version >= 11 AND SERVERPROPERTY(''''IsHadrEnabled'''') = 1
    BEGIN
      SELECT @CurrentReplicaID = databases.replica_id
      FROM sys.databases databases
      INNER JOIN sys.availability_replicas availability_replicas ON databases.replica_id = availability_replicas.replica_id
      WHERE databases.[name] = @CurrentDatabaseName

      SELECT @CurrentAvailabilityGroupID = group_id
      FROM sys.availability_replicas
      WHERE replica_id = @CurrentReplicaID

      SELECT @CurrentAvailabilityGroupRole = role_desc
      FROM sys.dm_hadr_availability_replica_states
      WHERE replica_id = @CurrentReplicaID

      SELECT @CurrentAvailabilityGroup = [name]
      FROM sys.availability_groups
      WHERE group_id = @CurrentAvailabilityGroupID
    END

    IF SERVERPROPERTY(''''EngineEdition'''') <> 5
    BEGIN
      SELECT @CurrentDatabaseMirroringRole = UPPER(mirroring_role_desc)
      FROM sys.database_mirroring database_mirroring
      INNER JOIN sys.databases databases ON database_mirroring.database_id = databases.database_id
      WHERE databases.[name] = @CurrentDatabaseName
    END

    IF @CurrentAvailabilityGroup IS NOT NULL
    BEGIN
      SET @DatabaseMessage = ''''Availability group: '''' + ISNULL(@CurrentAvailabilityGroup,''''N/A'''')
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = ''''Availability group role: '''' + ISNULL(@CurrentAvailabilityGroupRole,''''N/A'''')
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT
    END

    IF @CurrentDatabaseMirroringRole IS NOT NULL
    BEGIN
      SET @DatabaseMessage = ''''Database mirroring role: '''' + @CurrentDatabaseMirroringRole
      RAISERROR(''''%s'''',10,1,@DatabaseMessage) WITH NOWAIT
    END

    RAISERROR(@EmptyLine,10,1) WITH NOWAIT

    IF @ExecuteAsUser IS NOT NULL
    AND @CurrentDatabaseState = ''''ONLINE''''
    AND NOT (@CurrentUserAccess = ''''SINGLE_USER'''')
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND (@CurrentAvailabilityGroupRole <> ''''PRIMARY'''' OR @CurrentAvailabilityGroupRole IS NULL))
    AND NOT (@AmazonRDS = 1 AND @CurrentDatabaseName = ''''rdsadmin'''')
    BEGIN
      SET @CurrentCommand = ''''''''
      SET @CurrentCommand += ''''IF EXISTS(SELECT * FROM sys.database_principals database_principals WHERE database_principals.[name] = @ParamExecuteAsUser) BEGIN SET @ParamExecuteAsUserExists = 1 END ELSE BEGIN SET @ParamExecuteAsUserExists = 0 END''''

      EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N''''@ParamExecuteAsUser sysname, @ParamExecuteAsUserExists bit OUTPUT'''', @ParamExecuteAsUser = @ExecuteAsUser, @ParamExecuteAsUserExists = @CurrentExecuteAsUserExists OUTPUT
    END

    IF @CurrentExecuteAsUserExists = 0
    BEGIN
      SET @DatabaseMessage = ''''The user '''' + QUOTENAME(@ExecuteAsUser) + '''' does not exist in the database '''' + QUOTENAME(@CurrentDatabaseName) + ''''.''''
      RAISERROR(''''%s'''',16,1,@DatabaseMessage) WITH NOWAIT
      RAISERROR(@EmptyLine,10,1) WITH NOWAIT
    END

    IF @CurrentDatabaseState = ''''ONLINE''''
    AND NOT (@CurrentUserAccess = ''''SINGLE_USER'''')
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND (@CurrentAvailabilityGroupRole <> ''''PRIMARY'''' OR @CurrentAvailabilityGroupRole IS NULL))
    AND NOT (@AmazonRDS = 1 AND @CurrentDatabaseName = ''''rdsadmin'''')
    AND NOT (@CurrentIsReadOnly = 1)
    AND (@CurrentExecuteAsUserExists = 1 OR @CurrentExecuteAsUserExists IS NULL)
    BEGIN

      -- Select indexes in the current database
      IF (EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IS NOT NULL) AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
      BEGIN
        SET @CurrentCommand = ''''SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;''''
                              + '''' SELECT SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, IsMemoryOptimized, IndexID, IndexName, IndexType, AllowPageLocks, HasFilter, IsImageText, IsNewLOB, IsFileStream, HasColumnstore, IsComputed, IsClusteredIndexComputed, IsTimestamp, OnReadOnlyFileGroup, ResumableIndexOperation, StatisticsID, StatisticsName, NoRecompute, IsIncremental, PartitionID, PartitionNumber, PartitionCount, [Order], Selected, Completed''''
                              + '''' FROM (''''

        IF EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IN(''''ALL'''',''''INDEX'''')
        BEGIN
          SET @CurrentCommand = @CurrentCommand + ''''SELECT schemas.[schema_id] AS SchemaID''''
                                                    + '''', schemas.[name] AS SchemaName''''
                                                    + '''', objects.[object_id] AS ObjectID''''
                                                    + '''', objects.[name] AS ObjectName''''
                                                    + '''', RTRIM(objects.[type]) AS ObjectType''''
                                                    + '''', '''' + CASE WHEN @Version >= 12 THEN ''''tables.is_memory_optimized'''' ELSE ''''0'''' END + '''' AS IsMemoryOptimized''''
                                                    + '''', indexes.index_id AS IndexID''''
                                                    + '''', indexes.[name] AS IndexName''''
                                                    + '''', indexes.[type] AS IndexType''''
                                                    + '''', indexes.allow_page_locks AS AllowPageLocks''''
                                                    + '''', indexes.has_filter AS HasFilter''''

                                                    + '''', CASE WHEN indexes.[type] = 1 AND EXISTS(SELECT * FROM sys.columns columns INNER JOIN sys.types types ON columns.system_type_id = types.user_type_id WHERE columns.[object_id] = objects.object_id AND types.name IN(''''''''image'''''''',''''''''text'''''''',''''''''ntext'''''''')) THEN 1 ELSE 0 END AS IsImageText''''

                                                    + '''', CASE WHEN indexes.[type] = 1 AND EXISTS(SELECT * FROM sys.columns columns INNER JOIN sys.types types ON columns.system_type_id = types.user_type_id OR (columns.user_type_id = types.user_type_id AND types.is_assembly_type = 1) WHERE columns.[object_id] = objects.object_id AND (types.name IN(''''''''xml'''''''') OR (types.name IN(''''''''varchar'''''''',''''''''nvarchar'''''''',''''''''varbinary'''''''') AND columns.max_length = -1) OR (types.is_assembly_type = 1 AND columns.max_length = -1))) THEN 1''''
                                                    + '''' WHEN indexes.[type] = 2 AND EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.[object_id] = columns.[object_id] AND index_columns.column_id = columns.column_id INNER JOIN sys.types types ON columns.system_type_id = types.user_type_id OR (columns.user_type_id = types.user_type_id AND types.is_assembly_type = 1) WHERE index_columns.[object_id] = objects.object_id AND index_columns.index_id = indexes.index_id AND (types.[name] IN(''''''''xml'''''''') OR (types.[name] IN(''''''''varchar'''''''',''''''''nvarchar'''''''',''''''''varbinary'''''''') AND columns.max_length = -1) OR (types.is_assembly_type = 1 AND columns.max_length = -1))) THEN 1 ELSE 0 END AS IsNewLOB''''

                                                    + '''', CASE WHEN indexes.[type] = 1 AND EXISTS(SELECT * FROM sys.columns columns WHERE columns.[object_id] = objects.object_id  AND columns.is_filestream = 1) THEN 1 ELSE 0 END AS IsFileStream''''

                                                    + '''', CASE WHEN EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.[object_id] = objects.object_id AND [type] IN(5,6)) THEN 1 ELSE 0 END AS HasColumnstore''''

                                                    + '''', CASE WHEN EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.object_id = columns.object_id AND index_columns.column_id = columns.column_id WHERE (index_columns.key_ordinal > 0 OR index_columns.partition_ordinal > 0) AND columns.is_computed = 1 AND index_columns.object_id = indexes.object_id AND index_columns.index_id = indexes.index_id) THEN 1 ELSE 0 END AS IsComputed''''

                                                    + '''', CASE WHEN EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.object_id = columns.object_id AND index_columns.column_id = columns.column_id INNER JOIN sys.indexes indexes2 ON index_columns.object_id = indexes2.object_id AND index_columns.index_id = indexes2.index_id WHERE (index_columns.key_ordinal > 0 OR index_columns.partition_ordinal > 0) AND columns.is_computed = 1 AND indexes2.[type] = 1 AND index_columns.object_id = indexes.object_id) THEN 1 ELSE 0 END AS IsClusteredIndexComputed''''

                                                    + '''', CASE WHEN EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.[object_id] = columns.[object_id] AND index_columns.column_id = columns.column_id INNER JOIN sys.types types ON columns.system_type_id = types.system_type_id WHERE index_columns.[object_id] = objects.object_id AND index_columns.index_id = indexes.index_id AND types.[name] = ''''''''timestamp'''''''') THEN 1 ELSE 0 END AS IsTimestamp''''

                                                    + '''', CASE WHEN EXISTS (SELECT * FROM sys.indexes indexes2 INNER JOIN sys.destination_data_spaces destination_data_spaces ON indexes.data_space_id = destination_data_spaces.partition_scheme_id INNER JOIN sys.filegroups filegroups ON destination_data_spaces.data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND indexes2.[object_id] = indexes.[object_id] AND indexes2.[index_id] = indexes.index_id'''' + CASE WHEN @PartitionLevel = ''''Y'''' THEN '''' AND destination_data_spaces.destination_id = partitions.partition_number'''' ELSE '''''''' END + '''') THEN 1''''
                                                    + '''' WHEN EXISTS (SELECT * FROM sys.indexes indexes2 INNER JOIN sys.filegroups filegroups ON indexes.data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND indexes.[object_id] = indexes2.[object_id] AND indexes.[index_id] = indexes2.index_id) THEN 1''''
                                                    + '''' WHEN indexes.[type] = 1 AND EXISTS (SELECT * FROM sys.tables tables INNER JOIN sys.filegroups filegroups ON tables.lob_data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND tables.[object_id] = objects.[object_id]) THEN 1 ELSE 0 END AS OnReadOnlyFileGroup''''

                                                    + '''', '''' + CASE WHEN @Version >= 14 OR SERVERPROPERTY(''''EngineEdition'''') IN (5, 8) THEN ''''CASE WHEN EXISTS(SELECT * FROM sys.index_resumable_operations index_resumable_operations WHERE state_desc = ''''''''PAUSED'''''''' AND index_resumable_operations.object_id = indexes.object_id AND index_resumable_operations.index_id = indexes.index_id'''' + CASE WHEN @PartitionLevel = ''''Y'''' THEN '''' AND (index_resumable_operations.partition_number = partitions.partition_number OR index_resumable_operations.partition_number IS NULL)'''' ELSE '''''''' END + '''') THEN 1 ELSE 0 END'''' ELSE ''''0'''' END + '''' AS ResumableIndexOperation''''

                                                    + '''', stats.stats_id AS StatisticsID''''
                                                    + '''', stats.name AS StatisticsName''''
                                                    + '''', stats.no_recompute AS NoRecompute''''
                                                    + '''', '''' + CASE WHEN @Version >= 12 THEN ''''stats.is_incremental'''' ELSE ''''0'''' END + '''' AS IsIncremental''''
                                                    + '''', '''' + CASE WHEN @PartitionLevel = ''''Y'''' THEN ''''partitions.partition_id AS PartitionID'''' WHEN @PartitionLevel = ''''N'''' THEN ''''NULL AS PartitionID'''' END
                                                    + '''', '''' + CASE WHEN @PartitionLevel = ''''Y'''' THEN ''''partitions.partition_number AS PartitionNumber'''' WHEN @PartitionLevel = ''''N'''' THEN ''''NULL AS PartitionNumber'''' END
                                                    + '''', '''' + CASE WHEN @PartitionLevel = ''''Y'''' THEN ''''IndexPartitions.partition_count AS PartitionCount'''' WHEN @PartitionLevel = ''''N'''' THEN ''''NULL AS PartitionCount'''' END
                                                    + '''', 0 AS [Order]''''
                                                    + '''', 0 AS Selected''''
                                                    + '''', 0 AS Completed''''
                                                    + '''' FROM sys.indexes indexes''''
                                                    + '''' INNER JOIN sys.objects objects ON indexes.[object_id] = objects.[object_id]''''
                                                    + '''' INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id]''''
                                                    + '''' LEFT OUTER JOIN sys.tables tables ON objects.[object_id] = tables.[object_id]''''
                                                    + '''' LEFT OUTER JOIN sys.stats stats ON indexes.[object_id] = stats.[object_id] AND indexes.[index_id] = stats.[stats_id]''''
          IF @PartitionLevel = ''''Y''''
          BEGIN
            SET @CurrentCommand = @CurrentCommand + '''' LEFT OUTER JOIN sys.partitions partitions ON indexes.[object_id] = partitions.[object_id] AND indexes.index_id = partitions.index_id''''
                                                      + '''' LEFT OUTER JOIN (SELECT partitions.[object_id], partitions.index_id, COUNT(DISTINCT partitions.partition_number) AS partition_count FROM sys.partitions partitions GROUP BY partitions.[object_id], partitions.index_id) IndexPartitions ON partitions.[object_id] = IndexPartitions.[object_id] AND partitions.[index_id] = IndexPartitions.[index_id]''''
          END

          SET @CurrentCommand = @CurrentCommand + '''' WHERE objects.[type] IN(''''''''U'''''''',''''''''V'''''''')''''
                                                    + CASE WHEN @MSShippedObjects = ''''N'''' THEN '''' AND objects.is_ms_shipped = 0'''' ELSE '''''''' END
                                                    + '''' AND indexes.[type] IN(1,2,3,4,5,6,7)''''
                                                    + '''' AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0''''
        END

        IF (EXISTS(SELECT * FROM @ActionsPreferred) AND @UpdateStatistics = ''''COLUMNS'''') OR @UpdateStatistics = ''''ALL''''
        BEGIN
          SET @CurrentCommand = @CurrentCommand + '''' UNION ''''
        END

        IF @UpdateStatistics IN(''''ALL'''',''''COLUMNS'''')
        BEGIN
          SET @CurrentCommand = @CurrentCommand + ''''SELECT schemas.[schema_id] AS SchemaID''''
                                                    + '''', schemas.[name] AS SchemaName''''
                                                    + '''', objects.[object_id] AS ObjectID''''
                                                    + '''', objects.[name] AS ObjectName''''
                                                    + '''', RTRIM(objects.[type]) AS ObjectType''''
                                                    + '''', '''' + CASE WHEN @Version >= 12 THEN ''''tables.is_memory_optimized'''' ELSE ''''0'''' END + '''' AS IsMemoryOptimized''''
                                                    + '''', NULL AS IndexID, NULL AS IndexName''''
                                                    + '''', NULL AS IndexType''''
                                                    + '''', NULL AS AllowPageLocks''''
                                                    + '''', NULL AS HasFilter''''
                                                    + '''', NULL AS IsImageText''''
                                                    + '''', NULL AS IsNewLOB''''
                                                    + '''', NULL AS IsFileStream''''
                                                    + '''', NULL AS HasColumnstore''''
                                                    + '''', NULL AS IsComputed''''
                                                    + '''', NULL AS IsClusteredIndexComputed''''
                                                    + '''', NULL AS IsTimestamp''''
                                                    + '''', NULL AS OnReadOnlyFileGroup''''
                                                    + '''', NULL AS ResumableIndexOperation''''
                                                    + '''', stats.stats_id AS StatisticsID''''
                                                    + '''', stats.name AS StatisticsName''''
                                                    + '''', stats.no_recompute AS NoRecompute''''
                                                    + '''', '''' + CASE WHEN @Version >= 12 THEN ''''stats.is_incremental'''' ELSE ''''0'''' END + '''' AS IsIncremental''''
                                                    + '''', NULL AS PartitionID''''
                                                    + '''', '''' + CASE WHEN @PartitionLevelStatistics = 1 THEN ''''dm_db_incremental_stats_properties.partition_number'''' ELSE ''''NULL'''' END + '''' AS PartitionNumber''''
                                                    + '''', NULL AS PartitionCount''''
                                                    + '''', 0 AS [Order]''''
                                                    + '''', 0 AS Selected''''
                                                    + '''', 0 AS Completed''''
                                                    + '''' FROM sys.stats stats''''
                                                    + '''' INNER JOIN sys.objects objects ON stats.[object_id] = objects.[object_id]''''
                                                    + '''' INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id]''''
                                                    + '''' LEFT OUTER JOIN sys.tables tables ON objects.[object_id] = tables.[object_id]''''

          IF @PartitionLevelStatistics = 1
          BEGIN
            SET @CurrentCommand = @CurrentCommand + '''' OUTER APPLY sys.dm_db_incremental_stats_properties(stats.object_id, stats.stats_id) dm_db_incremental_stats_properties''''
          END

          SET @CurrentCommand = @CurrentCommand + '''' WHERE objects.[type] IN(''''''''U'''''''',''''''''V'''''''')''''
                                                    + CASE WHEN @Version >= 12 THEN '''' AND (tables.is_memory_optimized = 0 OR tables.is_memory_optimized IS NULL)'''' ELSE '''''''' END
                                                    + CASE WHEN @MSShippedObjects = ''''N'''' THEN '''' AND objects.is_ms_shipped = 0'''' ELSE '''''''' END
                                                    + '''' AND NOT EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.[object_id] = stats.[object_id] AND indexes.index_id = stats.stats_id)''''
                                                    + '''' AND NOT EXISTS(SELECT * FROM sys.indexes indexes2 WHERE indexes2.[object_id] = stats.[object_id] AND indexes2.type = 1 AND indexes2.is_disabled = 1)''''

          IF @Version >= 12
          BEGIN
            SET @CurrentCommand = @CurrentCommand + '''' UNION ''''

            SET @CurrentCommand = @CurrentCommand + ''''SELECT schemas.[schema_id] AS SchemaID''''
                                                      + '''', schemas.[name] AS SchemaName''''
                                                      + '''', objects.[object_id] AS ObjectID''''
                                                      + '''', objects.[name] AS ObjectName''''
                                                      + '''', RTRIM(objects.[type]) AS ObjectType''''
                                                      + '''', tables.is_memory_optimized AS IsMemoryOptimized''''
                                                      + '''', NULL AS IndexID, NULL AS IndexName''''
                                                      + '''', NULL AS IndexType''''
                                                      + '''', NULL AS AllowPageLocks''''
                                                      + '''', NULL AS HasFilter''''
                                                      + '''', NULL AS IsImageText''''
                                                      + '''', NULL AS IsNewLOB''''
                                                      + '''', NULL AS IsFileStream''''
                                                      + '''', NULL AS HasColumnstore''''
                                                      + '''', NULL AS IsComputed''''
                                                      + '''', NULL AS IsClusteredIndexComputed''''
                                                      + '''', NULL AS IsTimestamp''''
                                                      + '''', NULL AS OnReadOnlyFileGroup''''
                                                      + '''', NULL AS ResumableIndexOperation''''
                                                      + '''', stats.stats_id AS StatisticsID''''
                                                      + '''', stats.name AS StatisticsName''''
                                                      + '''', stats.no_recompute AS NoRecompute''''
                                                      + '''', '''' + CASE WHEN @Version >= 12 THEN ''''stats.is_incremental'''' ELSE ''''0'''' END + '''' AS IsIncremental''''
                                                      + '''', NULL AS PartitionID''''
                                                      + '''', NULL AS PartitionNumber''''
                                                      + '''', NULL AS PartitionCount''''
                                                      + '''', 0 AS [Order]''''
                                                      + '''', 0 AS Selected''''
                                                      + '''', 0 AS Completed''''
                                                      + '''' FROM sys.stats stats''''
                                                      + '''' INNER JOIN sys.objects objects ON stats.[object_id] = objects.[object_id]''''
                                                      + '''' INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id]''''
                                                      + '''' INNER JOIN sys.tables tables ON objects.[object_id] = tables.[object_id]''''

            SET @CurrentCommand = @CurrentCommand + '''' WHERE objects.[type] = ''''''''U''''''''''''
                                                      + '''' AND tables.is_memory_optimized = 1''''
                                                      + CASE WHEN @MSShippedObjects = ''''N'''' THEN '''' AND objects.is_ms_shipped = 0'''' ELSE '''''''' END
                                                      + '''' AND NOT EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.[object_id] = stats.[object_id] AND indexes.index_id = stats.stats_id)''''
          END
        END

        SET @CurrentCommand = @CurrentCommand + '''') IndexesStatistics''''

        INSERT INTO @tmpIndexesStatistics (SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, IsMemoryOptimized, IndexID, IndexName, IndexType, AllowPageLocks, HasFilter, IsImageText, IsNewLOB, IsFileStream, HasColumnstore, IsComputed, IsClusteredIndexComputed, IsTimestamp, OnReadOnlyFileGroup, ResumableIndexOperation, StatisticsID, StatisticsName, [NoRecompute], IsIncremental, PartitionID, PartitionNumber, PartitionCount, [Order], Selected, Completed)
        EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand
        SET @Error = @@ERROR
        IF @Error <> 0
        BEGIN
          SET @ReturnCode = @Error
        END
      END

      IF @Indexes IS NULL
      BEGIN
        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = 1
        FROM @tmpIndexesStatistics tmpIndexesStatistics
      END
      ELSE
      BEGIN
        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = SelectedIndexes.Selected
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN @SelectedIndexes SelectedIndexes
        ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,''''_'''',''''[_]'''') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,''''_'''',''''[_]'''') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,''''_'''',''''[_]'''') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,''''_'''',''''[_]'''')
        WHERE SelectedIndexes.Selected = 1

        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = SelectedIndexes.Selected
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN @SelectedIndexes SelectedIndexes
        ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,''''_'''',''''[_]'''') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,''''_'''',''''[_]'''') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,''''_'''',''''[_]'''') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,''''_'''',''''[_]'''')
        WHERE SelectedIndexes.Selected = 0

        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.StartPosition = SelectedIndexes2.StartPosition
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN (SELECT tmpIndexesStatistics.SchemaName, tmpIndexesStatistics.ObjectName, tmpIndexesStatistics.IndexName, tmpIndexesStatistics.StatisticsName, MIN(SelectedIndexes.StartPosition) AS StartPosition
                    FROM @tmpIndexesStatistics tmpIndexesStatistics
                    INNER JOIN @SelectedIndexes SelectedIndexes
                    ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,''''_'''',''''[_]'''') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,''''_'''',''''[_]'''') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,''''_'''',''''[_]'''') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,''''_'''',''''[_]'''')
                    WHERE SelectedIndexes.Selected = 1
                    GROUP BY tmpIndexesStatistics.SchemaName, tmpIndexesStatistics.ObjectName, tmpIndexesStatistics.IndexName, tmpIndexesStatistics.StatisticsName) SelectedIndexes2
        ON tmpIndexesStatistics.SchemaName = SelectedIndexes2.SchemaName
        AND tmpIndexesStatistics.ObjectName = SelectedIndexes2.ObjectName
        AND (tmpIndexesStatistics.IndexName = SelectedIndexes2.IndexName OR tmpIndexesStatistics.IndexName IS NULL)
        AND (tmpIndexesStatistics.StatisticsName = SelectedIndexes2.StatisticsName OR tmpIndexesStatistics.StatisticsName IS NULL)
      END;

      WITH tmpIndexesStatistics AS (
      SELECT SchemaName, ObjectName, [Order], ROW_NUMBER() OVER (ORDER BY ISNULL(ResumableIndexOperation,0) DESC, StartPosition ASC, SchemaName ASC, ObjectName ASC, CASE WHEN IndexType IS NULL THEN 1 ELSE 0 END ASC, IndexType ASC, IndexName ASC, StatisticsName ASC, PartitionNumber ASC) AS RowNumber
      FROM @tmpIndexesStatistics tmpIndexesStatistics
      WHERE Selected = 1
      )
      UPDATE tmpIndexesStatistics
      SET [Order] = RowNumber

      SET @ErrorMessage = ''''''''
      SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ''''.'''' + QUOTENAME(SchemaName) + ''''.'''' + QUOTENAME(ObjectName) + '''', ''''
      FROM @SelectedIndexes SelectedIndexes
      WHERE DatabaseName = @CurrentDatabaseName
      AND SchemaName NOT LIKE ''''%[%]%''''
      AND ObjectName NOT LIKE ''''%[%]%''''
      AND IndexName LIKE ''''%[%]%''''
      AND NOT EXISTS (SELECT * FROM @tmpIndexesStatistics WHERE SchemaName = SelectedIndexes.SchemaName AND ObjectName = SelectedIndexes.ObjectName)
      IF @@ROWCOUNT > 0
      BEGIN
        SET @ErrorMessage = ''''The following objects in the @Indexes parameter do not exist: '''' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + ''''.''''
        RAISERROR(''''%s'''',10,1,@ErrorMessage) WITH NOWAIT
        SET @Error = @@ERROR
        RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      END

      SET @ErrorMessage = ''''''''
      SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + QUOTENAME(SchemaName) + ''''.'''' + QUOTENAME(ObjectName) + ''''.'''' + QUOTENAME(IndexName) + '''', ''''
      FROM @SelectedIndexes SelectedIndexes
      WHERE DatabaseName = @CurrentDatabaseName
      AND SchemaName NOT LIKE ''''%[%]%''''
      AND ObjectName NOT LIKE ''''%[%]%''''
      AND IndexName NOT LIKE ''''%[%]%''''
      AND NOT EXISTS (SELECT * FROM @tmpIndexesStatistics WHERE SchemaName = SelectedIndexes.SchemaName AND ObjectName = SelectedIndexes.ObjectName AND IndexName = SelectedIndexes.IndexName)
      IF @@ROWCOUNT > 0
      BEGIN
        SET @ErrorMessage = ''''The following indexes in the @Indexes parameter do not exist: '''' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + ''''.''''
        RAISERROR(''''%s'''',10,1,@ErrorMessage) WITH NOWAIT
        SET @Error = @@ERROR
        RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      END

      WHILE (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
      BEGIN
        SELECT TOP 1 @CurrentIxID = ID,
                     @CurrentIxOrder = [Order],
                     @CurrentSchemaID = SchemaID,
                     @CurrentSchemaName = SchemaName,
                     @CurrentObjectID = ObjectID,
                     @CurrentObjectName = ObjectName,
                     @CurrentObjectType = ObjectType,
                     @CurrentIsMemoryOptimized = IsMemoryOptimized,
                     @CurrentIndexID = IndexID,
                     @CurrentIndexName = IndexName,
                     @CurrentIndexType = IndexType,
                     @CurrentAllowPageLocks = AllowPageLocks,
                     @CurrentHasFilter = HasFilter,
                     @CurrentIsImageText = IsImageText,
                     @CurrentIsNewLOB = IsNewLOB,
                     @CurrentIsFileStream = IsFileStream,
                     @CurrentHasColumnstore = HasColumnstore,
                     @CurrentIsComputed = IsComputed,
                     @CurrentIsClusteredIndexComputed = IsClusteredIndexComputed,
                     @CurrentIsTimestamp = IsTimestamp,
                     @CurrentOnReadOnlyFileGroup = OnReadOnlyFileGroup,
                     @CurrentResumableIndexOperation = ResumableIndexOperation,
                     @CurrentStatisticsID = StatisticsID,
                     @CurrentStatisticsName = StatisticsName,
                     @CurrentNoRecompute = [NoRecompute],
                     @CurrentIsIncremental = IsIncremental,
                     @CurrentPartitionID = PartitionID,
                     @CurrentPartitionNumber = PartitionNumber,
                     @CurrentPartitionCount = PartitionCount
        FROM @tmpIndexesStatistics
        WHERE Selected = 1
        AND Completed = 0
        ORDER BY [Order] ASC

        IF @@ROWCOUNT = 0
        BEGIN
          BREAK
        END

        -- Is the index a partition?
        IF @CurrentPartitionNumber IS NULL OR @CurrentPartitionCount = 1 BEGIN SET @CurrentIsPartition = 0 END ELSE BEGIN SET @CurrentIsPartition = 1 END

        -- Does the index exist?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand = ''''''''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = ''''SET LOCK_TIMEOUT '''' + CAST(@LockTimeout * 1000 AS nvarchar) + ''''; ''''

          IF @CurrentIsPartition = 0 SET @CurrentCommand += ''''IF EXISTS(SELECT * FROM sys.indexes indexes INNER JOIN sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''''''''U'''''''',''''''''V'''''''') AND indexes.[type] IN(1,2,3,4,5,6,7) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0 AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND indexes.index_id = @ParamIndexID AND indexes.[name] = @ParamIndexName AND indexes.[type] = @ParamIndexType) BEGIN SET @ParamIndexExists = 1 END''''
          IF @CurrentIsPartition = 1 SET @CurrentCommand += ''''IF EXISTS(SELECT * FROM sys.indexes indexes INNER JOIN sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] INNER JOIN sys.partitions partitions ON indexes.[object_id] = partitions.[object_id] AND indexes.index_id = partitions.index_id WHERE objects.[type] IN(''''''''U'''''''',''''''''V'''''''') AND indexes.[type] IN(1,2,3,4,5,6,7) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0 AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND indexes.index_id = @ParamIndexID AND indexes.[name] = @ParamIndexName AND indexes.[type] = @ParamIndexType AND partitions.partition_id = @ParamPartitionID AND partitions.partition_number = @ParamPartitionNumber) BEGIN SET @ParamIndexExists = 1 END''''

          BEGIN TRY
            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N''''@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamIndexID int, @ParamIndexName sysname, @ParamIndexType int, @ParamPartitionID bigint, @ParamPartitionNumber int, @ParamIndexExists bit OUTPUT'''', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamIndexID = @CurrentIndexID, @ParamIndexName = @CurrentIndexName, @ParamIndexType = @CurrentIndexType, @ParamPartitionID = @CurrentPartitionID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamIndexExists = @CurrentIndexExists OUTPUT

            IF @CurrentIndexExists IS NULL
            BEGIN
              SET @CurrentIndexExists = 0
              GOTO NoAction
            END
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = ''''Msg '''' + CAST(ERROR_NUMBER() AS nvarchar) + '''', '''' + ISNULL(ERROR_MESSAGE(),'''''''') + CASE WHEN ERROR_NUMBER() = 1222 THEN '''' The index '''' + QUOTENAME(@CurrentIndexName) + '''' on the object '''' + QUOTENAME(@CurrentDatabaseName) + ''''.'''' + QUOTENAME(@CurrentSchemaName) + ''''.'''' + QUOTENAME(@CurrentObjectName) + '''' is locked. It could not be checked if the index exists.'''' ELSE '''''''' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR(''''%s'''',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Does the statistics exist?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL
        BEGIN
          SET @CurrentCommand = ''''''''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = ''''SET LOCK_TIMEOUT '''' + CAST(@LockTimeout * 1000 AS nvarchar) + ''''; ''''

          SET @CurrentCommand += ''''IF EXISTS(SELECT * FROM sys.stats stats INNER JOIN sys.objects objects ON stats.[object_id] = objects.[object_id] INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''''''''U'''''''',''''''''V'''''''')'''' + CASE WHEN @MSShippedObjects = ''''N'''' THEN '''' AND objects.is_ms_shipped = 0'''' ELSE '''''''' END + '''' AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND stats.stats_id = @ParamStatisticsID AND stats.[name] = @ParamStatisticsName) BEGIN SET @ParamStatisticsExists = 1 END''''

          BEGIN TRY
            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N''''@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamStatisticsID int, @ParamStatisticsName sysname, @ParamStatisticsExists bit OUTPUT'''', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamStatisticsID = @CurrentStatisticsID, @ParamStatisticsName = @CurrentStatisticsName, @ParamStatisticsExists = @CurrentStatisticsExists OUTPUT

            IF @CurrentStatisticsExists IS NULL
            BEGIN
              SET @CurrentStatisticsExists = 0
              GOTO NoAction
            END
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = ''''Msg '''' + CAST(ERROR_NUMBER() AS nvarchar) + '''', '''' + ISNULL(ERROR_MESSAGE(),'''''''') + CASE WHEN ERROR_NUMBER() = 1222 THEN '''' The statistics '''' + QUOTENAME(@CurrentStatisticsName) + '''' on the object '''' + QUOTENAME(@CurrentDatabaseName) + ''''.'''' + QUOTENAME(@CurrentSchemaName) + ''''.'''' + QUOTENAME(@CurrentObjectName) + '''' is locked. It could not be checked if the statistics exists.'''' ELSE '''''''' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR(''''%s'''',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Has the data in the statistics been modified since the statistics was last updated?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL
        BEGIN
          SET @CurrentCommand = ''''''''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = ''''SET LOCK_TIMEOUT '''' + CAST(@LockTimeout * 1000 AS nvarchar) + ''''; ''''

          IF @PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1
          BEGIN
            SET @CurrentCommand += ''''SELECT @ParamRowCount = [rows], @ParamModificationCounter = modification_counter FROM sys.dm_db_incremental_stats_properties (@ParamObjectID, @ParamStatisticsID) WHERE partition_number = @ParamPartitionNumber''''
          END
          ELSE
          IF (@Version >= 10.504000 AND @Version < 11) OR @Version >= 11.03000
          BEGIN
            SET @CurrentCommand += ''''SELECT @ParamRowCount = [rows], @ParamModificationCounter = modification_counter FROM sys.dm_db_stats_properties (@ParamObjectID, @ParamStatisticsID)''''
          END
          ELSE
          BEGIN
            SET @CurrentCommand += ''''SELECT @ParamRowCount = rowcnt, @ParamModificationCounter = rowmodctr FROM sys.sysindexes sysindexes WHERE sysindexes.[id] = @ParamObjectID AND sysindexes.[indid] = @ParamStatisticsID''''
          END

          BEGIN TRY
            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N''''@ParamObjectID int, @ParamStatisticsID int, @ParamPartitionNumber int, @ParamRowCount bigint OUTPUT, @ParamModificationCounter bigint OUTPUT'''', @ParamObjectID = @CurrentObjectID, @ParamStatisticsID = @CurrentStatisticsID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamRowCount = @CurrentRowCount OUTPUT, @ParamModificationCounter = @CurrentModificationCounter OUTPUT

            IF @CurrentRowCount IS NULL SET @CurrentRowCount = 0
            IF @CurrentModificationCounter IS NULL SET @CurrentModificationCounter = 0
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = ''''Msg '''' + CAST(ERROR_NUMBER() AS nvarchar) + '''', '''' + ISNULL(ERROR_MESSAGE(),'''''''') + CASE WHEN ERROR_NUMBER() = 1222 THEN '''' The statistics '''' + QUOTENAME(@CurrentStatisticsName) + '''' on the object '''' + QUOTENAME(@CurrentDatabaseName) + ''''.'''' + QUOTENAME(@CurrentSchemaName) + ''''.'''' + QUOTENAME(@CurrentObjectName) + '''' is locked. The rows and modification_counter could not be checked.'''' ELSE '''''''' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR(''''%s'''',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Is the index fragmented?
        IF @CurrentIndexID IS NOT NULL
        AND @CurrentOnReadOnlyFileGroup = 0
        AND EXISTS(SELECT * FROM @ActionsPreferred)
        AND (EXISTS(SELECT [Priority], [Action], COUNT(*) FROM @ActionsPreferred GROUP BY [Priority], [Action] HAVING COUNT(*) <> 3) OR @MinNumberOfPages > 0 OR @MaxNumberOfPages IS NOT NULL)
        AND NOT (SERVERPROPERTY(''''EngineEdition'''') = 8 AND @CurrentDatabaseName IN (''''master'''', ''''model''''))
        BEGIN
          SET @CurrentCommand = ''''''''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = ''''SET LOCK_TIMEOUT '''' + CAST(@LockTimeout * 1000 AS nvarchar) + ''''; ''''

          SET @CurrentCommand += ''''SELECT @ParamFragmentationLevel = MAX(avg_fragmentation_in_percent), @ParamPageCount = SUM(page_count) FROM sys.dm_db_index_physical_stats(DB_ID(@ParamDatabaseName), @ParamObjectID, @ParamIndexID, @ParamPartitionNumber, ''''''''LIMITED'''''''') WHERE alloc_unit_type_desc = ''''''''IN_ROW_DATA'''''''' AND index_level = 0''''

          BEGIN TRY
            EXECUTE sp_executesql @stmt = @CurrentCommand, @params = N''''@ParamDatabaseName nvarchar(max), @ParamObjectID int, @ParamIndexID int, @ParamPartitionNumber int, @ParamFragmentationLevel float OUTPUT, @ParamPageCount bigint OUTPUT'''', @ParamDatabaseName = @CurrentDatabaseName, @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamFragmentationLevel = @CurrentFragmentationLevel OUTPUT, @ParamPageCount = @CurrentPageCount OUTPUT
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = ''''Msg '''' + CAST(ERROR_NUMBER() AS nvarchar) + '''', '''' + ISNULL(ERROR_MESSAGE(),'''''''') + CASE WHEN ERROR_NUMBER() = 1222 THEN '''' The index '''' + QUOTENAME(@CurrentIndexName) + '''' on the object '''' + QUOTENAME(@CurrentDatabaseName) + ''''.'''' + QUOTENAME(@CurrentSchemaName) + ''''.'''' + QUOTENAME(@CurrentObjectName) + '''' is locked. The page_count and avg_fragmentation_in_percent could not be checked.'''' ELSE '''''''' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR(''''%s'''',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Select fragmentation group
        IF @CurrentIndexID IS NOT NULL AND @CurrentOnReadOnlyFileGroup = 0 AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentFragmentationGroup = CASE
          WHEN @CurrentFragmentationLevel >= @FragmentationLevel2 THEN ''''High''''
          WHEN @CurrentFragmentationLevel >= @FragmentationLevel1 AND @CurrentFragmentationLevel < @FragmentationLevel2 THEN ''''Medium''''
          WHEN @CurrentFragmentationLevel < @FragmentationLevel1 THEN ''''Low''''
          END
        END

        -- Which actions are allowed?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          IF NOT (@CurrentOnReadOnlyFileGroup = 1)
          AND NOT (@CurrentIsMemoryOptimized = 1)
          AND NOT (@CurrentAllowPageLocks = 0)
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES (''''INDEX_REORGANIZE'''')
          END
          IF NOT (@CurrentOnReadOnlyFileGroup = 1)
          AND NOT (@CurrentIsMemoryOptimized = 1)
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES (''''INDEX_REBUILD_OFFLINE'''')
          END
          IF SERVERPROPERTY(''''EngineEdition'''') IN (3, 5, 8)
          AND NOT (@CurrentOnReadOnlyFileGroup = 1)
          AND NOT (@CurrentIsMemoryOptimized = 1)
          AND NOT (@CurrentIsPartition = 1 AND @Version < 12)
          AND NOT (@CurrentIndexType = 1 AND @CurrentIsImageText = 1)
          AND NOT (@CurrentIndexType = 1 AND @CurrentIsFileStream = 1)
          AND NOT (@CurrentIndexType = 1 AND @CurrentIsNewLOB = 1 AND @Version < 11)
          AND NOT (@CurrentIndexType = 2 AND @CurrentIsNewLOB = 1 AND @Version < 11)
          AND NOT (@CurrentIndexType = 3)
          AND NOT (@CurrentIndexType = 4)
          AND NOT (@CurrentIndexType = 5 AND @Version < 15)
          AND NOT (@CurrentIndexType = 6 AND @Version < 14)
          AND NOT (@CurrentIndexType = 1 AND @CurrentHasColumnstore = 1 AND @Version < 13)
          AND NOT (@CurrentIndexType = 2 AND @CurrentHasColumnstore = 1 AND @Version < 15)
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES (''''INDEX_REBUILD_ONLINE'''')
          END
        END

        -- Decide action
        IF @CurrentIndexID IS NOT NULL
        AND EXISTS(SELECT * FROM @ActionsPreferred)
        AND (@CurrentPageCount >= @MinNumberOfPages OR @MinNumberOfPages = 0)
        AND (@CurrentPageCount <= @MaxNumberOfPages OR @MaxNumberOfPages IS NULL)
        AND @CurrentResumableIndexOperation = 0
        BEGIN
          IF EXISTS(SELECT [Priority], [Action], COUNT(*) FROM @ActionsPreferred GROUP BY [Priority], [Action] HAVING COUNT(*) <> 3)
          BEGIN
            SELECT @CurrentAction = [Action]
            FROM @ActionsPreferred
            WHERE FragmentationGroup = @CurrentFragmentationGroup
            AND [Priority] = (SELECT MIN([Priority])
                              FROM @ActionsPreferred
                              WHERE FragmentationGroup = @CurrentFragmentationGroup
                              AND [Action] IN (SELECT [Action] FROM @CurrentActionsAllowed))
          END
          ELSE
          BEGIN
            SELECT @CurrentAction = [Action]
            FROM @ActionsPreferred
            WHERE [Priority] = (SELECT MIN([Priority])
                                FROM @ActionsPreferred
                                WHERE [Action] IN (SELECT [Action] FROM @CurrentActionsAllowed))
          END
        END

        IF @CurrentResumableIndexOperation = 1
        BEGIN
          SET @CurrentAction = ''''INDEX_REBUILD_ONLINE''''
        END

        -- Workaround for limitation in SQL Server, http://support.microsoft.com/kb/2292737
        IF @CurrentIndexID IS NOT NULL
        BEGIN
          SET @CurrentMaxDOP = @MaxDOP

          IF @CurrentAction = ''''INDEX_REBUILD_ONLINE'''' AND @CurrentAllowPageLocks = 0
          BEGIN
            SET @CurrentMaxDOP = 1
          END
        END

        -- Update statistics?
        IF @CurrentStatisticsID IS NOT NULL
        AND ((@UpdateStatistics = ''''ALL'''' AND (@CurrentIndexType IN (1,2,3,4,7) OR @CurrentIndexID IS NULL)) OR (@UpdateStatistics = ''''INDEX'''' AND @CurrentIndexID IS NOT NULL AND @CurrentIndexType IN (1,2,3,4,7)) OR (@UpdateStatistics = ''''COLUMNS'''' AND @CurrentIndexID IS NULL))
        AND ((@OnlyModifiedStatistics = ''''N'''' AND @StatisticsModificationLevel IS NULL) OR (@OnlyModifiedStatistics = ''''Y'''' AND @CurrentModificationCounter > 0) OR ((@CurrentModificationCounter * 1. / NULLIF(@CurrentRowCount,0)) * 100 >= @StatisticsModificationLevel) OR (@StatisticsModificationLevel IS NOT NULL AND @CurrentModificationCounter > 0 AND (@CurrentModificationCounter >= SQRT(@CurrentRowCount * 1000))) OR (@CurrentIsMemoryOptimized = 1 AND NOT (@Version >= 13 OR SERVERPROPERTY(''''EngineEdition'''') IN (5,8))))
        AND ((@CurrentIsPartition = 0 AND (@CurrentAction NOT IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') OR @CurrentAction IS NULL)) OR (@CurrentIsPartition = 1 AND (@CurrentPartitionNumber = @CurrentPartitionCount OR (@PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1))))
        BEGIN
          SET @CurrentUpdateStatistics = ''''Y''''
        END
        ELSE
        BEGIN
          SET @CurrentUpdateStatistics = ''''N''''
        END

        SET @CurrentStatisticsSample = @StatisticsSample
        SET @CurrentStatisticsResample = @StatisticsResample

        -- Memory-optimized tables only supports FULLSCAN and RESAMPLE in SQL Server 2014
        IF @CurrentIsMemoryOptimized = 1 AND NOT (@Version >= 13 OR SERVERPROPERTY(''''EngineEdition'''') IN (5,8)) AND (@CurrentStatisticsSample <> 100 OR @CurrentStatisticsSample IS NULL)
        BEGIN
          SET @CurrentStatisticsSample = NULL
          SET @CurrentStatisticsResample = ''''Y''''
        END

        -- Incremental statistics only supports RESAMPLE
        IF @PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1
        BEGIN
          SET @CurrentStatisticsSample = NULL
          SET @CurrentStatisticsResample = ''''Y''''
        END

        -- Create index comment
        IF @CurrentIndexID IS NOT NULL
        BEGIN
          SET @CurrentComment = ''''ObjectType: '''' + CASE WHEN @CurrentObjectType = ''''U'''' THEN ''''Table'''' WHEN @CurrentObjectType = ''''V'''' THEN ''''View'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''IndexType: '''' + CASE WHEN @CurrentIndexType = 1 THEN ''''Clustered'''' WHEN @CurrentIndexType = 2 THEN ''''NonClustered'''' WHEN @CurrentIndexType = 3 THEN ''''XML'''' WHEN @CurrentIndexType = 4 THEN ''''Spatial'''' WHEN @CurrentIndexType = 5 THEN ''''Clustered Columnstore'''' WHEN @CurrentIndexType = 6 THEN ''''NonClustered Columnstore'''' WHEN @CurrentIndexType = 7 THEN ''''NonClustered Hash'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''ImageText: '''' + CASE WHEN @CurrentIsImageText = 1 THEN ''''Yes'''' WHEN @CurrentIsImageText = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''NewLOB: '''' + CASE WHEN @CurrentIsNewLOB = 1 THEN ''''Yes'''' WHEN @CurrentIsNewLOB = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''FileStream: '''' + CASE WHEN @CurrentIsFileStream = 1 THEN ''''Yes'''' WHEN @CurrentIsFileStream = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          IF @Version >= 11 SET @CurrentComment += ''''HasColumnStore: '''' + CASE WHEN @CurrentHasColumnstore = 1 THEN ''''Yes'''' WHEN @CurrentHasColumnstore = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          IF @Version >= 14 AND @Resumable = ''''Y'''' SET @CurrentComment += ''''Computed: '''' + CASE WHEN @CurrentIsComputed = 1 THEN ''''Yes'''' WHEN @CurrentIsComputed = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          IF @Version >= 14 AND @Resumable = ''''Y'''' AND @CurrentIndexType = 2 SET @CurrentComment += ''''ClusteredIndexComputed: '''' + CASE WHEN @CurrentIsClusteredIndexComputed = 1 THEN ''''Yes'''' WHEN @CurrentIsClusteredIndexComputed = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          IF @Version >= 14 AND @Resumable = ''''Y'''' SET @CurrentComment += ''''Timestamp: '''' + CASE WHEN @CurrentIsTimestamp = 1 THEN ''''Yes'''' WHEN @CurrentIsTimestamp = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          IF @Version >= 14 AND @Resumable = ''''Y'''' SET @CurrentComment += ''''HasFilter: '''' + CASE WHEN @CurrentHasFilter = 1 THEN ''''Yes'''' WHEN @CurrentHasFilter = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''AllowPageLocks: '''' + CASE WHEN @CurrentAllowPageLocks = 1 THEN ''''Yes'''' WHEN @CurrentAllowPageLocks = 0 THEN ''''No'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''PageCount: '''' + ISNULL(CAST(@CurrentPageCount AS nvarchar),''''N/A'''') + '''', ''''
          SET @CurrentComment += ''''Fragmentation: '''' + ISNULL(CAST(@CurrentFragmentationLevel AS nvarchar),''''N/A'''')
        END

        IF @CurrentIndexID IS NOT NULL AND (@CurrentPageCount IS NOT NULL OR @CurrentFragmentationLevel IS NOT NULL)
        BEGIN
        SET @CurrentExtendedInfo = (SELECT *
                                    FROM (SELECT CAST(@CurrentPageCount AS nvarchar) AS [PageCount],
                                                 CAST(@CurrentFragmentationLevel AS nvarchar) AS Fragmentation
                                    ) ExtendedInfo FOR XML RAW(''''ExtendedInfo''''), ELEMENTS)
        END

        IF @CurrentIndexID IS NOT NULL AND @CurrentAction IS NOT NULL AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
        BEGIN
          SET @CurrentDatabaseContext = @CurrentDatabaseName

          SET @CurrentCommandType = ''''ALTER_INDEX''''

          SET @CurrentCommand = ''''''''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand = ''''SET LOCK_TIMEOUT '''' + CAST(@LockTimeout * 1000 AS nvarchar) + ''''; ''''
          SET @CurrentCommand += ''''ALTER INDEX '''' + QUOTENAME(@CurrentIndexName) + '''' ON '''' + QUOTENAME(@CurrentSchemaName) + ''''.'''' + QUOTENAME(@CurrentObjectName)
          IF @CurrentResumableIndexOperation = 1 SET @CurrentCommand += '''' RESUME''''
          IF @CurrentAction IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') AND @CurrentResumableIndexOperation = 0 SET @CurrentCommand += '''' REBUILD''''
          IF @CurrentAction IN(''''INDEX_REORGANIZE'''') AND @CurrentResumableIndexOperation = 0 SET @CurrentCommand += '''' REORGANIZE''''
          IF @CurrentIsPartition = 1 AND @CurrentResumableIndexOperation = 0 SET @CurrentCommand += '''' PARTITION = '''' + CAST(@CurrentPartitionNumber AS nvarchar)

          IF @CurrentAction IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') AND @SortInTempdb = ''''Y'''' AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''SORT_IN_TEMPDB = ON''''
          END

          IF @CurrentAction IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') AND @SortInTempdb = ''''N'''' AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''SORT_IN_TEMPDB = OFF''''
          END

          IF @CurrentAction = ''''INDEX_REBUILD_ONLINE'''' AND (@CurrentIsPartition = 0 OR @Version >= 12) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''ONLINE = ON'''' + CASE WHEN @WaitAtLowPriorityMaxDuration IS NOT NULL THEN '''' (WAIT_AT_LOW_PRIORITY (MAX_DURATION = '''' + CAST(@WaitAtLowPriorityMaxDuration AS nvarchar) + '''', ABORT_AFTER_WAIT = '''' + UPPER(@WaitAtLowPriorityAbortAfterWait) + ''''))'''' ELSE '''''''' END
          END

          IF @CurrentAction = ''''INDEX_REBUILD_OFFLINE'''' AND (@CurrentIsPartition = 0 OR @Version >= 12) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''ONLINE = OFF''''
          END

          IF @CurrentAction IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') AND @CurrentMaxDOP IS NOT NULL
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''MAXDOP = '''' + CAST(@CurrentMaxDOP AS nvarchar)
          END

          IF @CurrentAction IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') AND @FillFactor IS NOT NULL AND @CurrentIsPartition = 0 AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''FILLFACTOR = '''' + CAST(@FillFactor AS nvarchar)
          END

          IF @CurrentAction IN(''''INDEX_REBUILD_ONLINE'''',''''INDEX_REBUILD_OFFLINE'''') AND @PadIndex = ''''Y'''' AND @CurrentIsPartition = 0 AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''PAD_INDEX = ON''''
          END

          IF (@Version >= 14 OR SERVERPROPERTY(''''EngineEdition'''') IN (5,8)) AND @CurrentAction = ''''INDEX_REBUILD_ONLINE'''' AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT CASE WHEN @Resumable = ''''Y'''' AND @CurrentIndexType IN(1,2) AND @CurrentIsComputed = 0 AND @CurrentIsClusteredIndexComputed = 0 AND @CurrentIsTimestamp = 0 AND @CurrentHasFilter = 0 THEN ''''RESUMABLE = ON'''' ELSE ''''RESUMABLE = OFF'''' END
          END

          IF (@Version >= 14 OR SERVERPROPERTY(''''EngineEdition'''') IN (5,8)) AND @CurrentAction = ''''INDEX_REBUILD_ONLINE'''' AND @Resumable = ''''Y''''  AND @CurrentIndexType IN(1,2) AND @CurrentIsComputed = 0 AND @CurrentIsClusteredIndexComputed = 0 AND @CurrentIsTimestamp = 0 AND @CurrentHasFilter = 0 AND @TimeLimit IS NOT NULL
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''MAX_DURATION = '''' + CAST(DATEDIFF(MINUTE,SYSDATETIME(),DATEADD(SECOND,@TimeLimit,@StartTime)) AS nvarchar(max))
          END

          IF @CurrentAction IN(''''INDEX_REORGANIZE'''') AND @LOBCompaction = ''''Y''''
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''LOB_COMPACTION = ON''''
          END

          IF @CurrentAction IN(''''INDEX_REORGANIZE'''') AND @LOBCompaction = ''''N''''
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT ''''LOB_COMPACTION = OFF''''
          END

          IF EXISTS (SELECT * FROM @CurrentAlterIndexWithClauseArguments)
          BEGIN
            SET @CurrentAlterIndexWithClause = '''' WITH (''''

            WHILE (1 = 1)
            BEGIN
              SELECT TOP 1 @CurrentAlterIndexArgumentID = ID,
                           @CurrentAlterIndexArgument = Argument
              FROM @CurrentAlterIndexWithClauseArguments
              WHERE Added = 0
              ORDER BY ID ASC

              IF @@ROWCOUNT = 0
              BEGIN
                BREAK
              END

              SET @CurrentAlterIndexWithClause += @CurrentAlterIndexArgument + '''', ''''

              UPDATE @CurrentAlterIndexWithClauseArguments
              SET Added = 1
              WHERE [ID] = @CurrentAlterIndexArgumentID
            END

            SET @CurrentAlterIndexWithClause = RTRIM(@CurrentAlterIndexWithClause)

            SET @CurrentAlterIndexWithClause = LEFT(@CurrentAlterIndexWithClause,LEN(@CurrentAlterIndexWithClause) - 1)

            SET @CurrentAlterIndexWithClause = @CurrentAlterIndexWithClause + '''')''''
          END

          IF @CurrentAlterIndexWithClause IS NOT NULL SET @CurrentCommand += @CurrentAlterIndexWithClause

          EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseName, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 2, @Comment = @CurrentComment, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @IndexName = @CurrentIndexName, @IndexType = @CurrentIndexType, @PartitionNumber = @CurrentPartitionNumber, @ExtendedInfo = @CurrentExtendedInfo, @LockMessageSeverity = @LockMessageSeverity, @ExecuteAsUser = @ExecuteAsUser, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error <> 0 SET @CurrentCommandOutput = @Error
          IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput

          IF @Delay > 0
          BEGIN
            SET @CurrentDelay = DATEADD(ss,@Delay,''''1900-01-01'''')
            WAITFOR DELAY @CurrentDelay
          END
        END

        SET @CurrentMaxDOP = @MaxDOP

        -- Create statistics comment
        IF @CurrentStatisticsID IS NOT NULL
        BEGIN
          SET @CurrentComment = ''''ObjectType: '''' + CASE WHEN @CurrentObjectType = ''''U'''' THEN ''''Table'''' WHEN @CurrentObjectType = ''''V'''' THEN ''''View'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''IndexType: '''' + CASE WHEN @CurrentIndexID IS NOT NULL THEN ''''Index'''' ELSE ''''Column'''' END + '''', ''''
          IF @CurrentIndexID IS NOT NULL SET @CurrentComment += ''''IndexType: '''' + CASE WHEN @CurrentIndexType = 1 THEN ''''Clustered'''' WHEN @CurrentIndexType = 2 THEN ''''NonClustered'''' WHEN @CurrentIndexType = 3 THEN ''''XML'''' WHEN @CurrentIndexType = 4 THEN ''''Spatial'''' WHEN @CurrentIndexType = 5 THEN ''''Clustered Columnstore'''' WHEN @CurrentIndexType = 6 THEN ''''NonClustered Columnstore'''' WHEN @CurrentIndexType = 7 THEN ''''NonClustered Hash'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''Incremental: '''' + CASE WHEN @CurrentIsIncremental = 1 THEN ''''Y'''' WHEN @CurrentIsIncremental = 0 THEN ''''N'''' ELSE ''''N/A'''' END + '''', ''''
          SET @CurrentComment += ''''RowCount: '''' + ISNULL(CAST(@CurrentRowCount AS nvarchar),''''N/A'''') + '''', ''''
          SET @CurrentComment += ''''ModificationCounter: '''' + ISNULL(CAST(@CurrentModificationCounter AS nvarchar),''''N/A'''')
        END

        IF @CurrentStatisticsID IS NOT NULL AND (@CurrentRowCount IS NOT NULL OR @CurrentModificationCounter IS NOT NULL)
        BEGIN
        SET @CurrentExtendedInfo = (SELECT *
                                    FROM (SELECT CAST(@CurrentRowCount AS nvarchar) AS [RowCount],
                                                 CAST(@CurrentModificationCounter AS nvarchar) AS ModificationCounter
                                    ) ExtendedInfo FOR XML RAW(''''ExtendedInfo''''), ELEMENTS)
        END

        IF @CurrentStatisticsID IS NOT NULL AND @CurrentUpdateStatistics = ''''Y'''' AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
        BEGIN
          SET @CurrentDatabaseContext = @CurrentDatabaseName

          SET @CurrentCommandType = ''''UPDATE_STATISTICS''''

          SET @CurrentCommand = ''''''''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand = ''''SET LOCK_TIMEOUT '''' + CAST(@LockTimeout * 1000 AS nvarchar) + ''''; ''''
          SET @CurrentCommand += ''''UPDATE STATISTICS '''' + QUOTENAME(@CurrentSchemaName) + ''''.'''' + QUOTENAME(@CurrentObjectName) + '''' '''' + QUOTENAME(@CurrentStatisticsName)

          IF @CurrentMaxDOP IS NOT NULL AND ((@Version >= 12.06024 AND @Version < 13) OR (@Version >= 13.05026 AND @Version < 14) OR @Version >= 14.030154)
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT ''''MAXDOP = '''' + CAST(@CurrentMaxDOP AS nvarchar)
          END

          IF @CurrentStatisticsSample = 100
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT ''''FULLSCAN''''
          END

          IF @CurrentStatisticsSample IS NOT NULL AND @CurrentStatisticsSample <> 100
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT ''''SAMPLE '''' + CAST(@CurrentStatisticsSample AS nvarchar) + '''' PERCENT''''
          END

          IF @CurrentNoRecompute = 1
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT ''''NORECOMPUTE''''
          END

          IF @CurrentStatisticsResample = ''''Y''''
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT ''''RESAMPLE''''
          END

          IF EXISTS (SELECT * FROM @CurrentUpdateStatisticsWithClauseArguments)
          BEGIN
            SET @CurrentUpdateStatisticsWithClause = '''' WITH''''

            WHILE (1 = 1)
            BEGIN
              SELECT TOP 1 @CurrentUpdateStatisticsArgumentID = ID,
                           @CurrentUpdateStatisticsArgument = Argument
              FROM @CurrentUpdateStatisticsWithClauseArguments
              WHERE Added = 0
              ORDER BY ID ASC

              IF @@ROWCOUNT = 0
              BEGIN
                BREAK
              END

              SET @CurrentUpdateStatisticsWithClause = @CurrentUpdateStatisticsWithClause + '''' '''' + @CurrentUpdateStatisticsArgument + '''',''''

              UPDATE @CurrentUpdateStatisticsWithClauseArguments
              SET Added = 1
              WHERE [ID] = @CurrentUpdateStatisticsArgumentID
            END

            SET @CurrentUpdateStatisticsWithClause = LEFT(@CurrentUpdateStatisticsWithClause,LEN(@CurrentUpdateStatisticsWithClause) - 1)
          END

          IF @CurrentUpdateStatisticsWithClause IS NOT NULL SET @CurrentCommand += @CurrentUpdateStatisticsWithClause

          IF @PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1 AND @CurrentPartitionNumber IS NOT NULL SET @CurrentCommand += '''' ON PARTITIONS('''' + CAST(@CurrentPartitionNumber AS nvarchar(max)) + '''')''''

          EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseName, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 2, @Comment = @CurrentComment, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @IndexName = @CurrentIndexName, @IndexType = @CurrentIndexType, @StatisticsName = @CurrentStatisticsName, @ExtendedInfo = @CurrentExtendedInfo, @LockMessageSeverity = @LockMessageSeverity, @ExecuteAsUser = @ExecuteAsUser, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error <> 0 SET @CurrentCommandOutput = @Error
          IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput
        END

        NoAction:

        -- Update that the index or statistics is completed
        UPDATE @tmpIndexesStatistics
        SET Completed = 1
        WHERE Selected = 1
        AND Completed = 0
        AND [Order] = @CurrentIxOrder
        AND ID = @CurrentIxID

        -- Clear variables
        SET @CurrentDatabaseContext = NULL

        SET @CurrentCommand = NULL
        SET @CurrentCommandOutput = NULL
        SET @CurrentCommandType = NULL
        SET @CurrentComment = NULL
        SET @CurrentExtendedInfo = NULL

        SET @CurrentIxID = NULL
        SET @CurrentIxOrder = NULL
        SET @CurrentSchemaID = NULL
        SET @CurrentSchemaName = NULL
        SET @CurrentObjectID = NULL
        SET @CurrentObjectName = NULL
        SET @CurrentObjectType = NULL
        SET @CurrentIsMemoryOptimized = NULL
        SET @CurrentIndexID = NULL
        SET @CurrentIndexName = NULL
        SET @CurrentIndexType = NULL
        SET @CurrentStatisticsID = NULL
        SET @CurrentStatisticsName = NULL
        SET @CurrentPartitionID = NULL
        SET @CurrentPartitionNumber = NULL
        SET @CurrentPartitionCount = NULL
        SET @CurrentIsPartition = NULL
        SET @CurrentIndexExists = NULL
        SET @CurrentStatisticsExists = NULL
        SET @CurrentIsImageText = NULL
        SET @CurrentIsNewLOB = NULL
        SET @CurrentIsFileStream = NULL
        SET @CurrentHasColumnstore = NULL
        SET @CurrentIsComputed = NULL
        SET @CurrentIsClusteredIndexComputed = NULL
        SET @CurrentIsTimestamp = NULL
        SET @CurrentAllowPageLocks = NULL
        SET @CurrentHasFilter = NULL
        SET @CurrentNoRecompute = NULL
        SET @CurrentIsIncremental = NULL
        SET @CurrentRowCount = NULL
        SET @CurrentModificationCounter = NULL
        SET @CurrentOnReadOnlyFileGroup = NULL
        SET @CurrentResumableIndexOperation = NULL
        SET @CurrentFragmentationLevel = NULL
        SET @CurrentPageCount = NULL
        SET @CurrentFragmentationGroup = NULL
        SET @CurrentAction = NULL
        SET @CurrentMaxDOP = NULL
        SET @CurrentUpdateStatistics = NULL
        SET @CurrentStatisticsSample = NULL
        SET @CurrentStatisticsResample = NULL
        SET @CurrentAlterIndexArgumentID = NULL
        SET @CurrentAlterIndexArgument = NULL
        SET @CurrentAlterIndexWithClause = NULL
        SET @CurrentUpdateStatisticsArgumentID = NULL
        SET @CurrentUpdateStatisticsArgument = NULL
        SET @CurrentUpdateStatisticsWithClause = NULL

        DELETE FROM @CurrentActionsAllowed
        DELETE FROM @CurrentAlterIndexWithClauseArguments
        DELETE FROM @CurrentUpdateStatisticsWithClauseArguments

      END

    END

    IF @CurrentDatabaseState = ''''SUSPECT''''
    BEGIN
      SET @ErrorMessage = ''''The database '''' + QUOTENAME(@CurrentDatabaseName) + '''' is in a SUSPECT state.''''
      RAISERROR(''''%s'''',16,1,@ErrorMessage) WITH NOWAIT
      RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      SET @Error = @@ERROR
    END

    -- Update that the database is completed
    IF @DatabasesInParallel = ''''Y''''
    BEGIN
      UPDATE dbo.QueueDatabase
      SET DatabaseEndTime = SYSDATETIME()
      WHERE QueueID = @QueueID
      AND DatabaseName = @CurrentDatabaseName
    END
    ELSE
    BEGIN
      UPDATE @tmpDatabases
      SET Completed = 1
      WHERE Selected = 1
      AND Completed = 0
      AND ID = @CurrentDBID
    END

    -- Clear variables
    SET @CurrentDBID = NULL
    SET @CurrentDatabaseName = NULL

    SET @CurrentDatabase_sp_executesql = NULL

    SET @CurrentExecuteAsUserExists = NULL
    SET @CurrentUserAccess = NULL
    SET @CurrentIsReadOnly = NULL
    SET @CurrentDatabaseState = NULL
    SET @CurrentInStandby = NULL
    SET @CurrentRecoveryModel = NULL

    SET @CurrentReplicaID = NULL
    SET @CurrentAvailabilityGroupID = NULL
    SET @CurrentAvailabilityGroup = NULL
    SET @CurrentAvailabilityGroupRole = NULL
    SET @CurrentDatabaseMirroringRole = NULL

    SET @CurrentCommand = NULL

    DELETE FROM @tmpIndexesStatistics

  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  Logging:
  SET @EndMessage = ''''Date and time: '''' + CONVERT(nvarchar,SYSDATETIME(),120)
  RAISERROR(''''%s'''',10,1,@EndMessage) WITH NOWAIT

  RAISERROR(@EmptyLine,10,1) WITH NOWAIT

  IF @ReturnCode <> 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
'';
EXEC(@stmt);
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:IndexOptimize-004.sql modified: 2025.08.05 19.10.33
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableIndexRebuild bit;
	DECLARE @enableIndexReorganize bit;
	DECLARE @enableUpdateAllStatistics bit;
	DECLARE @enableUpdateModifiedStatistics bit;

	SET @enableIndexRebuild = 0;
	SET @enableIndexReorganize = 0;
	SET @enableUpdateAllStatistics = 0;
	SET @enableUpdateModifiedStatistics = 0;
END;

--
-- Specify where the Ola Hallengren objects are installed
--
BEGIN
	DECLARE @olaDatabase nvarchar(128);

	SET @olaDatabase = NULL;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexOptimize-004'', 0, 1) WITH NOWAIT;
END;

--
-- Do not change anything below here
--

--
-- Declare variables
--
BEGIN
	DECLARE @configuredOlaDatabase nvarchar(128);
	DECLARE @edition nvarchar(128);
	DECLARE @msg nvarchar(max);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Initialize @returnValue to true value
--
SET @returnValue = 1;

--
-- Test if we are in a database with FHSM registered
--
IF (@returnValue <> 0)
BEGIN
	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;

	IF (@returnValue = 0)
	BEGIN
		RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
	END
END;

--
-- If @olaDatabase is NULL try and lookup a previously configured value
-- If @olaDatabase is the same as the current database, set it to NULL
--
IF (@returnValue <> 0)
BEGIN
	IF (@olaDatabase IS NULL)
	BEGIN
		SET @configuredOlaDatabase = (
			SELECT dsre.referenced_database_name
			FROM sys.dm_sql_referenced_entities(''FHSM.Database'', ''OBJECT'') AS dsre
			WHERE (1 = 1)
				AND (dsre.referenced_minor_id = 0)
				AND (dsre.referenced_schema_name = ''dbo'')
				AND (dsre.referenced_entity_name = ''CommandLog'')
		);

		IF (@configuredOlaDatabase IS NOT NULL)
		BEGIN
			SET @msg = ''Installing IndexOptimize-004 using the already configured database '' + QUOTENAME(@configuredOlaDatabase) + '' as the Ola Hallengren database'';
			RAISERROR(@msg, 0, 1) WITH NOWAIT;

			SET @olaDatabase = @configuredOlaDatabase;
		END;
	END
	ELSE IF (@olaDatabase = DB_NAME())
	BEGIN
		SET @olaDatabase = NULL;
	END;
END;

--
-- Test if the Ola Hallengren table CommandLog exists
--
IF (@returnValue <> 0)
BEGIN
	SET @stmt = ''
		USE '' + QUOTENAME(COALESCE(@olaDatabase, DB_NAME())) + ''
		SET @returnValue = OBJECT_ID(''''dbo.CommandLog'''');
		SET @returnValue = COALESCE(@returnValue, 0);
	'';
	EXEC sp_executesql
		@stmt
		,N''@returnValue int OUTPUT''
		,@returnValue = @returnValue OUTPUT;

	IF (@returnValue = 0)
	BEGIN
		RAISERROR(''Can not install as the Ola Hallengren table dbo.CommandLog does not exist'', 0, 1) WITH NOWAIT;
	END;
END;

IF (@returnValue <> 0)
BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create indexes and register properties, even if using an Ola Hallengren installation in another database
	--
	BEGIN
		--
		-- Create index on dbo.CommandLog
		--
		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.CommandLog'')) AND (i.name = ''NC_CommandLog_StartTime''))
		BEGIN
			RAISERROR(''Adding index [NC_CommandLog_StartTime] to table dbo.CommandLog'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_CommandLog_StartTime ON dbo.CommandLog(StartTime ASC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Create index on dbo.CommandLog
		--
		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.CommandLog'')) AND (i.name = ''NC_CommandLog_DatabaseName_SchemaName_ObjectName_IndexName''))
		BEGIN
			RAISERROR(''Adding index [NC_CommandLog_DatabaseName_SchemaName_ObjectName_IndexName] to table dbo.CommandLog'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_CommandLog_DatabaseName_SchemaName_ObjectName_IndexName ON dbo.CommandLog(DatabaseName, SchemaName, ObjectName, IndexName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.CommandLog (Ola Hallengren)
		--
		BEGIN
			SET @objectName = ''dbo.CommandLog'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Index optimize]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index optimize'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index optimize'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index optimize'') + ''
				AS
				SELECT
					CASE
						WHEN (cl.CommandType = ''''ALTER_INDEX'''') AND (cl.Command LIKE ''''% REBUILD %'''') THEN 1
						WHEN (cl.CommandType = ''''ALTER_INDEX'''') AND (cl.Command LIKE ''''% REORGANIZE %'''') THEN 2
						WHEN (cl.CommandType = ''''UPDATE_STATISTICS'''') THEN 3
						WHEN (cl.CommandType = ''''BACKUP_DATABASE'''') THEN 4
						WHEN (cl.CommandType = ''''BACKUP_LOG'''') THEN 5
						WHEN (cl.CommandType = ''''RESTORE_VERIFYONLY'''') THEN 6
						WHEN (cl.CommandType = ''''DBCC_CHECKDB'''') THEN 7
						WHEN (cl.CommandType = ''''xp_create_subdir'''') THEN 8
						WHEN (cl.CommandType = ''''xp_delete_file'''') THEN 9
					END Type
					,COALESCE(NULLIF(DATEDIFF(SECOND, cl.StartTime, cl.EndTime), 0), 1) AS Duration		-- Duration of 0 sec. will always be 1 sec.
					,CAST(cl.StartTime AS date) AS Date
					,(DATEPART(HOUR, cl.StartTime) * 60 * 60) + (DATEPART(MINUTE, cl.StartTime) * 60) + (DATEPART(SECOND, cl.StartTime)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, cl.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, cl.SchemaName, cl.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, cl.SchemaName, cl.ObjectName, COALESCE(cl.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
				FROM '' + COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog AS cl;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Index optimize]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index optimize'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[OH errors]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''OH errors'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''OH errors'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''OH errors'') + ''
				AS
				SELECT
					CASE
						WHEN (cl.CommandType = ''''ALTER_INDEX'''') AND (cl.Command LIKE ''''% REBUILD %'''') THEN 1
						WHEN (cl.CommandType = ''''ALTER_INDEX'''') AND (cl.Command LIKE ''''% REORGANIZE %'''') THEN 2
						WHEN (cl.CommandType = ''''UPDATE_STATISTICS'''') THEN 3
						WHEN (cl.CommandType = ''''BACKUP_DATABASE'''') THEN 4
						WHEN (cl.CommandType = ''''BACKUP_LOG'''') THEN 5
						WHEN (cl.CommandType = ''''RESTORE_VERIFYONLY'''') THEN 6
						WHEN (cl.CommandType = ''''DBCC_CHECKDB'''') THEN 7
						WHEN (cl.CommandType = ''''xp_create_subdir'''') THEN 8
						WHEN (cl.CommandType = ''''xp_delete_file'''') THEN 9
					END Type
					,cl.StartTime
					,cl.EndTime
					,COALESCE(NULLIF(DATEDIFF(SECOND, cl.StartTime, cl.EndTime), 0), 1) AS Duration		-- Duration of 0 sec. will always be 1 sec.
					,cl.Command
					,cl.ErrorNumber
					,cl.ErrorMessage
					,CAST(cl.StartTime AS date) AS Date
					,(DATEPART(HOUR, cl.StartTime) * 60 * 60) + (DATEPART(MINUTE, cl.StartTime) * 60) + (DATEPART(SECOND, cl.StartTime)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, cl.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, cl.SchemaName, cl.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(cl.DatabaseName, cl.SchemaName, cl.ObjectName, COALESCE(cl.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
				FROM '' + COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog AS cl
				WHERE (cl.ErrorNumber <> 0) OR (cl.ErrorMessage IS NOT NULL);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[OH errors]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''OH errors'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures, but only if on FHSQLMonitor database
	--
	IF (DB_NAME() = COALESCE(@olaDatabase, DB_NAME()))
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPIndexOptimize
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPIndexOptimize'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPIndexOptimize AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPIndexOptimize (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Call Ola Hallengren
					--
					BEGIN
						SET @stmt = ''''EXEC dbo.IndexOptimize '''' + @parameter;
						EXEC(@stmt);
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPIndexOptimize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPIndexOptimize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlIndexOptimize
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlIndexOptimize'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlIndexOptimize AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlIndexOptimize (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlIndexOptimize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlIndexOptimize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention, but only if on FHSQLMonitor database
	--
	IF (DB_NAME() = COALESCE(@olaDatabase, DB_NAME()))
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.CommandLog''
				,1
				,''StartTime''
				,0
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules, but only if on FHSQLMonitor database
	--
	IF (DB_NAME() = COALESCE(@olaDatabase, DB_NAME()))
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableIndexRebuild								AS Enabled
				,0												AS DeploymentStatus
				,''Index rebuild''								AS Name
				,PARSENAME(''dbo.fhsmSPIndexOptimize'', 1)		AS Task
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T02:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T04:00:00.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb'''', @TimeLimit = 1800, @FragmentationLow = NULL, @FragmentationMedium = NULL, @FragmentationHigh = ''''INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE'''', @FragmentationLevel2 = 30, @LogToTable = ''''Y''''''

			UNION ALL

			SELECT
				@enableIndexReorganize							AS Enabled
				,0												AS DeploymentStatus
				,''Index reorganize''								AS Name
				,PARSENAME(''dbo.fhsmSPIndexOptimize'', 1)		AS Task
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T02:00:00.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb'''', @TimeLimit = 1800, @FragmentationLow = NULL, @FragmentationMedium = ''''INDEX_REORGANIZE,INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE'''', @FragmentationHigh = NULL, @FragmentationLevel1 = 5, @LogToTable = ''''Y''''''

			UNION ALL

			SELECT
				@enableUpdateAllStatistics						AS Enabled
				,0												AS DeploymentStatus
				,''Update all statistics''						AS Name
				,PARSENAME(''dbo.fhsmSPIndexOptimize'', 1)		AS Task
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T04:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T06:00:00.0000'' AS datetime2(0))	AS ToTime
				,0, 0, 0, 0, 0, 0, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb'''', @TimeLimit = 1800, @FragmentationLow = NULL, @FragmentationMedium = NULL, @FragmentationHigh = NULL, @UpdateStatistics = ''''ALL'''', @LogToTable = ''''Y''''''

			UNION ALL

			SELECT
				@enableUpdateModifiedStatistics					AS Enabled
				,0												AS DeploymentStatus
				,''Update modified statistics''					AS Name
				,PARSENAME(''dbo.fhsmSPIndexOptimize'', 1)		AS Task
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T04:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T06:00:00.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 0							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb'''', @TimeLimit = 1800, @FragmentationLow = NULL, @FragmentationMedium = NULL, @FragmentationHigh = NULL, @UpdateStatistics = ''''ALL'''', @OnlyModifiedStatistics = ''''Y'''', @LogToTable = ''''Y''''''
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[StartTime]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[StartTime]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL
				,''Database'', ''Schema'', NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[StartTime]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL
				,''Database'', ''Schema'', ''Object'', NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[StartTime]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')''
				,''Database'', ''Schema'', ''Object'', ''Index''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (PARSENAME(src.SrcTable, 1) = PARSENAME(tgt.SrcTable, 1))
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		SET @stmt = COALESCE(QUOTENAME(@olaDatabase) + ''.'', '''') + ''dbo.CommandLog'';
		EXEC dbo.fhsmSPUpdateDimensions @table = @stmt;
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:DatabaseState.sql modified: 2025.08.05 19.09.57
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableDatabaseState bit;

	SET @enableDatabaseState = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing DatabaseState'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmAlwaysOnState and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAlwaysOnState'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAlwaysOnState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAlwaysOnState(
						Id int identity(1,1) NOT NULL
						,Query int NOT NULL
						,GroupA nvarchar(128) NOT NULL
						,GroupB nvarchar(128) NOT NULL
						,GroupC nvarchar(128) NOT NULL
						,[Key] nvarchar(128) NOT NULL
						,Value nvarchar(max) NOT NULL
						,ValidFrom datetime NOT NULL
						,ValidTo datetime NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmAlwaysOnState PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAlwaysOnState'')) AND (i.name = ''NC_fhsmAlwaysOnState_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAlwaysOnState_TimestampUTC] to table dbo.fhsmAlwaysOnState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAlwaysOnState_TimestampUTC ON dbo.fhsmAlwaysOnState(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAlwaysOnState'')) AND (i.name = ''NC_fhsmAlwaysOnState_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAlwaysOnState_Timestamp] to table dbo.fhsmAlwaysOnState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAlwaysOnState_Timestamp ON dbo.fhsmAlwaysOnState(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAlwaysOnState
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAlwaysOnState'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmDatabaseState and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmDatabaseState'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmDatabaseState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmDatabaseState(
						Id int identity(1,1) NOT NULL
						,Query int NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,[Key] nvarchar(128) NOT NULL
						,Value nvarchar(max) NOT NULL
						,ValidFrom datetime NOT NULL
						,ValidTo datetime NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmDatabaseState PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseState'')) AND (i.name = ''NC_fhsmDatabaseState_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseState_TimestampUTC] to table dbo.fhsmDatabaseState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseState_TimestampUTC ON dbo.fhsmDatabaseState(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseState'')) AND (i.name = ''NC_fhsmDatabaseState_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseState_Timestamp] to table dbo.fhsmDatabaseState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseState_Timestamp ON dbo.fhsmDatabaseState(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseState'')) AND (i.name = ''NC_fhsmDatabaseState_Query_DatabaseName_Key_ValidTo''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseState_Query_DatabaseName_Key_ValidTo] to table dbo.fhsmDatabaseState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseState_Query_DatabaseName_Key_ValidTo ON dbo.fhsmDatabaseState(Query, DatabaseName, [Key], ValidTo) INCLUDE(Value)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseState'')) AND (i.name = ''NC_fhsmDatabaseState_ValidTo_Query_DatabaseName_key''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseState_ValidTo_Query_DatabaseName_key] to table dbo.fhsmDatabaseState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseState_ValidTo_Query_DatabaseName_key ON dbo.fhsmDatabaseState(ValidTo, Query, DatabaseName, [Key]) INCLUDE(Value)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmDatabaseState
			--
			BEGIN
				SET @objectName = ''dbo.fhsmDatabaseState'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Always On database states
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On database states'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On database states'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On database states'') + ''
				AS
					SELECT
						pvt.GroupA														AS AGGroupName
						,pvt.GroupB														AS AGReplicaName
						,pvt.GroupC														AS AGDatabaseName
						,CASE pvt.is_local
							WHEN ''''0'''' THEN ''''No''''
							WHEN ''''1'''' THEN ''''Yes''''
						END																AS IsLocal
						,CASE pvt.is_primary_replica
							WHEN ''''0'''' THEN ''''No''''
							WHEN ''''1'''' THEN ''''Yes''''
						END																AS IsPrimaryReplica
						,dbo.fhsmFNConvertToDisplayTxt(pvt.synchronization_state_desc)	AS SynchronizationState
						,CASE pvt.is_commit_participant
							WHEN ''''0'''' THEN ''''No''''
							WHEN ''''1'''' THEN ''''Yes''''
						END																AS IsCommitParticipant
						,dbo.fhsmFNConvertToDisplayTxt(pvt.synchronization_health_desc)	AS SynchronizationHealth
						,dbo.fhsmFNConvertToDisplayTxt(pvt.database_state_desc)			AS DatabaseState
						,CASE pvt.is_suspended
							WHEN ''''0'''' THEN ''''No''''
							WHEN ''''1'''' THEN ''''Yes''''
						END																AS IsSuspended
						,dbo.fhsmFNConvertToDisplayTxt(pvt.suspend_reason_desc)			AS SuspendReason
						,(SELECT MIN(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.GroupC = pvt.GroupC) AND (aoState.Query = 6) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.GroupC = pvt.GroupC) AND (aoState.Query = 6) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, DEFAULT,    DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, pvt.GroupB, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupReplicaKey
					FROM (
						SELECT aoState.GroupA, aoState.GroupB, aoState.GroupC, aoState.[Key], aoState.Value AS _Value_
						FROM dbo.fhsmAlwaysOnState AS aoState
						WHERE (aoState.Query = 6) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[database_state_desc], [is_commit_participant], [is_local], [is_primary_replica],
							[is_suspended], [suspend_reason_desc], [synchronization_health_desc], [synchronization_state_desc]
						)
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Always On database states]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On database states'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Always On group states
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On group states'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On group states'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On group states'') + ''
				AS
					SELECT
						pvt.GroupA															AS AGGroupName
						,pvt.GroupB															AS AGReplicaName
						,dbo.fhsmFNConvertToDisplayTxt(pvt.primary_recovery_health_desc)	AS PrimaryRecoveryHealth
						,dbo.fhsmFNConvertToDisplayTxt(pvt.secondary_recovery_health_desc)	AS SecondaryRecoveryHealth
						,dbo.fhsmFNConvertToDisplayTxt(pvt.synchronization_health_desc)		AS SynchronizationHealth
						,(SELECT MIN(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.Query = 3) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.Query = 3) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, DEFAULT,    DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, pvt.GroupB, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupReplicaKey
					FROM (
						SELECT aoState.GroupA, aoState.GroupB, aoState.[Key], aoState.Value AS _Value_
						FROM dbo.fhsmAlwaysOnState AS aoState
						WHERE (aoState.Query = 3) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[primary_recovery_health_desc], [secondary_recovery_health_desc],
							[synchronization_health_desc]
						)
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Always On group states]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On group states'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Always On read only routing
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On read only routing'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On read only routing'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On read only routing'') + ''
				AS
					SELECT
						pvt.GroupA																	AS AGGroupName
						,pvt.GroupB																	AS AGSrcReplicaName
						,pvt.GroupC																	AS AGReplReplicaName
						,pvt.read_only_routing_url													AS ReadOnlyRoutingURL
						,CAST(pvt.routing_priority AS int)											AS RoutingPriority
						,dbo.fhsmFNConvertToDisplayTxt(pvt.secondary_role_allow_connections_desc)	AS SecondaryRoleAllowConnections
						,(SELECT MIN(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.GroupC = pvt.GroupC) AND (aoState.Query = 4) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.GroupC = pvt.GroupC) AND (aoState.Query = 4) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, DEFAULT,    DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, pvt.GroupB, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupReplicaKey
					FROM (
						SELECT aoState.GroupA, aoState.GroupB, aoState.GroupC, aoState.[Key], aoState.Value AS _Value_
						FROM dbo.fhsmAlwaysOnState AS aoState
						WHERE (aoState.Query = 4) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[read_only_routing_url], [routing_priority],
							[secondary_role_allow_connections_desc]
						)
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Always On read only routing]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On read only routing'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Always On replicas
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On replicas'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On replicas'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On replicas'') + ''
				AS
					SELECT
						pvt.GroupA																	AS AGGroupName
						,pvt.GroupB																	AS AGReplicaName
						,pvt.endpoint_url															AS EndpointURL
						,dbo.fhsmFNConvertToDisplayTxt(pvt.availability_mode_desc)					AS AvailabilityMode
						,dbo.fhsmFNConvertToDisplayTxt(pvt.failover_mode_desc)						AS FailoverMode
						,dbo.fhsmFNConvertToDisplayTxt(pvt.primary_role_allow_connections_desc)		AS PrimaryRoleAllowConnections
						,dbo.fhsmFNConvertToDisplayTxt(pvt.secondary_role_allow_connections_desc)	AS SecondaryRoleAllowConnections
						,CAST(pvt.backup_priority AS int)											AS BackupPriority
						,pvt.read_only_routing_url													AS ReadOnlyRoutingURL
						,pvt.read_write_routing_url													AS ReadWriteRoutingURL
						,(SELECT MIN(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.Query = 5) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.GroupB = pvt.GroupB) AND (aoState.Query = 5) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, DEFAULT,    DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.GroupA, pvt.GroupB, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AlwaysOnGroupReplicaKey
					FROM (
						SELECT aoState.GroupA, aoState.GroupB, aoState.[Key], aoState.Value AS _Value_
						FROM dbo.fhsmAlwaysOnState AS aoState
						WHERE (aoState.Query = 5) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[availability_mode_desc], [backup_priority], [endpoint_url], [failover_mode_desc],
							[primary_role_allow_connections_desc], [read_only_routing_url], [read_write_routing_url],
							[secondary_role_allow_connections_desc]
						)
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Always On replicas]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Always On replicas'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Database state]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state'') + ''
				AS
					SELECT
						pvt.DatabaseName
						,pvt.collation_name AS CollationName
						,CAST(pvt.compatibility_level AS int) AS CompatibilityLevel
						,CASE pvt.delayed_durability
							WHEN 0 THEN ''''DISABLED''''
							WHEN 1 THEN ''''ALLOWED''''
							WHEN 2 THEN ''''FORCED''''
							ELSE ''''?:'''' + pvt.delayed_durability
						END AS DelayedDurability
						,CAST(pvt.is_auto_close_on AS bit) AS IsAutoCloseOn
						,CAST(pvt.is_auto_shrink_on AS bit) AS IsAutoShrinkOn
						,CAST(pvt.is_auto_update_stats_async_on AS bit) AS IsAutoUpdateStatsAsyncOn
						,CAST(pvt.is_encrypted AS bit) AS IsEncrypted
						,CAST(pvt.is_mixed_page_allocation_on AS bit) AS IsMixedPageAllocationOn
						,CASE pvt.page_verify_option
							WHEN 0 THEN ''''NONE''''
							WHEN 1 THEN ''''TORN_PAGE_DETECTION''''
							WHEN 2 THEN ''''CHECKSUM''''
							ELSE ''''?:'''' + pvt.page_verify_option
						END AS PageVerifyOption
						,CAST(pvt.is_read_committed_snapshot_on AS bit) AS IsReadCommittedSnapshotOn
						,CASE pvt.recovery_model
							WHEN 1 THEN ''''FULL''''
							WHEN 2 THEN ''''BULK_LOGGED''''
							WHEN 3 THEN ''''SIMPLE''''
							ELSE ''''?:'''' + pvt.recovery_model
						END AS RecoveryModel
						,CAST(pvt.target_recovery_time_in_seconds AS int) AS TargetRecoveryTimeInSeconds
						,pvt.replica_id AS ReplicaId
						,pvt.AlwaysOnGroupName
						,CAST(pvt.IsOnAlwaysOnPrimary AS int) AS IsOnAlwaysOnPrimary
						,(SELECT MIN(dbState.Timestamp) FROM dbo.fhsmDatabaseState AS dbState WHERE (dbState.DatabaseName = pvt.DatabaseName) AND (dbState.Query = 31) AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(dbState.Timestamp) FROM dbo.fhsmDatabaseState AS dbState WHERE (dbState.DatabaseName = pvt.DatabaseName) AND (dbState.Query = 31) AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pvt.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					FROM (
						SELECT dbState.DatabaseName, dbState.[Key], dbState.Value AS _Value_
						FROM (
							SELECT DISTINCT dbState.DatabaseName
							FROM dbo.fhsmDatabaseState AS dbState
							WHERE
								(dbState.Query = 31)
								AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS toCheck
						INNER JOIN dbo.fhsmDatabaseState AS dbState ON (dbState.DatabaseName = toCheck.DatabaseName)
						WHERE (dbState.Query = 31) AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[collation_name], [compatibility_level], [delayed_durability]
							,[is_auto_close_on], [is_auto_shrink_on], [is_auto_update_stats_async_on], [is_encrypted], [is_mixed_page_allocation_on]
							,[is_read_committed_snapshot_on], [page_verify_option], [recovery_model], [target_recovery_time_in_seconds]
							,[replica_id], [AlwaysOnGroupName], [IsOnAlwaysOnPrimary])
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Database state]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Database state history]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state history'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state history'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state history'') + ''
				AS
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
				WITH databaseState AS (
					SELECT
						dbState.DatabaseName, dbState.[Key], dbState.Value, dbState.TimestampUTC, dbState.ValidFrom, dbState.ValidTo
						,ROW_NUMBER() OVER(PARTITION BY dbState.DatabaseName, dbState.[Key] ORDER BY dbState.ValidTo DESC) AS Idx
					FROM (
						SELECT DISTINCT dbState.DatabaseName
						FROM dbo.fhsmDatabaseState AS dbState
						WHERE
							(dbState.Query = 31)
							AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS toCheck
					INNER JOIN dbo.fhsmDatabaseState AS dbState ON (dbState.DatabaseName = toCheck.DatabaseName)
					WHERE (dbState.Query = 31)
						AND (dbState.[Key] IN (
							''''collation_name'''', ''''compatibility_level'''', ''''delayed_durability''''
							,''''is_auto_close_on'''', ''''is_auto_shrink_on'''', ''''is_auto_update_stats_async_on'''', ''''is_encrypted'''', ''''is_mixed_page_allocation_on''''
							,''''is_read_committed_snapshot_on'''', ''''page_verify_option'''', ''''recovery_model'''', ''''target_recovery_time_in_seconds''''
							,''''AlwaysOnGroupName'''', ''''IsOnAlwaysOnPrimary''''
						))
				)
				'';
			END;
			SET @stmt += ''
					SELECT
						''''Standard'''' AS Type
						,a.DatabaseName
						,CASE a.[Key]
							WHEN ''''collation_name'''' THEN ''''Collation''''
							WHEN ''''compatibility_level'''' THEN ''''Comp. level''''
							WHEN ''''delayed_durability'''' THEN ''''Delayed durability''''
							WHEN ''''is_auto_close_on'''' THEN ''''Auto close''''
							WHEN ''''is_auto_shrink_on'''' THEN ''''Auto shrink''''
							WHEN ''''is_auto_update_stats_async_on'''' THEN ''''Auto update stats. async.''''
							WHEN ''''is_encrypted'''' THEN ''''Encrypted''''
							WHEN ''''is_mixed_page_allocation_on'''' THEN ''''Mixed page allocation''''
							WHEN ''''is_read_committed_snapshot_on'''' THEN ''''Is read committed snapshot on''''
							WHEN ''''page_verify_option'''' THEN ''''Page verify''''
							WHEN ''''recovery_model'''' THEN ''''Recovery model''''
							WHEN ''''target_recovery_time_in_seconds'''' THEN ''''Target recovery time in sec.''''
							WHEN ''''AlwaysOnGroupName'''' THEN ''''AlwaysOn group''''
							WHEN ''''IsOnAlwaysOnPrimary'''' THEN ''''Is on AlwaysOn primary''''
							ELSE a.[Key]
						END AS [Key]
						,a.ValidFrom
						,NULLIF(a.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
						,CASE a.[Key]
							WHEN ''''delayed_durability''''
								THEN CASE a.Value
									WHEN 0 THEN ''''DISABLED''''
									WHEN 1 THEN ''''ALLOWED''''
									WHEN 2 THEN ''''FORCED''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''is_auto_close_on''''
								THEN CASE a.Value
									WHEN 0 THEN ''''False''''
									WHEN 1 THEN ''''True''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''is_auto_shrink_on''''
								THEN CASE a.Value
									WHEN 0 THEN ''''False''''
									WHEN 1 THEN ''''True''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''is_auto_update_stats_async_on''''
								THEN CASE a.Value
									WHEN 0 THEN ''''False''''
									WHEN 1 THEN ''''True''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''is_encrypted''''
								THEN CASE a.Value
									WHEN 0 THEN ''''False''''
									WHEN 1 THEN ''''True''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''is_mixed_page_allocation_on''''
								THEN CASE a.Value
									WHEN 0 THEN ''''False''''
									WHEN 1 THEN ''''True''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''page_verify_option''''
								THEN CASE a.Value
									WHEN 0 THEN ''''NONE''''
									WHEN 1 THEN ''''TORN_PAGE_DETECTION''''
									WHEN 2 THEN ''''CHECKSUM''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''is_read_committed_snapshot_on''''
								THEN CASE a.Value
									WHEN 0 THEN ''''False''''
									WHEN 1 THEN ''''True''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''recovery_model''''
								THEN CASE a.Value
									WHEN 1 THEN ''''FULL''''
									WHEN 2 THEN ''''BULK_LOGGED''''
									WHEN 3 THEN ''''SIMPLE''''
									ELSE ''''?:'''' + a.Value
								END
							WHEN ''''IsOnAlwaysOnPrimary''''
								THEN CASE a.Value
									WHEN 1 THEN ''''Yes''''
									WHEN 2 THEN ''''No''''
									WHEN 3 THEN ''''N.A.''''
									ELSE ''''?:'''' + a.Value
								END
							ELSE a.Value
						END AS Value
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					FROM (
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
						SELECT
							dbState.DatabaseName, dbState.[Key], dbState.Value, dbState.TimestampUTC, dbState.ValidFrom, dbState.ValidTo
							,prevDBState.Value AS PreviousValue
						FROM databaseState AS dbState
						LEFT OUTER JOIN databaseState AS prevDBState ON
							(prevDBState.DatabaseName = dbState.DatabaseName)
							AND (prevDBState.[Key] = dbState.[Key])
							AND (prevDBState.Idx = dbState.Idx - 1)
				'';
			END
			ELSE BEGIN
				-- SQL Versions SQL2012 or higher

				SET @stmt += ''
						SELECT
							dbState.DatabaseName, dbState.[Key], dbState.Value, dbState.TimestampUTC, dbState.ValidFrom, dbState.ValidTo
							,LAG(dbState.Value) OVER(PARTITION BY dbState.DatabaseName, dbState.[Key] ORDER BY dbState.ValidTo DESC) AS PreviousValue
						FROM (
							SELECT DISTINCT dbState.DatabaseName
							FROM dbo.fhsmDatabaseState AS dbState
							WHERE
								(dbState.Query = 31)
								AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS toCheck
						INNER JOIN dbo.fhsmDatabaseState AS dbState ON (dbState.DatabaseName = toCheck.DatabaseName)
						WHERE (dbState.Query = 31)
							AND (dbState.[Key] IN (
								''''collation_name'''', ''''compatibility_level'''', ''''delayed_durability''''
								,''''is_auto_close_on'''', ''''is_auto_shrink_on'''', ''''is_auto_update_stats_async_on'''', ''''is_encrypted'''', ''''is_mixed_page_allocation_on''''
								,''''is_read_committed_snapshot_on'''', ''''page_verify_option'''', ''''recovery_model'''', ''''target_recovery_time_in_seconds''''
								,''''AlwaysOnGroupName'''', ''''IsOnAlwaysOnPrimary''''
							))
				'';
			END;
			SET @stmt += ''
					) AS a
					WHERE ((a.Value <> a.PreviousValue) OR (a.PreviousValue IS NULL))
			'';
			IF (@productVersion1 >= 13)
			BEGIN
				-- SQL Versions SQL2016 or higher

				SET @stmt += ''
					UNION ALL

					SELECT
						''''Scoped'''' AS Type
						,a.DatabaseName
						,a.[Key]
						,a.ValidFrom
						,NULLIF(a.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
						,a.Value
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					FROM (
						SELECT
							dbState.DatabaseName, dbState.[Key], dbState.Value, dbState.TimestampUTC, dbState.ValidFrom, dbState.ValidTo
							,LAG(dbState.Value) OVER(PARTITION BY dbState.DatabaseName, dbState.[Key] ORDER BY dbState.ValidTo DESC) AS PreviousValue
						FROM (
							SELECT DISTINCT dbState.DatabaseName
							FROM dbo.fhsmDatabaseState AS dbState
							WHERE
								(dbState.Query = 60)
								AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS toCheck
						INNER JOIN dbo.fhsmDatabaseState AS dbState ON (dbState.DatabaseName = toCheck.DatabaseName)
						WHERE (dbState.Query = 60)
							AND EXISTS (
								SELECT *
								FROM dbo.fhsmDatabaseState AS dbDefault
								WHERE
									(dbDefault.Query = 2060)
									AND (dbDefault.DatabaseName = dbState.DatabaseName)
									AND (dbDefault.[Key] = dbState.[Key])
									AND (dbDefault.Value <> 1)
							)
					) AS a
					WHERE ((a.Value <> a.PreviousValue) OR (a.PreviousValue IS NULL))
				'';

				SET @stmt += ''
					UNION ALL

					SELECT
						''''Scoped secondary'''' AS Type
						,a.DatabaseName
						,a.[Key]
						,a.ValidFrom
						,NULLIF(a.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
						,a.Value
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					FROM (
						SELECT
							dbState.DatabaseName, dbState.[Key], dbState.Value, dbState.TimestampUTC, dbState.ValidFrom, dbState.ValidTo
							,LAG(dbState.Value) OVER(PARTITION BY dbState.DatabaseName, dbState.[Key] ORDER BY dbState.ValidTo DESC) AS PreviousValue
						FROM (
							SELECT DISTINCT dbState.DatabaseName
							FROM dbo.fhsmDatabaseState AS dbState
							WHERE
								(dbState.Query = 1060)
								AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS toCheck
						INNER JOIN dbo.fhsmDatabaseState AS dbState ON (dbState.DatabaseName = toCheck.DatabaseName)
						WHERE (dbState.Query = 1060)
							AND EXISTS (
								SELECT *
								FROM dbo.fhsmDatabaseState AS dbDefault
								WHERE
									(dbDefault.Query = 2060)
									AND (dbDefault.DatabaseName = dbState.DatabaseName)
									AND (dbDefault.[Key] = dbState.[Key])
									AND (dbDefault.Value <> 1)
							)
					) AS a
					WHERE ((a.Value <> a.PreviousValue) OR (a.PreviousValue IS NULL));
				'';
			END;
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Database state history]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database state history'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Database scoped configuration]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configuration'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configuration'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configuration'') + ''
				AS
					SELECT
						ds.[Key]
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.[Key], DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseScopedConfigurationKey
					FROM (
						SELECT DISTINCT ds.[Key]
						FROM dbo.fhsmDatabaseState AS ds
						WHERE
							(ds.Query IN (60, 1060, 2060))
					) AS ds;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Database scoped configuration]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configuration'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Database scoped configurations]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configurations'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configurations'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configurations'') + ''
				AS
					SELECT
						ds.DatabaseName
						,ds.[Key]
						,ds.Value
						,dsSecondary.Value AS ValueForSecondary
						,CAST(dsDefault.Value AS int) AS DefaultState
						,ROW_NUMBER() OVER(
							ORDER BY
								CASE
									WHEN (dsDefault.Value = 0) THEN 1
									ELSE 2
								END
								,ds.DatabaseName
								,ds.[Key]
						) AS ConfigurationSortOrder
						,ds.Timestamp
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.[Key],        DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseScopedConfigurationKey
					FROM (
						SELECT ds.DatabaseName, ds.[Key], ds.Value, ds.Timestamp
						FROM dbo.fhsmDatabaseState AS ds
						WHERE
							(ds.Query = 60)
							AND (ds.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS ds
					LEFT OUTER JOIN (
						SELECT ds.DatabaseName, ds.[Key], ds.Value
						FROM dbo.fhsmDatabaseState AS ds
						WHERE
							(ds.Query = 1060)
							AND (ds.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS dsSecondary ON (dsSecondary.DatabaseName = ds.DatabaseName) AND (dsSecondary.[Key] = ds.[Key])
					LEFT OUTER JOIN (
						SELECT ds.DatabaseName, ds.[Key], ds.Value
						FROM dbo.fhsmDatabaseState AS ds
						WHERE
							(ds.Query = 2060)
							AND (ds.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS dsDefault ON (dsDefault.DatabaseName = ds.DatabaseName) AND (dsDefault.[Key] = ds.[Key]);
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[Database scoped configurations]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database scoped configurations'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- WSFC quorum members
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum members'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum members'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum members'') + ''
				AS
					SELECT
						pvt.GroupA												AS WSFCQuorumMember
						,dbo.fhsmFNConvertToDisplayTxt(pvt.member_type_desc)	AS MemberType
						,dbo.fhsmFNConvertToDisplayTxt(pvt.member_state_desc)	AS MemberState
						,CAST(pvt.number_of_quorum_votes AS int)				AS NumberOfQuorumVotes
						,CAST(pvt.number_of_current_votes AS int)				AS NumberOfCurrentVotes
						,(SELECT MIN(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.Query = 2) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.GroupA = pvt.GroupA) AND (aoState.Query = 2) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
					FROM (
						SELECT aoState.GroupA, aoState.[Key], aoState.Value AS _Value_
						FROM dbo.fhsmAlwaysOnState AS aoState
						WHERE (aoState.Query = 2) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[member_state_desc], [member_type_desc],
							[number_of_current_votes], [number_of_quorum_votes]
						)
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[WSFC quorum members]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum members'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- WSFC quorum state
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum state'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum state'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum state'') + ''
				AS
					SELECT
						pvt.cluster_name										AS WSFCClusterName
						,dbo.fhsmFNConvertToDisplayTxt(pvt.quorum_type_desc)	AS QuorumType
						,dbo.fhsmFNConvertToDisplayTxt(pvt.quorum_state_desc)	AS QuorumState
						,(SELECT MIN(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.Query = 1) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MinTimestamp
						,(SELECT MAX(aoState.Timestamp) FROM dbo.fhsmAlwaysOnState AS aoState WHERE (aoState.Query = 1) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')) AS MaxTimestamp
					FROM (
						SELECT aoState.[Key], aoState.Value AS _Value_
						FROM dbo.fhsmAlwaysOnState AS aoState
						WHERE (aoState.Query = 1) AND (aoState.ValidTo = ''''9999-12-31 23:59:59.000'''')
					) AS p
					PIVOT (
						MAX(_Value_)
						FOR [Key] IN (
							[cluster_name], [quorum_state_desc], [quorum_type_desc])
					) AS pvt;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on fact view @pbiSchema.[WSFC quorum state]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''WSFC quorum state'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPAlwaysOnState
		--
		IF (@productVersion1 < 11)
		BEGIN
			-- SQL Versions SQL2008R2 or lower
			RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
			RAISERROR(''!!! Can not install Always On state on SQL versions lower than SQL2012'', 0, 1) WITH NOWAIT;
			RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
		END
		ELSE BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPAlwaysOnState'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPAlwaysOnState AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPAlwaysOnState (
						@name nvarchar(128),
						@parameter nvarchar(max)
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);
						DECLARE @version nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--
						-- Get the parameter for the command
						--
						BEGIN
							SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
						END;

						--
						-- Collect data
						--
						BEGIN
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							IF (OBJECT_ID(''''tempdb..#alwaysOn'''') IS NOT NULL) DROP TABLE #alwaysOn;

							CREATE TABLE #alwaysOn(
								Query int NOT NULL
								,GroupA nvarchar(128) NOT NULL
								,GroupB nvarchar(128) NOT NULL
								,GroupC nvarchar(128) NOT NULL
								,[Key] nvarchar(128) NOT NULL
								,Value nvarchar(max) NULL
								,PRIMARY KEY(Query, GroupA, GroupB, GroupC, [Key])
							);

							BEGIN
								--
								-- Test if read_write_routing_url exists on availability_replicas
								--
								BEGIN
									DECLARE @readWriteRoutingURLStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''availability_replicas'''') AND (sc.name = ''''read_write_routing_url'''')
									)
									BEGIN
										SET @readWriteRoutingURLStmt = ''''ar.read_write_routing_url COLLATE DATABASE_DEFAULT'''';
									END
									ELSE BEGIN
										SET @readWriteRoutingURLStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if number_of_current_votes exists on dm_hadr_cluster_members
								--
								BEGIN
									DECLARE @numberOfCurrentVotesStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''dm_hadr_cluster_members'''') AND (sc.name = ''''number_of_current_votes'''')
									)
									BEGIN
										SET @numberOfCurrentVotesStmt = ''''dhcm.number_of_current_votes'''';
									END
									ELSE BEGIN
										SET @numberOfCurrentVotesStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_primary_replica exists on dm_hadr_database_replica_states
								--
								BEGIN
									DECLARE @isPrimaryReplicaStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''dm_hadr_database_replica_states'''') AND (sc.name = ''''is_primary_replica'''')
									)
									BEGIN
										SET @isPrimaryReplicaStmt = ''''dhdrs.is_primary_replica'''';
									END
									ELSE BEGIN
										SET @isPrimaryReplicaStmt = ''''NULL'''';
									END;
								END;

								SET @stmt = '''''''';
				'';
				SET @stmt += ''
								SET @stmt += ''''
									INSERT INTO #alwaysOn(Query, GroupA, GroupB, GroupC, [Key], Value)
									SELECT
										1 AS Query, '''''''''''''''' AS GroupA, '''''''''''''''' AS GroupB, '''''''''''''''' AS GroupC, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(dhc.cluster_name AS nvarchar(max)) AS cluster_name
											,CAST(dhc.quorum_type_desc AS nvarchar(max)) AS quorum_type_desc
											,CAST(dhc.quorum_state_desc AS nvarchar(max)) AS quorum_state_desc
										FROM sys.dm_hadr_cluster AS dhc WITH (NOLOCK)
									) AS p
									UNPIVOT (
										V FOR K IN (
											p.cluster_name
											,p.quorum_type_desc
											,p.quorum_state_desc
										)
									) AS unpvt
									OPTION (RECOMPILE);
								'''';
				'';
				SET @stmt += ''
								SET @stmt += ''''
									INSERT INTO #alwaysOn(Query, GroupA, GroupB, GroupC, [Key], Value)
									SELECT
										2 AS Query, unpvt.GroupA, '''''''''''''''' AS GroupB, '''''''''''''''' AS GroupC, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(dhcm.member_name AS nvarchar(max)) AS GroupA
											,CAST(dhcm.member_type_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS member_type_desc
											,CAST(dhcm.member_state_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS member_state_desc
											,CAST(dhcm.number_of_quorum_votes AS nvarchar(max)) AS number_of_quorum_votes
											,CAST('''' + @numberOfCurrentVotesStmt + '''' AS nvarchar(max)) AS number_of_current_votes
										FROM sys.dm_hadr_cluster_members AS dhcm WITH (NOLOCK)
									) AS p
									UNPIVOT (
										V FOR K IN (
											p.member_type_desc
											,p.member_state_desc
											,p.number_of_quorum_votes
											,p.number_of_current_votes
										)
									) AS unpvt
									OPTION (RECOMPILE);
								'''';
				'';
				SET @stmt += ''
								SET @stmt += ''''
									INSERT INTO #alwaysOn(Query, GroupA, GroupB, GroupC, [Key], Value)
									SELECT
										3 AS Query, unpvt.GroupA, unpvt.GroupB, '''''''''''''''' AS GroupC, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(ag.name AS nvarchar(max)) AS GroupA
											,CAST(dhags.primary_replica AS nvarchar(max)) AS GroupB
											,CAST(dhags.primary_recovery_health_desc AS nvarchar(max)) AS primary_recovery_health_desc
											,CAST(dhags.secondary_recovery_health_desc AS nvarchar(max)) AS secondary_recovery_health_desc
											,CAST(dhags.synchronization_health_desc AS nvarchar(max)) AS synchronization_health_desc
										FROM sys.dm_hadr_availability_group_states AS dhags WITH (NOLOCK)
										INNER JOIN sys.availability_groups AS ag WITH (NOLOCK) ON (ag.group_id = dhags.group_id)
									) AS p
									UNPIVOT (
										V FOR K IN (
											p.primary_recovery_health_desc
											,p.secondary_recovery_health_desc
											,p.synchronization_health_desc
										)
									) AS unpvt
									OPTION (RECOMPILE);
								'''';
				'';
				SET @stmt += ''
								SET @stmt += ''''
									INSERT INTO #alwaysOn(Query, GroupA, GroupB, GroupC, [Key], Value)
									SELECT
										4 AS Query, unpvt.GroupA, unpvt.GroupB, unpvt.GroupC, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(ag.name AS nvarchar(max)) AS GroupA
											,CAST(arSrc.replica_server_name AS nvarchar(max)) AS GroupB
											,CAST(arRepl.replica_server_name AS nvarchar(max)) AS GroupC
											,CAST(arRepl.read_only_routing_url COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS read_only_routing_url
											,CAST(arorl.routing_priority AS nvarchar(max)) AS routing_priority
											,CAST(arRepl.secondary_role_allow_connections_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS secondary_role_allow_connections_desc
										FROM sys.availability_read_only_routing_lists AS arorl WITH (NOLOCK)
										INNER JOIN sys.availability_replicas AS arSrc WITH (NOLOCK) ON (arSrc.replica_id = arorl.replica_id)
										INNER JOIN sys.availability_replicas AS arRepl WITH (NOLOCK) ON (arRepl.replica_id = arorl.read_only_replica_id)
										INNER JOIN sys.availability_groups AS ag WITH (NOLOCK) ON (ag.group_id = arSrc.group_id)
									) AS p
									UNPIVOT (
										V FOR K IN (
											p.read_only_routing_url
											,p.routing_priority
											,p.secondary_role_allow_connections_desc
										)
									) AS unpvt
									OPTION (RECOMPILE);
								'''';
				'';
				SET @stmt += ''
								SET @stmt += ''''
									INSERT INTO #alwaysOn(Query, GroupA, GroupB, GroupC, [Key], Value)
									SELECT
										5 AS Query, unpvt.GroupA, unpvt.GroupB, '''''''''''''''' AS GroupC, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(ag.name AS nvarchar(max)) AS GroupA
											,CAST(ar.replica_server_name AS nvarchar(max)) AS GroupB
											,CAST(ar.endpoint_url COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS endpoint_url
											,CAST(ar.availability_mode_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS availability_mode_desc
											,CAST(ar.failover_mode_desc AS nvarchar(max)) AS failover_mode_desc
											,CAST(ar.primary_role_allow_connections_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS primary_role_allow_connections_desc
											,CAST(ar.secondary_role_allow_connections_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS secondary_role_allow_connections_desc
											,CAST(ar.backup_priority AS nvarchar(max)) AS backup_priority
											,CAST(ar.read_only_routing_url COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS read_only_routing_url
											,CAST('''' + @readWriteRoutingURLStmt + '''' AS nvarchar(max)) AS read_write_routing_url
										FROM sys.availability_replicas AS ar WITH (NOLOCK)
										INNER JOIN sys.availability_groups AS ag WITH (NOLOCK) ON (ag.group_id = ar.group_id)
									) AS p
									UNPIVOT (
										V FOR K IN (
											p.endpoint_url
											,p.availability_mode_desc
											,p.failover_mode_desc
											,p.primary_role_allow_connections_desc
											,p.secondary_role_allow_connections_desc
											,p.backup_priority
											,p.read_only_routing_url
											,p.read_write_routing_url
										)
									) AS unpvt
									OPTION (RECOMPILE);
								'''';
				'';
				SET @stmt += ''
								SET @stmt += ''''
									INSERT INTO #alwaysOn(Query, GroupA, GroupB, GroupC, [Key], Value)
									SELECT
										6 AS Query, unpvt.GroupA, unpvt.GroupB, unpvt.GroupC, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(ag.name AS nvarchar(max)) AS GroupA
											,CAST(ar.replica_server_name AS nvarchar(max)) AS GroupB
											,CAST(d.name AS nvarchar(max)) AS GroupC
											,CAST(dhdrs.is_local AS nvarchar(max)) AS is_local
											,CAST('''' + @isPrimaryReplicaStmt + '''' AS nvarchar(max)) AS is_primary_replica
											,CAST(dhdrs.synchronization_state_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS synchronization_state_desc
											,CAST(dhdrs.is_commit_participant AS nvarchar(max)) AS is_commit_participant
											,CAST(dhdrs.synchronization_health_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS synchronization_health_desc
											,CAST(dhdrs.database_state_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS database_state_desc
											,CAST(dhdrs.is_suspended AS nvarchar(max)) AS is_suspended
											,CAST(dhdrs.suspend_reason_desc COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS suspend_reason_desc
										FROM sys.dm_hadr_database_replica_states AS dhdrs WITH (NOLOCK)
										INNER JOIN sys.availability_replicas AS ar WITH (NOLOCK) ON (ar.group_id = dhdrs.group_id) AND (ar.replica_id = dhdrs.replica_id)
										INNER JOIN sys.availability_groups AS ag WITH (NOLOCK) ON (ag.group_id = ar.group_id)
										INNER JOIN sys.databases AS d WITH (NOLOCK) ON (d.database_id = dhdrs.database_id)
									) AS p
									UNPIVOT (
										V FOR K IN (
											p.is_local
											,p.is_primary_replica
											,p.synchronization_state_desc
											,p.is_commit_participant
											,p.synchronization_health_desc
											,p.database_state_desc
											,p.is_suspended
											,p.suspend_reason_desc
										)
									) AS unpvt
									OPTION (RECOMPILE);
								'''';
				'';
				SET @stmt += ''
								EXEC(@stmt);
							END;
				'';
				SET @stmt += ''
							--
							-- Remove records where Value is NULL
							--
							BEGIN
								DELETE tgt
								FROM #alwaysOn AS tgt
								WHERE (tgt.Value IS NULL);
							END;

							--
							-- Update current record ValidTo as it is no longer valid
							--
							BEGIN
								UPDATE tgt
								SET tgt.ValidTo = @nowUTC
								FROM dbo.fhsmAlwaysOnState AS tgt
								LEFT OUTER JOIN #alwaysOn AS src ON (src.Query = tgt.Query)
									AND (src.GroupA COLLATE DATABASE_DEFAULT = tgt.GroupA)
									AND (src.GroupB COLLATE DATABASE_DEFAULT = tgt.GroupB)
									AND (src.GroupC COLLATE DATABASE_DEFAULT = tgt.GroupC)
									AND (src.[Key] COLLATE DATABASE_DEFAULT = tgt.[Key])
								WHERE
									(
										(src.Query IS NULL)
										OR ((src.Value COLLATE DATABASE_DEFAULT <> tgt.Value) OR (src.Value IS NULL AND tgt.Value IS NOT NULL) OR (src.Value IS NOT NULL AND tgt.Value IS NULL))
									) AND (tgt.ValidTo = ''''9999-dec-31 23:59:59'''');
							END;

							--
							-- Insert new records
							--
							BEGIN
								INSERT INTO dbo.fhsmAlwaysOnState(Query, GroupA, GroupB, GroupC, [Key], Value, ValidFrom, ValidTo, TimestampUTC, Timestamp)
								SELECT src.Query, src.GroupA, src.GroupB, src.GroupC, src.[Key], src.Value, @nowUTC AS ValidFrom, ''''9999-dec-31 23:59:59'''' AS ValidTo, @nowUTC, @now
								FROM #alwaysOn AS src
								WHERE NOT EXISTS (
									SELECT *
									FROM dbo.fhsmAlwaysOnState AS tgt
									WHERE
										(tgt.Query = src.Query)
										AND (tgt.GroupA COLLATE DATABASE_DEFAULT = src.GroupA)
										AND (tgt.GroupB COLLATE DATABASE_DEFAULT = src.GroupB)
										AND (tgt.GroupC COLLATE DATABASE_DEFAULT = src.GroupC)
										AND (tgt.[Key] COLLATE DATABASE_DEFAULT = src.[Key])
										AND ((tgt.Value COLLATE DATABASE_DEFAULT = src.Value) OR (tgt.Value IS NULL AND src.Value IS NULL)) AND (tgt.ValidTo = ''''9999-dec-31 23:59:59'''')
								);
							END;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPAlwaysOnState
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPAlwaysOnState'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPDatabaseState
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPDatabaseState'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPDatabaseState AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPDatabaseState (
						@name nvarchar(128)
						,@version nvarchar(128) OUTPUT
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @database nvarchar(128);
						DECLARE @errorMsg nvarchar(max);
						DECLARE @message nvarchar(max);
						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @parameter nvarchar(max);
						DECLARE @replicaId uniqueidentifier;
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--******************************************************************************
						--*   Copyright (C) 2020 Glenn Berry
						--*   All rights reserved. 
						--*
						--*
						--*   You may alter this code for your own *non-commercial* purposes. You may
						--*   republish altered code as long as you include this copyright and give due credit. 
						--*
						--*
						--*   THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
						--*   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
						--*   TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
						--*   PARTICULAR PURPOSE. 
						--*
						--******************************************************************************

						--
						-- Get the parameter for the command
						--
						BEGIN
							SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
						END;

						--
						-- Collect data
						--
						BEGIN
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				SET @stmt += ''
							--
							-- Calling dbo.fhsmSPAlwaysOnState
							--
							BEGIN
								SET @message = ''''Before calling dbo.fhsmSPAlwaysOnState'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

								EXEC dbo.fhsmSPAlwaysOnState @name = @name, @parameter = @parameter;

								SET @message = ''''After calling dbo.fhsmSPAlwaysOnState'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
				'';
			END;
			SET @stmt += ''
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							IF (OBJECT_ID(''''tempdb..#inventory'''') IS NOT NULL) DROP TABLE #inventory;

							CREATE TABLE #inventory(
								Query int NOT NULL
								,DatabaseName nvarchar(128) NOT NULL
								,[Key] nvarchar(128) NOT NULL
								,Value nvarchar(max) NULL
								,PRIMARY KEY(Query, DatabaseName, [Key])
							);

							DECLARE @xpReadErrorLog TABLE(LogDate datetime, ProcessorInfo nvarchar(128), Text nvarchar(max));
							DECLARE @xpReadReg TABLE(Value nvarchar(128), Data nvarchar(max));

							--
							-- Recovery model, log reuse wait description, log file size, log usage size  (Query 31) (Database Properties)
							--
							BEGIN
								--
								-- Test if is_auto_create_stats_incremental_on exists on databases
								--
								BEGIN
									DECLARE @isAutoCreateStatsIncrementalOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_auto_create_stats_incremental_on'''')
									)
									BEGIN
										SET @isAutoCreateStatsIncrementalOnStmt = ''''d.is_auto_create_stats_incremental_on'''';
									END
									ELSE BEGIN
										SET @isAutoCreateStatsIncrementalOnStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_query_store_on exists on databases
								--
								BEGIN
									DECLARE @isQueryStoreOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_query_store_on'''')
									)
									BEGIN
										SET @isQueryStoreOnStmt = ''''d.is_query_store_on'''';
									END
									ELSE BEGIN
										SET @isQueryStoreOnStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if delayed_durability exists on databases
								--
								BEGIN
									DECLARE @delayedDurabilityStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''delayed_durability'''')
									)
									BEGIN
										SET @delayedDurabilityStmt = ''''d.delayed_durability'''';
									END
									ELSE BEGIN
										SET @delayedDurabilityStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_memory_optimized_elevate_to_snapshot_on exists on databases
								--
								BEGIN
									DECLARE @isMemoryOptimizedElevateToSnapshotOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_memory_optimized_elevate_to_snapshot_on'''')
									)
									BEGIN
										SET @isMemoryOptimizedElevateToSnapshotOnStmt = ''''d.is_memory_optimized_elevate_to_snapshot_on'''';
									END
									ELSE BEGIN
										SET @isMemoryOptimizedElevateToSnapshotOnStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_federation_member exists on databases
								--
								BEGIN
									DECLARE @isFederationMemberStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_federation_member'''')
									)
									BEGIN
										SET @isFederationMemberStmt = ''''d.is_federation_member'''';
									END
									ELSE BEGIN
										SET @isFederationMemberStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if is_remote_data_archive_enabled exists on databases
								--
								BEGIN
									DECLARE @isRemoteDataArchiveEnabledStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_remote_data_archive_enabled'''')
									)
									BEGIN
										SET @isRemoteDataArchiveEnabledStmt = ''''d.is_remote_data_archive_enabled'''';
									END
									ELSE BEGIN
										SET @isRemoteDataArchiveEnabledStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_mixed_page_allocation_on exists on databases
								--
								BEGIN
									DECLARE @isMixedPageAllocationOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_mixed_page_allocation_on'''')
									)
									BEGIN
										SET @isMixedPageAllocationOnStmt = ''''d.is_mixed_page_allocation_on'''';
									END
									ELSE BEGIN
										SET @isMixedPageAllocationOnStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if is_temporal_history_retention_enabled exists on databases
								--
								BEGIN
									DECLARE @isTemporalHistoryRetentionEnabledStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_temporal_history_retention_enabled'''')
									)
									BEGIN
										SET @isTemporalHistoryRetentionEnabledStmt = ''''d.is_temporal_history_retention_enabled'''';
									END
									ELSE BEGIN
										SET @isTemporalHistoryRetentionEnabledStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if catalog_collation_type exists on databases
								--
								BEGIN
									DECLARE @catalogCollationTypeStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''catalog_collation_type'''')
									)
									BEGIN
										SET @catalogCollationTypeStmt = ''''d.catalog_collation_type'''';
									END
									ELSE BEGIN
										SET @catalogCollationTypeStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if physical_database_name exists on databases
								--
								BEGIN
									DECLARE @physicalDatabaseNameStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''physical_database_name'''')
									)
									BEGIN
										SET @physicalDatabaseNameStmt = ''''d.physical_database_name COLLATE DATABASE_DEFAULT'''';
									END
									ELSE BEGIN
										SET @physicalDatabaseNameStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if is_result_set_caching_on exists on databases
								--
								BEGIN
									DECLARE @isResultSetCachingOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_result_set_caching_on'''')
									)
									BEGIN
										SET @isResultSetCachingOnStmt = ''''d.is_result_set_caching_on'''';
									END
									ELSE BEGIN
										SET @isResultSetCachingOnStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_accelerated_database_recovery_on exists on databases
								--
								BEGIN
									DECLARE @isAcceleratedDatabaseRecoveryOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_accelerated_database_recovery_on'''')
									)
									BEGIN
										SET @isAcceleratedDatabaseRecoveryOnStmt = ''''d.is_accelerated_database_recovery_on'''';
									END
									ELSE BEGIN
										SET @isAcceleratedDatabaseRecoveryOnStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_tempdb_spill_to_remote_store exists on databases
								--
								BEGIN
									DECLARE @isTempdbSpillToRemoteStoreStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_tempdb_spill_to_remote_store'''')
									)
									BEGIN
										SET @isTempdbSpillToRemoteStoreStmt = ''''d.is_tempdb_spill_to_remote_store'''';
									END
									ELSE BEGIN
										SET @isTempdbSpillToRemoteStoreStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if is_stale_page_detection_on exists on databases
								--
								BEGIN
									DECLARE @isStalePageDetectionOnStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_stale_page_detection_on'''')
									)
									BEGIN
										SET @isStalePageDetectionOnStmt = ''''d.is_stale_page_detection_on'''';
									END
									ELSE BEGIN
										SET @isStalePageDetectionOnStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if is_memory_optimized_enabled exists on databases
								--
								BEGIN
									DECLARE @isMemoryOptimizedEnabledStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''is_memory_optimized_enabled'''')
									)
									BEGIN
										SET @isMemoryOptimizedEnabledStmt = ''''d.is_memory_optimized_enabled'''';
									END
									ELSE BEGIN
										SET @isMemoryOptimizedEnabledStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if containment exists on databases
								--
								BEGIN
									DECLARE @containmentStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''containment'''')
									)
									BEGIN
										SET @containmentStmt = ''''d.containment'''';
									END
									ELSE BEGIN
										SET @containmentStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if replica_id exists on databases
								--
								BEGIN
									DECLARE @replicaIdStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''replica_id'''')
									)
									BEGIN
										SET @replicaIdStmt = ''''d.replica_id'''';
									END
									ELSE BEGIN
										SET @replicaIdStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if target_recovery_time_in_seconds exists on databases
								--
								BEGIN
									DECLARE @targetRecoveryTimeInSecondsStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''databases'''') AND (sc.name = ''''target_recovery_time_in_seconds'''')
									)
									BEGIN
										SET @targetRecoveryTimeInSecondsStmt = ''''d.target_recovery_time_in_seconds'''';
									END
									ELSE BEGIN
										SET @targetRecoveryTimeInSecondsStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								--
								-- Test if encryption_scan_state exists on dm_database_encryption_keys
								--
								BEGIN
									DECLARE @encryptionScanStateStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''dm_database_encryption_keys'''') AND (sc.name = ''''encryption_scan_state'''')
									)
									BEGIN
										SET @encryptionScanStateStmt = ''''ddek.encryption_scan_state'''';
									END
									ELSE BEGIN
										SET @encryptionScanStateStmt = ''''NULL'''';
									END;
								END;

								--
								-- Test if encryption_scan_modify_date exists on dm_database_encryption_keys
								--
								BEGIN
									DECLARE @encryptionScanModifyDateStmt nvarchar(max);

									IF EXISTS(
										SELECT *
										FROM master.sys.system_columns AS sc
										INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
										WHERE (so.name = ''''dm_database_encryption_keys'''') AND (sc.name = ''''encryption_scan_modify_date'''')
									)
									BEGIN
										SET @encryptionScanModifyDateStmt = ''''ddek.encryption_scan_modify_date'''';
									END
									ELSE BEGIN
										SET @encryptionScanModifyDateStmt = ''''NULL'''';
									END;
								END;
			'';
			SET @stmt += ''
								SET @stmt = ''''
									INSERT INTO #inventory(Query, DatabaseName, [Key], Value)
									SELECT 31 AS Query, unpvt.database_name AS DatabaseName, unpvt.K, unpvt.V
									FROM (
										SELECT
											CAST(d.name                                        AS nvarchar(max)) AS database_name 
											,CAST(SUSER_SNAME(d.owner_sid)                     AS nvarchar(max)) AS database_owner
											,CONVERT(nvarchar(max), d.create_date, 126)                          AS database_create_date
											,CAST(d.compatibility_level                        AS nvarchar(max)) AS compatibility_level
											,CAST(d.collation_name COLLATE DATABASE_DEFAULT    AS nvarchar(max)) AS collation_name
											,CAST(d.user_access                                AS nvarchar(max)) AS user_access
											,CAST(d.is_read_only                               AS nvarchar(max)) AS is_read_only
											,CAST(d.is_auto_close_on                           AS nvarchar(max)) AS is_auto_close_on
											,CAST(d.is_auto_shrink_on                          AS nvarchar(max)) AS is_auto_shrink_on
											,CAST(d.state                                      AS nvarchar(max)) AS state
											,CAST(d.is_in_standby                              AS nvarchar(max)) AS is_in_standby
											,CAST(d.is_cleanly_shutdown                        AS nvarchar(max)) AS is_cleanly_shutdown
											,CAST(d.is_supplemental_logging_enabled            AS nvarchar(max)) AS is_supplemental_logging_enabled
											,CAST(d.snapshot_isolation_state                   AS nvarchar(max)) AS snapshot_isolation_state
											,CAST(d.is_read_committed_snapshot_on              AS nvarchar(max)) AS is_read_committed_snapshot_on
											,CAST(d.recovery_model                             AS nvarchar(max)) AS recovery_model
								'''';
			'';
			SET @stmt += ''
								SET @stmt += ''''
											,CAST(d.page_verify_option                         AS nvarchar(max)) AS page_verify_option
											,CAST(d.is_auto_create_stats_on                    AS nvarchar(max)) AS is_auto_create_stats_on
											,CAST('''' + @isAutoCreateStatsIncrementalOnStmt + ''''        AS nvarchar(max)) AS is_auto_create_stats_incremental_on
											,CAST(d.is_auto_update_stats_on                    AS nvarchar(max)) AS is_auto_update_stats_on
											,CAST(d.is_auto_update_stats_async_on              AS nvarchar(max)) AS is_auto_update_stats_async_on
											,CAST(d.is_ansi_null_default_on                    AS nvarchar(max)) AS is_ansi_null_default_on
											,CAST(d.is_ansi_nulls_on                           AS nvarchar(max)) AS is_ansi_nulls_on
											,CAST(d.is_ansi_padding_on                         AS nvarchar(max)) AS is_ansi_padding_on
											,CAST(d.is_ansi_warnings_on                        AS nvarchar(max)) AS is_ansi_warnings_on
											,CAST(d.is_arithabort_on                           AS nvarchar(max)) AS is_arithabort_on
											,CAST(d.is_concat_null_yields_null_on              AS nvarchar(max)) AS is_concat_null_yields_null_on
											,CAST(d.is_numeric_roundabort_on                   AS nvarchar(max)) AS is_numeric_roundabort_on
											,CAST(d.is_quoted_identifier_on                    AS nvarchar(max)) AS is_quoted_identifier_on
											,CAST(d.is_recursive_triggers_on                   AS nvarchar(max)) AS is_recursive_triggers_on
											,CAST(d.is_cursor_close_on_commit_on               AS nvarchar(max)) AS is_cursor_close_on_commit_on
											,CAST(d.is_local_cursor_default                    AS nvarchar(max)) AS is_local_cursor_default
								'''';
			'';
			SET @stmt += ''
								SET @stmt += ''''
											,CAST(d.is_fulltext_enabled                        AS nvarchar(max)) AS is_fulltext_enabled
											,CAST(d.is_trustworthy_on                          AS nvarchar(max)) AS is_trustworthy_on
											,CAST(d.is_db_chaining_on                          AS nvarchar(max)) AS is_db_chaining_on
											,CAST(d.is_parameterization_forced                 AS nvarchar(max)) AS is_parameterization_forced
											,CAST(d.is_master_key_encrypted_by_server          AS nvarchar(max)) AS is_master_key_encrypted_by_server
											,CAST('''' + @isQueryStoreOnStmt + ''''                          AS nvarchar(max)) AS is_query_store_on
											,CAST(d.is_published                               AS nvarchar(max)) AS is_published
											,CAST(d.is_subscribed                              AS nvarchar(max)) AS is_subscribed
											,CAST(d.is_merge_published                         AS nvarchar(max)) AS is_merge_published
											,CAST(d.is_distributor                             AS nvarchar(max)) AS is_distributor
											,CAST(d.is_sync_with_backup                        AS nvarchar(max)) AS is_sync_with_backup
											,CAST(d.is_broker_enabled                          AS nvarchar(max)) AS is_broker_enabled
											,CAST(d.is_date_correlation_on                     AS nvarchar(max)) AS is_date_correlation_on
											,CAST(d.is_cdc_enabled                             AS nvarchar(max)) AS is_cdc_enabled
											,CAST(d.is_encrypted                               AS nvarchar(max)) AS is_encrypted
											,CAST(d.is_honor_broker_priority_on                AS nvarchar(max)) AS is_honor_broker_priority_on
											,CAST('''' + @replicaIdStmt + ''''                               AS nvarchar(max)) AS replica_id
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				SET @stmt += ''
											,CAST((
												SELECT ag.name COLLATE DATABASE_DEFAULT
												FROM master.sys.availability_groups AS ag
												INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
												WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = d.replica_id)
											) AS nvarchar(max)) AS AlwaysOnGroupName
											,COALESCE(CAST((
												SELECT
												CASE
													WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
													ELSE                                                  2
												END AS IsPrimaryServer
												FROM master.sys.availability_groups AS ag
												INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
												INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
												WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = d.replica_id)
											) AS nvarchar(max)), ''''''''3'''''''') AS IsOnAlwaysOnPrimary
				'';
			END
			ELSE BEGIN
				SET @stmt += ''
											,CAST(NULL AS nvarchar(max))		AS AlwaysOnGroupName
											,CAST(''''''''3'''''''' AS nvarchar(max))	AS IsOnAlwaysOnPrimary
				'';
			END
				SET @stmt += ''
											,CAST('''' + @containmentStmt + ''''                                AS nvarchar(max)) AS containment
											,CAST('''' + @targetRecoveryTimeInSecondsStmt + ''''            AS nvarchar(max)) AS target_recovery_time_in_seconds
								'''';
								SET @stmt += ''''
											,CAST('''' + @delayedDurabilityStmt + ''''                         AS nvarchar(max)) AS delayed_durability
											,CAST('''' + @isMemoryOptimizedElevateToSnapshotOnStmt + '''' AS nvarchar(max)) AS is_memory_optimized_elevate_to_snapshot_on
											,CAST('''' + @isFederationMemberStmt + ''''                       AS nvarchar(max)) AS is_federation_member
											,CAST('''' + @isRemoteDataArchiveEnabledStmt + ''''             AS nvarchar(max)) AS is_remote_data_archive_enabled
											,CAST('''' + @isMixedPageAllocationOnStmt + ''''                AS nvarchar(max)) AS is_mixed_page_allocation_on
											,CAST('''' + @isTemporalHistoryRetentionEnabledStmt + ''''      AS nvarchar(max)) AS is_temporal_history_retention_enabled
											,CAST('''' + @catalogCollationTypeStmt + ''''                     AS nvarchar(max)) AS catalog_collation_type
											,CAST('''' + @physicalDatabaseNameStmt + ''''                     AS nvarchar(max)) AS physical_database_name
											,CAST('''' + @isResultSetCachingOnStmt + ''''                   AS nvarchar(max)) AS is_result_set_caching_on
											,CAST('''' + @isAcceleratedDatabaseRecoveryOnStmt + ''''        AS nvarchar(max)) AS is_accelerated_database_recovery_on
											,CAST('''' + @isTempdbSpillToRemoteStoreStmt + ''''            AS nvarchar(max)) AS is_tempdb_spill_to_remote_store
											,CAST('''' + @isStalePageDetectionOnStmt + ''''                 AS nvarchar(max)) AS is_stale_page_detection_on
											,CAST('''' + @isMemoryOptimizedEnabledStmt + ''''                AS nvarchar(max)) AS is_memory_optimized_enabled
											,CAST(ddek.encryption_state                        AS nvarchar(max)) AS encryption_state
											,CONVERT(nvarchar(max), ddek.create_date, 126)                       AS key_create_date
											,CONVERT(nvarchar(max), ddek.regenerate_date, 126)                   AS key_regenerate_date
											,CONVERT(nvarchar(max), ddek.set_date, 126)                          AS key_set_date
											,CONVERT(nvarchar(max), ddek.opened_date, 126)                       AS key_opened_date
											,CAST(ddek.key_algorithm COLLATE DATABASE_DEFAULT  AS nvarchar(max)) AS key_algorithm
											,CAST(ddek.key_length                              AS nvarchar(max)) AS key_length
											,CAST(ddek.percent_complete                        AS nvarchar(max)) AS percent_complete
											,CAST('''' + @encryptionScanStateStmt + ''''                   AS nvarchar(max)) AS encryption_scan_state
											,CAST('''' + @encryptionScanModifyDateStmt + ''''             AS nvarchar(max)) AS encryption_scan_modify_date
										FROM sys.databases AS d WITH (NOLOCK)
										LEFT OUTER JOIN sys.dm_database_encryption_keys AS ddek WITH (NOLOCK) ON (d.database_id = ddek.database_id)
									) AS p
								'''';
			'';
			SET @stmt += ''
								SET @stmt += ''''
									UNPIVOT(
										V FOR K IN (
											p.database_owner
											,p.database_create_date
											,p.compatibility_level
											,p.collation_name
											,p.user_access
											,p.is_read_only
											,p.is_auto_close_on
											,p.is_auto_shrink_on
											,p.state
											,p.is_in_standby
											,p.is_cleanly_shutdown
											,p.is_supplemental_logging_enabled
											,p.snapshot_isolation_state
											,p.is_read_committed_snapshot_on
											,p.recovery_model
								'''';
								SET @stmt += ''''
											,p.page_verify_option
											,p.is_auto_create_stats_on
											,p.is_auto_create_stats_incremental_on
											,p.is_auto_update_stats_on
											,p.is_auto_update_stats_async_on
											,p.is_ansi_null_default_on
											,p.is_ansi_nulls_on
											,p.is_ansi_padding_on
											,p.is_ansi_warnings_on
											,p.is_arithabort_on
											,p.is_concat_null_yields_null_on
											,p.is_numeric_roundabort_on
											,p.is_quoted_identifier_on
											,p.is_recursive_triggers_on
											,p.is_cursor_close_on_commit_on
											,p.is_local_cursor_default
								'''';
			'';
			SET @stmt += ''
								SET @stmt += ''''
											,p.is_fulltext_enabled
											,p.is_trustworthy_on
											,p.is_db_chaining_on
											,p.is_parameterization_forced
											,p.is_master_key_encrypted_by_server
											,p.is_query_store_on
											,p.is_published
											,p.is_subscribed
											,p.is_merge_published
											,p.is_distributor
											,p.is_sync_with_backup
											,p.is_broker_enabled
											,p.is_date_correlation_on
											,p.is_cdc_enabled
											,p.is_encrypted
											,p.is_honor_broker_priority_on
											,p.replica_id
											,p.AlwaysOnGroupName
											,p.IsOnAlwaysOnPrimary
											,p.containment
											,p.target_recovery_time_in_seconds
								'''';
								SET @stmt += ''''
											,p.delayed_durability
											,p.is_memory_optimized_elevate_to_snapshot_on
											,p.is_federation_member
											,p.is_remote_data_archive_enabled
											,p.is_mixed_page_allocation_on
											,p.is_temporal_history_retention_enabled
											,p.catalog_collation_type
											,p.physical_database_name
											,p.is_result_set_caching_on
											,p.is_accelerated_database_recovery_on
											,p.is_tempdb_spill_to_remote_store
											,p.is_stale_page_detection_on
											,p.is_memory_optimized_enabled
											,p.encryption_state
											,p.key_create_date
											,p.key_regenerate_date
											,p.key_set_date
											,p.key_opened_date
											,p.key_algorithm
											,p.key_length
											,p.percent_complete
											,p.encryption_scan_state
											,p.encryption_scan_modify_date
										)
									) AS unpvt OPTION (RECOMPILE);
								'''';
								EXEC(@stmt);
							END;
				'';
				IF (@productVersion1 < 13)
				BEGIN
					-- SQL Versions SQL2014 or lower
					RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
					RAISERROR(''!!! Can not install Database scoped configurations on SQL versions lower than SQL2016'', 0, 1) WITH NOWAIT;
					RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
				END
				ELSE BEGIN
					SET @stmt += ''
							--
							-- Get Database scoped configurations Query:60/1060/2060
							--
							BEGIN
								DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
								SELECT d.name AS DatabaseName, d.replica_id
								FROM sys.databases AS d
								ORDER BY d.name;

								OPEN dCur;

								WHILE (1 = 1)
								BEGIN
									FETCH NEXT FROM dCur
									INTO @database, @replicaId;

									IF (@@FETCH_STATUS <> 0)
									BEGIN
										BREAK;
									END;

									--
									-- If is a member of a replica, we will only execute when running on the primary
									--
									IF (@replicaId IS NULL)
										OR (
											(
												SELECT
												CASE
													WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
													ELSE 0
												END AS IsPrimaryServer
												FROM master.sys.availability_groups AS ag
												INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
												INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
												WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
											) = 1
										)
									BEGIN
										SET @stmt = ''''
											USE '''' + QUOTENAME(@database) + '''';
											INSERT INTO #inventory(Query, DatabaseName, [Key], Value)
											SELECT
												a.Query
												,DB_NAME() AS DatabaseName
												,CAST(a.name AS nvarchar(max)) AS [Key]
												,CAST(a.value AS nvarchar(max)) AS Value
											FROM (
												SELECT
													60 AS Query	-- Value for primary
													,dsc.name
													,dsc.value
												FROM sys.database_scoped_configurations AS dsc WITH (NOLOCK)

												UNION ALL

												SELECT
													1060 AS Query	-- Value for secondary
													,dsc.name
													,dsc.value_for_secondary AS value
												FROM sys.database_scoped_configurations AS dsc WITH (NOLOCK)

												UNION ALL
					'';
					IF (@productVersion1 >= 14)
					BEGIN
						-- SQL Versions SQL2017 or higher
						SET @stmt += ''
												SELECT
													2060 AS Query	-- Is default value
													,dsc.name
													,dsc.is_value_default AS value
												FROM sys.database_scoped_configurations AS dsc WITH (NOLOCK)
						'';
					END
					ELSE BEGIN
						SET @stmt += ''
												SELECT
													2060 AS Query	-- Is default value
													,dscDefaultValues.name
													,CASE WHEN (dscDefaultValues.value <> dsc.value) OR (dsc.value_for_secondary IS NOT NULL) THEN 0 ELSE 1 END AS value
												FROM (
													VALUES
														(''''''''LEGACY_CARDINALITY_ESTIMATION'''''''',	0),
														(''''''''MAXDOP'''''''',						0),
														(''''''''PARAMETER_SNIFFING'''''''',			1),
														(''''''''QUERY_OPTIMIZER_HOTFIXES'''''''',		0)
												) AS dscDefaultValues(name, value)
												INNER JOIN sys.database_scoped_configurations AS dsc WITH (NOLOCK) ON (dsc.name = dscDefaultValues.name)
						'';
					END;
					SET @stmt += ''
											) AS a
											WHERE (a.value IS NOT NULL)
											OPTION (RECOMPILE);
										'''';

										BEGIN TRY
											EXEC(@stmt);
										END TRY
										BEGIN CATCH
											SET @errorMsg = ERROR_MESSAGE();

											SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
											EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
										END CATCH;
									END
									ELSE BEGIN
										SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
									END;
								END;

								CLOSE dCur;
								DEALLOCATE dCur;
							END;
					'';
				END;
				SET @stmt += ''
							--
							-- Remove records where Value is NULL
							--
							BEGIN
								DELETE tgt
								FROM #inventory AS tgt
								WHERE (tgt.Value IS NULL);
							END;

							--
							-- Update current record ValidTo as it is no longer valid
							--
							BEGIN
								UPDATE tgt
								SET tgt.ValidTo = @nowUTC
								FROM dbo.fhsmDatabaseState AS tgt
								LEFT OUTER JOIN #inventory AS src ON (src.Query = tgt.Query) AND (src.DatabaseName COLLATE DATABASE_DEFAULT = tgt.DatabaseName) AND (src.[Key] COLLATE DATABASE_DEFAULT = tgt.[Key])
								WHERE
									(
										(src.Query IS NULL)
										OR ((src.Value COLLATE DATABASE_DEFAULT <> tgt.Value) OR (src.Value IS NULL AND tgt.Value IS NOT NULL) OR (src.Value IS NOT NULL AND tgt.Value IS NULL))
									) AND (tgt.ValidTo = ''''9999-dec-31 23:59:59'''');
							END;

							--
							-- Insert new records
							--
							BEGIN
								INSERT INTO dbo.fhsmDatabaseState(Query, DatabaseName, [Key], Value, ValidFrom, ValidTo, TimestampUTC, Timestamp)
								SELECT src.Query, src.DatabaseName, src.[Key], src.Value, @nowUTC AS ValidFrom, ''''9999-dec-31 23:59:59'''' AS ValidTo, @nowUTC, @now
								FROM #inventory AS src
								WHERE NOT EXISTS (
									SELECT *
									FROM dbo.fhsmDatabaseState AS tgt
									WHERE
										(tgt.Query = src.Query)
										AND (tgt.DatabaseName COLLATE DATABASE_DEFAULT = src.DatabaseName)
										AND (tgt.[Key] COLLATE DATABASE_DEFAULT = src.[Key])
										AND ((tgt.Value COLLATE DATABASE_DEFAULT = src.Value) OR (tgt.Value IS NULL AND src.Value IS NULL)) AND (tgt.ValidTo = ''''9999-dec-31 23:59:59'''')
								);
							END;
				'';
				SET @stmt += ''
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPDatabaseState
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPDatabaseState'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmAlwaysOnState''
				,1
				,''TimestampUTC''
				,1
				,1825	-- 5 years
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmDatabaseState''
				,1
				,''TimestampUTC''
				,1
				,1825	-- 5 years
				,NULL

		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableDatabaseState							AS Enabled
				,0												AS DeploymentStatus
				,''Database state''								AS Name
				,PARSENAME(''dbo.fhsmSPDatabaseState'', 1)		AS Task
				,1 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2
			,OutputColumn1, OutputColumn2
		) AS (
			SELECT
				''Always On group'' AS DimensionName
				,''AlwaysOnGroupKey'' AS DimensionKey
				,''dbo.fhsmAlwaysOnState'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[GroupA]'', NULL
				,''Group'', NULL

			UNION ALL

			SELECT
				''Always On group-replica'' AS DimensionName
				,''AlwaysOnGroupReplicaKey'' AS DimensionKey
				,''dbo.fhsmAlwaysOnState'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[GroupA]'', ''src.[GroupB]''
				,''Group'', ''Replica''

			UNION ALL

			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmDatabaseState'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL
				,''Database'', NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2
				,OutputColumn1, OutputColumn2
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2
				,src.OutputColumn1, src.OutputColumn2
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmAlwaysOnState'';
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmDatabaseState'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:AgentJobs.sql modified: 2025.08.05 19.07.12
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableAgentJobs bit;

	SET @enableAgentJobs = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing AgentJobs'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmAgentJobs and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmAgentJobs'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmAgentJobs'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmAgentJobs(
					Id int identity(1,1) NOT NULL
					,JobName nvarchar(128) NOT NULL
					,JobId uniqueidentifier NOT NULL
					,JobEnabled tinyint NOT NULL
					,JobDescription nvarchar(512) NULL
					,ScheduleName nvarchar(128) NULL
					,ScheduleId int NULL
					,ScheduleEnabled int NULL
					,FreqType int NULL
					,FreqInterval int NULL
					,FreqSubdayType int NULL
					,FreqSubdayInterval int NULL
					,FreqRelativeInterval int NULL
					,FreqRecurrenceFactor int NULL
					,ActiveStartDate int NULL
					,ActiveEndDate int NULL
					,ActiveStartTime int NULL
					,ActiveEndTime int NULL
					,NextRunDate int NULL
					,NextRunTime int NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmAgentJobs PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobs'')) AND (i.name = ''NC_fhsmAgentJobs_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmAgentJobs_TimestampUTC] to table dbo.fhsmAgentJobs'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmAgentJobs_TimestampUTC ON dbo.fhsmAgentJobs(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobs'')) AND (i.name = ''NC_fhsmAgentJobs_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmAgentJobs_Timestamp] to table dbo.fhsmAgentJobs'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmAgentJobs_Timestamp ON dbo.fhsmAgentJobs(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmAgentJobs
		--
		BEGIN
			SET @objectName = ''dbo.fhsmAgentJobs'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Agent jobs - grid]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - grid'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - grid'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - grid'') + ''
				AS
				WITH
				L0   AS (SELECT 1 AS c UNION ALL SELECT 1),
				L1   AS (SELECT 1 AS c FROM L0 AS A CROSS JOIN L0 AS B),
				L2   AS (SELECT 1 AS c FROM L1 AS A CROSS JOIN L1 AS B),
				L3   AS (SELECT 1 AS c FROM L2 AS A CROSS JOIN L2 AS B),
				Nums AS (
					SELECT
						ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) - 1 AS n
					FROM L3
				)
				SELECT
					p.JobName
					,p.JobEnabled
					,p.ScheduleId
					,p.ScheduleEnabled
					, p.[0],  p.[1],  p.[2],  p.[3],  p.[4],  p.[5],  p.[6],  p.[7],  p.[8],  p.[9]
					,p.[10], p.[11], p.[12], p.[13], p.[14], p.[15], p.[16], p.[17], p.[18], p.[19]
					,p.[20], p.[21], p.[22], p.[23]
					,p.WhenDesc
					,p.WhenDetailsDesc
					,p.ActiveDesc
					,p.Timestamp
				FROM (
			'';
			SET @stmt += ''
					SELECT
						a.JobName,
						n.n AS HourSlot,
						a.JobEnabled,
						a.ScheduleId,
						a.ScheduleEnabled,
						CASE a.FreqType
							WHEN   1 THEN ''''Once on '''' + CAST(a.ActiveStartDate AS nvarchar) + '''':'''' + CAST(a.ActiveStartTime AS nvarchar)
							WHEN   4 THEN ''''Every '''' + CASE WHEN a.FreqInterval = 1 THEN ''''day'''' ELSE CAST(a.FreqInterval AS nvarchar) + '''' days'''' END
							WHEN   8 THEN ''''Every '''' + CASE WHEN a.FreqRecurrenceFactor = 1 THEN ''''week'''' ELSE CAST(a.FreqRecurrenceFactor AS nvarchar) + '''' weeks'''' END
						END
						AS WhenDesc,
						CASE
							WHEN (a.FreqSubdayType = 0)          THEN ''''''''
							WHEN (a.FreqSubdayType = 1)          THEN ''''At '''' + CAST(a.ActiveStartTime AS nvarchar)
							WHEN (a.FreqSubdayType IN (2, 4, 8)) THEN ''''Every '''' + CAST(a.FreqSubdayInterval AS nvarchar) + '''' ''''
								+ CASE a.FreqSubdayType
									WHEN 2 THEN ''''second''''
									WHEN 4 THEN ''''minute''''
									WHEN 8 THEN ''''hour''''
								END
								+ CASE WHEN a.FreqSubdayInterval > 1 THEN ''''s'''' ELSE '''''''' END
								+ '''' between '''' + CAST(a.ActiveStartTime AS nvarchar) + '''' and '''' + CAST(a.ActiveEndTime AS nvarchar)
						END
						AS WhenDetailsDesc,
						CASE
							WHEN (a.FreqType IN (4, 8, 16, 32))
							THEN
								CASE
									WHEN (a.ActiveEndDate = CAST(''''9999-12-31'''' AS date)) THEN ''''Starting on '''' + CAST(a.ActiveStartDate AS nvarchar)
									ELSE ''''Between '''' + CAST(a.ActiveStartDate AS nvarchar) + '''' and '''' + CAST(a.ActiveEndDate AS nvarchar)
								END
							ELSE ''''''''
						END
						AS ActiveDesc,
						CASE a.FreqType
							WHEN 8 THEN
								SUBSTRING(
									(
										CASE WHEN (a.FreqInterval &  2) =  2 THEN CHAR(10) + ''''Mon'''' ELSE '''''''' END +
										CASE WHEN (a.FreqInterval &  4) =  4 THEN CHAR(10) + ''''Tue'''' ELSE '''''''' END +
										CASE WHEN (a.FreqInterval &  8) =  8 THEN CHAR(10) + ''''Wed'''' ELSE '''''''' END +
										CASE WHEN (a.FreqInterval & 16) = 16 THEN CHAR(10) + ''''Thu'''' ELSE '''''''' END +
										CASE WHEN (a.FreqInterval & 32) = 32 THEN CHAR(10) + ''''Fri'''' ELSE '''''''' END +
										CASE WHEN (a.FreqInterval & 64) = 64 THEN CHAR(10) + ''''Sat'''' ELSE '''''''' END +
										CASE WHEN (a.FreqInterval &  1) =  1 THEN CHAR(10) + ''''Sun'''' ELSE '''''''' END
									)
									,2
									,128
								)
							ELSE ''''X''''
						END
						AS DayDesc,
						a.Timestamp
					FROM (
			'';
			SET @stmt += ''
						SELECT
							aj.JobName
							,CAST(aj.JobEnabled AS bit)				AS JobEnabled
							,aj.ScheduleId
							,CAST(aj.ScheduleEnabled AS bit)		AS ScheduleEnabled
							,aj.FreqType
							,aj.FreqInterval
							,aj.FreqSubdayType
							,aj.FreqSubdayInterval
							,aj.FreqRecurrenceFactor
							,CONVERT(
								date,
									CAST(aj.ActiveStartDate / 10000 AS nvarchar)
									+ ''''-'''' + CAST((aj.ActiveStartDate / 100) % 100 AS nvarchar)
									+ ''''-'''' + CAST((aj.ActiveStartDate % 100) AS nvarchar),
								102
							)										AS ActiveStartDate
							,CONVERT(
								date,
									CAST(aj.ActiveEndDate / 10000 AS nvarchar)
									+ ''''-'''' + CAST((aj.ActiveEndDate / 100) % 100 AS nvarchar)
									+ ''''-'''' + CAST((aj.ActiveEndDate % 100) AS nvarchar),
								102
							)										AS ActiveEndDate
							,CONVERT(
								time(0),
									CAST(aj.ActiveStartTime / 10000 AS nvarchar)
									+ '''':'''' + CAST((aj.ActiveStartTime / 100) % 100 AS nvarchar)
									+ '''':'''' + CAST((aj.ActiveStartTime % 100) AS nvarchar),
								108
							)										AS ActiveStartTime
							,CONVERT(
								time(0),
									CAST(aj.ActiveEndTime / 10000 AS nvarchar)
									+ '''':'''' + CAST((aj.ActiveEndTime / 100) % 100 AS nvarchar)
									+ '''':'''' + CAST((aj.ActiveEndTime % 100) AS nvarchar),
								108
							)										AS ActiveEndTime
							,aj.Timestamp
						FROM dbo.fhsmAgentJobs AS aj
						WHERE (aj.TimestampUTC = (
							SELECT TOP (1) aj2.TimestampUTC
							FROM dbo.fhsmAgentJobs AS aj2
							ORDER BY aj2.TimestampUTC DESC
						))
					) AS a
					CROSS JOIN Nums AS n
					WHERE (1 = 1)
						AND (a.FreqType IN (4, 8))
						AND (CAST(GETDATE() AS date) <= a.ActiveEndDate)
						AND (n.n <= 23)
						AND (
							(
								(a.FreqSubdayType = 1)			-- At the specified time
								AND (n.n = DATEPART(HOUR, a.ActiveStartTime))
							)
							OR (
								(a.FreqSubdayType IN (2, 4))	-- Seconds and minutes
								AND (n.n BETWEEN DATEPART(HOUR, a.ActiveStartTime) AND DATEPART(HOUR, a.ActiveEndTime))
							)
							OR (
								(a.FreqSubdayType = 8)	-- Hours
								AND (n.n BETWEEN DATEPART(HOUR, a.ActiveStartTime) AND DATEPART(HOUR, a.ActiveEndTime))
								AND (((n.n - DATEPART(HOUR, a.ActiveStartTime)) % NULLIF(a.FreqSubdayInterval, 0)) = 0)
							)
						)
				) AS b
				PIVOT (
					MAX(b.DayDesc)
					FOR b.HourSlot IN (
						  [0],  [1],  [2],  [3],  [4],  [5],  [6],  [7],  [8],  [9]
						,[10], [11], [12], [13], [14], [15], [16], [17], [18], [19]
						,[20], [21], [22], [23]
					)
				) AS p
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Agent jobs - grid]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - grid'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Agent jobs - list]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - list'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - list'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - list'') + ''
				AS
				SELECT
					a.JobName,
					a.JobEnabled,
					a.ScheduleEnabled,
					CASE a.FreqType
						WHEN   1 THEN ''''Once on '''' + CAST(a.ActiveStartDate AS nvarchar) + '''':'''' + CAST(a.ActiveStartTime AS nvarchar)
						WHEN   4 THEN ''''Every '''' + CASE WHEN a.FreqInterval = 1 THEN ''''day'''' ELSE CAST(a.FreqInterval AS nvarchar) + '''' days'''' END
						WHEN   8 THEN ''''Every '''' + CASE WHEN a.FreqRecurrenceFactor = 1 THEN ''''week'''' ELSE CAST(a.FreqRecurrenceFactor AS nvarchar) + '''' weeks'''' END
							+ '''' on ''''
							+ SUBSTRING(
								(
									CASE WHEN (a.FreqInterval &  2) =  2 THEN '''', Monday''''    ELSE '''''''' END +
									CASE WHEN (a.FreqInterval &  4) =  4 THEN '''', Tuesday''''   ELSE '''''''' END +
									CASE WHEN (a.FreqInterval &  8) =  8 THEN '''', Wednesday'''' ELSE '''''''' END +
									CASE WHEN (a.FreqInterval & 16) = 16 THEN '''', Thursday''''  ELSE '''''''' END +
									CASE WHEN (a.FreqInterval & 32) = 32 THEN '''', Friday''''    ELSE '''''''' END +
									CASE WHEN (a.FreqInterval & 64) = 64 THEN '''', Saturday''''  ELSE '''''''' END +
									CASE WHEN (a.FreqInterval &  1) =  1 THEN '''', Sunday''''    ELSE '''''''' END
								)
								,3
								,128
							)
						WHEN  16 THEN ''''Every '''' + CASE WHEN a.FreqRecurrenceFactor = 1 THEN ''''month'''' ELSE CAST(a.FreqRecurrenceFactor AS nvarchar) + '''' months'''' END
							+ '''' on day '''' + CAST(a.FreqInterval AS nvarchar) + '''' of that month''''
						WHEN  32 THEN ''''Every ''''
							+ CASE a.FreqRelativeInterval
								WHEN  1 THEN ''''first''''
								WHEN  2 THEN ''''second''''
								WHEN  4 THEN ''''third''''
								WHEN  8 THEN ''''fourth''''
								WHEN 16 THEN ''''last''''
							END
							+ '''' ''''
							+ CASE a.FreqInterval
								WHEN  1 THEN ''''Sunday''''
								WHEN  2 THEN ''''Monday''''
								WHEN  3 THEN ''''Tuesday''''
								WHEN  4 THEN ''''Wednesday''''
								WHEN  5 THEN ''''Thursday''''
								WHEN  6 THEN ''''Friday''''
								WHEN  7 THEN ''''Saturday''''
								WHEN  8 THEN ''''Day''''
								WHEN  9 THEN ''''Weekday''''
								WHEN 10 THEN ''''Weekend day''''
							END
							+ '''' of every '''' + CASE WHEN a.FreqRecurrenceFactor = 1 THEN ''''month'''' ELSE CAST(a.FreqRecurrenceFactor AS nvarchar) + '''' months'''' END

						WHEN  64 THEN ''''When SQL Server Agent starts''''
						WHEN 128 THEN ''''Whenever the CPUs become idle''''
					END
					+ CASE
						WHEN (a.FreqSubdayType = 0)          THEN ''''''''
						WHEN (a.FreqSubdayType = 1)          THEN '''' at '''' + CAST(a.ActiveStartTime AS nvarchar)
						WHEN (a.FreqSubdayType IN (2, 4, 8)) THEN '''' every '''' + CAST(a.FreqSubdayInterval AS nvarchar) + '''' ''''
							+ CASE a.FreqSubdayType
								WHEN 2 THEN ''''second''''
								WHEN 4 THEN ''''minute''''
								WHEN 8 THEN ''''hour''''
							END
							+ CASE WHEN a.FreqSubdayInterval > 1 THEN ''''s'''' ELSE '''''''' END
							+ '''' between '''' + CAST(a.ActiveStartTime AS nvarchar) + '''' and '''' + CAST(a.ActiveEndTime AS nvarchar)
					END
					+ CASE
						WHEN (a.FreqType IN (4, 8, 16, 32)) THEN ''''. Schedule will be used ''''
							+ CASE
								WHEN (a.ActiveEndDate = CAST(''''9999-12-31'''' AS date)) THEN ''''starting on '''' + CAST(a.ActiveStartDate AS nvarchar)
								ELSE ''''between '''' + CAST(a.ActiveStartDate AS nvarchar) + '''' and '''' + CAST(a.ActiveEndDate AS nvarchar)
							END
						ELSE ''''''''
					END
					AS TotalDesc,
					a.Timestamp
				FROM (
			'';
			SET @stmt += ''
					SELECT
						aj.JobName
						,CAST(aj.JobEnabled AS bit)				AS JobEnabled
						,CAST(aj.ScheduleEnabled AS bit)		AS ScheduleEnabled
						,aj.FreqType
						,aj.FreqInterval
						,aj.FreqSubdayType
						,aj.FreqSubdayInterval
						,aj.FreqRelativeInterval
						,aj.FreqRecurrenceFactor

						,CONVERT(
							date,
								CAST(aj.ActiveStartDate / 10000 AS nvarchar)
								+ ''''-'''' + CAST((aj.ActiveStartDate / 100) % 100 AS nvarchar)
								+ ''''-'''' + CAST((aj.ActiveStartDate % 100) AS nvarchar),
							102
						)										AS ActiveStartDate
						,CONVERT(
							date,
								CAST(aj.ActiveEndDate / 10000 AS nvarchar)
								+ ''''-'''' + CAST((aj.ActiveEndDate / 100) % 100 AS nvarchar)
								+ ''''-'''' + CAST((aj.ActiveEndDate % 100) AS nvarchar),
							102
						)										AS ActiveEndDate
						,CONVERT(
							time(0),
								CAST(aj.ActiveStartTime / 10000 AS nvarchar)
								+ '''':'''' + CAST((aj.ActiveStartTime / 100) % 100 AS nvarchar)
								+ '''':'''' + CAST((aj.ActiveStartTime % 100) AS nvarchar),
							108
						)										AS ActiveStartTime
						,CONVERT(
							time(0),
								CAST(aj.ActiveEndTime / 10000 AS nvarchar)
								+ '''':'''' + CAST((aj.ActiveEndTime / 100) % 100 AS nvarchar)
								+ '''':'''' + CAST((aj.ActiveEndTime % 100) AS nvarchar),
							108
						)										AS ActiveEndTime
						,aj.Timestamp
					FROM dbo.fhsmAgentJobs AS aj
					WHERE (aj.TimestampUTC = (
						SELECT TOP (1) aj2.TimestampUTC
						FROM dbo.fhsmAgentJobs AS aj2
						ORDER BY aj2.TimestampUTC DESC
					))
				) AS a
				WHERE (1 = 1)
					AND (a.FreqType NOT IN (4, 8))
					AND (CAST(GETDATE() AS date) <= a.ActiveEndDate)
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Agent jobs - list]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs - list'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPAgentJobs
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPAgentJobs'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPAgentJobs AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPAgentJobs (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;
			'';
			SET @stmt += ''

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						INSERT INTO dbo.fhsmAgentJobs(
							JobName, JobId, JobEnabled, JobDescription
							,ScheduleName, ScheduleId, ScheduleEnabled
							,FreqType, FreqInterval, FreqSubdayType, FreqSubdayInterval, FreqRelativeInterval, FreqRecurrenceFactor
							,ActiveStartDate, ActiveEndDate, ActiveStartTime, ActiveEndTime
							,NextRunDate, NextRunTime
							,TimestampUTC, Timestamp
						)
						SELECT
							sj.name						AS JobName
							,sj.job_id					AS JobId
							,sj.enabled					AS JobEnabled
							,sj.description				AS JobDescription
							,s.name						AS ScheduleName
							,s.schedule_id				AS ScheduleId
							,s.enabled					AS ScheduleEnabled
							,s.freq_type				AS FreqType
							,s.freq_interval			AS FreqInterval
							,s.freq_subday_type			AS FreqSubdayType
							,s.freq_subday_interval		AS FreqSubdayInterval
							,s.freq_relative_interval	AS FreqRelativeInterval
							,s.freq_recurrence_factor	AS FreqRecurrenceFactor
							,s.active_start_date		AS ActiveStartDate
							,s.active_end_date			AS ActiveEndDate
							,s.active_start_time		AS ActiveStartTime
							,s.active_end_time			AS ActiveEndTime
							,js.next_run_date			AS NextRunDate
							,js.next_run_time			AS NextRunTime
							,@nowUTC, @now
						FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
						LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK) ON (js.job_id = sj.job_id)
						LEFT OUTER JOIN msdb.dbo.sysschedules AS s WITH (NOLOCK) ON (js.schedule_id = s.schedule_id)
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPAgentJobs
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPAgentJobs'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmAgentJobs''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableAgentJobs								AS Enabled
				,0												AS DeploymentStatus
				,''Agent jobs''									AS Name
				,PARSENAME(''dbo.fhsmSPAgentJobs'', 1)			AS Task
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T06:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T07:00:00.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmAgentJobs'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:AgentJobsPerformance.sql modified: 2025.08.05 19.07.30
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableAgentJobsPerformance bit;

	SET @enableAgentJobsPerformance = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing AgentJobsPerformance'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables and indexes
	--
	BEGIN
		--
		-- Create table dbo.fhsmAgentJobsPerformance and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentJobsPerformance'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentJobsPerformance'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentJobsPerformance(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,JobStatus int NOT NULL
						,StepsStatus int NOT NULL
						,Date date NOT NULL
						,Hour tinyint NOT NULL
						,Cnt smallint NOT NULL
						,SumDurationSeconds int NOT NULL
						,MinDurationSeconds int NOT NULL
						,MaxDurationSeconds int NOT NULL
						,CONSTRAINT PK_fhsmAgentJobsPerformance PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformance'')) AND (i.name = ''NC_fhsmAgentJobsPerformance_Date_Name''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformance_Date_Name] to table dbo.fhsmAgentJobsPerformance'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformance_Date_Name ON dbo.fhsmAgentJobsPerformance(Date, Name)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformance'')) AND (i.name = ''NC_fhsmAgentJobsPerformance_Name_Date''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformance_Name_Date] to table dbo.fhsmAgentJobsPerformance'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformance_Name_Date ON dbo.fhsmAgentJobsPerformance(Name, Date)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentJobsPerformance
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentJobsPerformance'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmAgentJobsPerformanceDelta and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDelta'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentJobsPerformanceDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentJobsPerformanceDelta(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,JobStatus int NOT NULL
						,StepsStatus int NOT NULL
						,StartDateTime datetime NOT NULL
						,DurationSeconds int NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmAgentJobsPerformanceDelta PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDelta'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceDelta_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceDelta_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceDelta_TimestampUTC ON dbo.fhsmAgentJobsPerformanceDelta(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDelta'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceDelta_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceDelta_Timestamp] to table dbo.fhsmAgentJobsPerformanceDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceDelta_Timestamp ON dbo.fhsmAgentJobsPerformanceDelta(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDelta'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceDelta_Name_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceDelta_Name_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceDelta_Name_TimestampUTC ON dbo.fhsmAgentJobsPerformanceDelta(Name, TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentJobsPerformanceDelta
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentJobsPerformanceDelta'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmAgentJobsPerformanceDeltaTemp and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDeltaTemp'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentJobsPerformanceDeltaTemp'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentJobsPerformanceDeltaTemp(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,JobStatus int NOT NULL
						,StartDateTime datetime NOT NULL
						,DurationSeconds int NOT NULL
						,JobId uniqueidentifier NOT NULL
						,InstanceId int NOT NULL
						,PrevInstanceId int NULL
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDeltaTemp'')) AND (i.name = ''CL_fhsmAgentJobsPerformanceDeltaTemp''))
			BEGIN
				RAISERROR(''Adding index [CL_fhsmAgentJobsPerformanceDeltaTemp] to table dbo.fhsmAgentJobsPerformanceDeltaTemp'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE CLUSTERED INDEX CL_fhsmAgentJobsPerformanceDeltaTemp ON dbo.fhsmAgentJobsPerformanceDeltaTemp(JobId)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceDeltaTemp'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceDeltaTemp_Id''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceDeltaTemp_Id] to table dbo.fhsmAgentJobsPerformanceDeltaTemp'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE UNIQUE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceDeltaTemp_Id ON dbo.fhsmAgentJobsPerformanceDeltaTemp(Id)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentJobsPerformanceDeltaTemp
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentJobsPerformanceDeltaTemp'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmAgentJobsPerformanceLatest and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatest'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentJobsPerformanceLatest'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentJobsPerformanceLatest(
						Id bigint identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,JobStatus int NOT NULL
						,StepsStatus int NOT NULL
						,StartDateTime datetime NOT NULL
						,DurationSeconds int NOT NULL
						,Aggregated bit NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmAgentJobsPerformanceLatest PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatest'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceLatest_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceLatest_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceLatest'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceLatest_TimestampUTC ON dbo.fhsmAgentJobsPerformanceLatest(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatest'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceLatest_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceLatest_Timestamp] to table dbo.fhsmAgentJobsPerformanceLatest'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceLatest_Timestamp ON dbo.fhsmAgentJobsPerformanceLatest(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatest'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceLatest_Name_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceLatest_Name_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceLatest'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceLatest_Name_TimestampUTC ON dbo.fhsmAgentJobsPerformanceLatest(Name, TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentJobsPerformanceLatest
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentJobsPerformanceLatest'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmAgentJobsPerformanceErrorDelta and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentJobsPerformanceErrorDelta'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentJobsPerformanceErrorDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentJobsPerformanceErrorDelta(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,StepId int NOT NULL
						,StepName nvarchar(128) NOT NULL
						,RunStatus int NOT NULL
						,StartDateTime datetime NOT NULL
						,DurationSeconds int NOT NULL
						,JobDurationSeconds int NULL
						,MessageId int NULL
						,Severity int NULL
						,Message nvarchar(4000) NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmAgentJobsPerformanceErrorDelta PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceErrorDelta'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceErrorDelta_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceErrorDelta_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceErrorDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceErrorDelta_TimestampUTC ON dbo.fhsmAgentJobsPerformanceErrorDelta(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceErrorDelta'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceErrorDelta_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceErrorDelta_Timestamp] to table dbo.fhsmAgentJobsPerformanceErrorDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceErrorDelta_Timestamp ON dbo.fhsmAgentJobsPerformanceErrorDelta(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceErrorDelta'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceErrorDelta_Name_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceErrorDelta_Name_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceErrorDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceErrorDelta_Name_TimestampUTC ON dbo.fhsmAgentJobsPerformanceErrorDelta(Name, TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentJobsPerformanceErrorDelta
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentJobsPerformanceErrorDelta'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmAgentJobsPerformanceLatestError and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatestError'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentJobsPerformanceLatestError'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentJobsPerformanceLatestError(
						Id int identity(1,1) NOT NULL
						,Name nvarchar(128) NOT NULL
						,StepId int NOT NULL
						,StepName nvarchar(128) NOT NULL
						,RunStatus int NOT NULL
						,StartDateTime datetime NOT NULL
						,DurationSeconds int NOT NULL
						,JobDurationSeconds int NULL
						,MessageId int NULL
						,Severity int NULL
						,Message nvarchar(4000) NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmAgentJobsPerformanceLatestError PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatestError'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceLatestError_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceLatestError_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceLatestError'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceLatestError_TimestampUTC ON dbo.fhsmAgentJobsPerformanceLatestError(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatestError'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceLatestError_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceLatestError_Timestamp] to table dbo.fhsmAgentJobsPerformanceLatestError'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceLatestError_Timestamp ON dbo.fhsmAgentJobsPerformanceLatestError(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentJobsPerformanceLatestError'')) AND (i.name = ''NC_fhsmAgentJobsPerformanceLatestError_Name_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentJobsPerformanceLatestError_Name_TimestampUTC] to table dbo.fhsmAgentJobsPerformanceLatestError'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentJobsPerformanceLatestError_Name_TimestampUTC ON dbo.fhsmAgentJobsPerformanceLatestError(Name, TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentJobsPerformanceLatestError
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentJobsPerformanceLatestError'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Add indexes to msdb.dbo.sysjobhistory if they if they not already exists
		--
		BEGIN
			--
			-- Test if index on msdb.dbo.sysjobhistory with index columns [job_id] and [step_id] exists
			--
			IF NOT EXISTS (
				SELECT *
				FROM msdb.sys.indexes AS i
				WHERE (i.object_id = OBJECT_ID(''msdb.dbo.sysjobhistory''))
					AND EXISTS (	-- Test for [job_id] AS index column #1
						SELECT *
						FROM msdb.sys.index_columns AS ic
						INNER JOIN msdb.sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
						WHERE (1 = 1)
							AND (ic.object_id = i.object_id)
							AND (ic.index_id = i.index_id)
							AND (ic.index_column_id = 1)
							AND (ic.is_included_column = 0)
							AND (c.name = ''job_id'')
					)
					AND EXISTS (	-- Test for [step_id] AS index column #2
						SELECT *
						FROM msdb.sys.index_columns AS ic
						INNER JOIN msdb.sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
						WHERE (1 = 1)
							AND (ic.object_id = i.object_id)
							AND (ic.index_id = i.index_id)
							AND (ic.index_column_id = 2)
							AND (ic.is_included_column = 0)
							AND (c.name = ''step_id'')
					)
			)
			BEGIN
				RAISERROR(''Adding index [NC_sysjobhistory_job_id_step_id] to table msdb.dbo.sysjobhistory'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					USE [msdb];
					CREATE NONCLUSTERED INDEX NC_sysjobhistory_job_id_step_id ON dbo.sysjobhistory(job_id, step_id)
					INCLUDE(run_status, run_date, run_time, run_duration)
					'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Test if index on msdb.dbo.sysjobhistory with index columns [job_id], [instance_id] and [run_status] exists
			--
			IF NOT EXISTS (
				SELECT *
				FROM msdb.sys.indexes AS i
				WHERE (i.object_id = OBJECT_ID(''msdb.dbo.sysjobhistory''))
					AND EXISTS (	-- Test for [job_id] AS index column #1
						SELECT *
						FROM msdb.sys.index_columns AS ic
						INNER JOIN msdb.sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
						WHERE (1 = 1)
							AND (ic.object_id = i.object_id)
							AND (ic.index_id = i.index_id)
							AND (ic.index_column_id = 1)
							AND (ic.is_included_column = 0)
							AND (c.name = ''job_id'')
					)
					AND EXISTS (	-- Test for [instance_id] AS index column #2
						SELECT *
						FROM msdb.sys.index_columns AS ic
						INNER JOIN msdb.sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
						WHERE (1 = 1)
							AND (ic.object_id = i.object_id)
							AND (ic.index_id = i.index_id)
							AND (ic.index_column_id = 2)
							AND (ic.is_included_column = 0)
							AND (c.name = ''instance_id'')
					)
					AND EXISTS (	-- Test for [run_status] AS index column #3
						SELECT *
						FROM msdb.sys.index_columns AS ic
						INNER JOIN msdb.sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
						WHERE (1 = 1)
							AND (ic.object_id = i.object_id)
							AND (ic.index_id = i.index_id)
							AND (ic.index_column_id = 3)
							AND (ic.is_included_column = 0)
							AND (c.name = ''run_status'')
					)
			)
			BEGIN
				RAISERROR(''Adding index [NC_sysjobhistory_job_id_instance_id_run_status] to table msdb.dbo.sysjobhistory'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					USE [msdb];
					CREATE NONCLUSTERED INDEX NC_sysjobhistory_job_id_instance_id_run_status ON dbo.sysjobhistory(job_id, instance_id, run_status)
					'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Agent jobs performance]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs performance'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs performance'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs performance'') + ''
				AS
				SELECT
					ajp.Date
					,ajp.Cnt
					,ajp.SumDurationSeconds
					,ajp.MinDurationSeconds
					,ajp.MaxDurationSeconds
					,(ajp.Hour * 60 * 60) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ajp.Name, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AgentJobKey
					,CAST(
						CASE
							WHEN (ajp.JobStatus = 1) AND (ajp.StepsStatus = 0)	THEN 1	-- Ended with errors
							WHEN (ajp.JobStatus = 1)							THEN 0	-- Succeeded
							WHEN (ajp.JobStatus = 0)							THEN 2	-- Failed
							WHEN (ajp.JobStatus = 2)							THEN 3	-- Retry
							WHEN (ajp.JobStatus = 3)							THEN 4	-- Canceled
							WHEN (ajp.JobStatus = 4)							THEN 5	-- In progress
							WHEN (ajp.JobStatus = -1)							THEN 99	-- Missing data
						END
					AS bigint) AS AgentJobStatsusKey
				FROM dbo.fhsmAgentJobsPerformance AS ajp;
			'';
			EXEC(@stmt);
		END;

		--
		-- Create fact view @pbiSchema.[Agent jobs performance errors]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs performance errors'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs performance errors'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs performance errors'') + ''
				AS
				SELECT
					ajpe.StepId
					,ajpe.StepName
					,ajpe.DurationSeconds
					,ajpe.JobDurationSeconds
					,ajpe.MessageId
					,ajpe.Severity
					,ajpe.Message
					,ajpe.StartDateTime
					,CAST(ajpe.StartDateTime AS date) AS Date
					,(DATEPART(HOUR, ajpe.StartDateTime) * 60 * 60) + (DATEPART(MINUTE, ajpe.StartDateTime) * 60) + (DATEPART(SECOND, ajpe.StartDateTime)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ajpe.Name, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS AgentJobKey
					,CAST(
						CASE
							WHEN (ajpe.RunStatus = 0)	THEN 2	-- Failed
							WHEN (ajpe.RunStatus = 2)	THEN 3	-- Retry
							WHEN (ajpe.RunStatus = 3)	THEN 4	-- Canceled
							WHEN (ajpe.RunStatus = 4)	THEN 5	-- In progress
						END
					AS bigint) AS AgentJobStatsusKey
				FROM dbo.fhsmAgentJobsPerformanceLatestError AS ajpe
			'';
			EXEC(@stmt);
		END;

		--
		-- Create fact view @pbiSchema.[Agent job status]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent job status'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent job status'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent job status'') + ''
				AS
				SELECT
					s.Status
					,s.SortOrder
					,CAST(s.StatusVal AS bigint) AS AgentJobStatsusKey
				FROM (
					VALUES
						( 0, ''''Succeeded'''',         0),
						( 1, ''''Ended with errors'''', 1),
						( 2, ''''Failed'''',            2),
						( 3, ''''Retry'''',             3),
						( 4, ''''Canceled'''',          4),
						( 5, ''''In progress'''',       5),
						(99, ''''Missing data'''',      6)
				) AS s(StatusVal, Status, SortOrder);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Agent job status]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent job status'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPAgentJobsPerformance
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPAgentJobsPerformance'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPAgentJobsPerformance AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPAgentJobsPerformance (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @jobName nvarchar(128);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterStmt nvarchar(max);
					DECLARE @productEndPos int;
					DECLARE @productStartPos int;
					DECLARE @productVersion nvarchar(128);
					DECLARE @productVersion1 int;
					DECLARE @productVersion2 int;
					DECLARE @productVersion3 int;
					DECLARE @startDateTime datetime;
					DECLARE @startDateTimeTxt nvarchar(32);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);
					DECLARE @whereStmt nvarchar(max);
					DECLARE @whereStmt1 nvarchar(max);
					DECLARE @whereStmt2 nvarchar(max);
					DECLARE @whereStmtError nvarchar(max);
					DECLARE @whereStmtError1 nvarchar(max);
					DECLARE @whereStmtError2 nvarchar(max);

					--
					-- Initialize variables
					--
					BEGIN
						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						SET @productVersion = CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar);
						SET @productStartPos = 1;
						SET @productEndPos = CHARINDEX(''''.'''', @productVersion, @productStartPos);
						SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
						SET @productStartPos = @productEndPos + 1;
						SET @productEndPos = CHARINDEX(''''.'''', @productVersion, @productStartPos);
						SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
						SET @productStartPos = @productEndPos + 1;
						SET @productEndPos = CHARINDEX(''''.'''', @productVersion, @productStartPos);
						SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
					END;

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						SET @parameterStmt = '''''''';

						IF (@parameter IS NOT NULL)
						BEGIN
							SET @parameterStmt = ''''AND '''' + @parameter;
						END;
					END;
			'';
			SET @stmt += ''
					--
					-- Create where condition to load latest and newest per job
					--
					BEGIN
						DECLARE jCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT
							jpl.Name AS JobName,
							MAX(jpl.StartDateTime) AS StartDateTime
						FROM dbo.fhsmAgentJobsPerformanceLatest AS jpl
						GROUP BY jpl.Name
						ORDER BY jpl.Name;

						OPEN jCur;

						SET @whereStmt1 = '''''''';
						SET @whereStmt2 = '''''''';

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM jCur
							INTO @jobName, @startDateTime;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							SET @startDateTimeTxt = CONVERT(nvarchar, @startDateTime, 126);

							IF (@whereStmt1 <> '''''''')
							BEGIN
								SET @whereStmt1 += ''''OR '''';
							END;
							SET @whereStmt1 += ''''((sj.name = '''''''''''' + @jobName + '''''''''''') AND (ajt.StartDateTime >= '''''''''''' + @startDateTimeTxt + ''''''''''''))'''' + CHAR(13);;

							IF (@whereStmt2 <> '''''''')
							BEGIN
								SET @whereStmt2 += '''', '''';
							END;
							SET @whereStmt2 += '''''''''''''''' + @jobName + '''''''''''''''';
						END;

						CLOSE jCur;
						DEALLOCATE jCur;

						IF (@whereStmt1 = '''''''')
						BEGIN
							SET @whereStmt = '''''''';
						END
						ELSE BEGIN
							SET @whereStmt = ''''
								AND (
									('''' + @whereStmt1 + '''')
									OR (sj.name NOT IN ('''' + @whereStmt2 + ''''))
								);
							'''';
						END;
					END;
			'';
			SET @stmt += ''
					--
					-- Create where condition to load latest and newest errors per job
					--
					BEGIN
						DECLARE jCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT
							jple.Name AS JobName,
							MAX(jple.StartDateTime) AS StartDateTime
						FROM dbo.fhsmAgentJobsPerformanceLatestError AS jple
						GROUP BY jple.Name
						ORDER BY jple.Name;

						OPEN jCur;

						SET @whereStmtError1 = '''''''';
						SET @whereStmtError2 = '''''''';

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM jCur
							INTO @jobName, @startDateTime;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							SET @startDateTimeTxt = CONVERT(nvarchar, @startDateTime, 126);

							IF (@whereStmtError1 <> '''''''')
							BEGIN
								SET @whereStmtError1 += ''''OR '''';
							END;
							SET @whereStmtError1 += ''''((sj.name = '''''''''''' + @jobName + '''''''''''') AND (ajt.StartDateTime > '''''''''''' + @startDateTimeTxt + ''''''''''''))'''' + CHAR(13);;

							IF (@whereStmtError2 <> '''''''')
							BEGIN
								SET @whereStmtError2 += '''', '''';
							END;
							SET @whereStmtError2 += '''''''''''''''' + @jobName + '''''''''''''''';
						END;

						CLOSE jCur;
						DEALLOCATE jCur;

						IF (@whereStmtError1 = '''''''')
						BEGIN
							SET @whereStmtError = '''''''';
						END
						ELSE BEGIN
							SET @whereStmtError = ''''
								AND (
									('''' + @whereStmtError1 + '''')
									OR (sj.name NOT IN ('''' + @whereStmtError2 + ''''))
								);
							'''';
						END;
					END;
			'';
			SET @stmt += ''
					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						--
						-- Collect data into temp table
						--
						SET @stmt = ''''
							TRUNCATE TABLE dbo.fhsmAgentJobsPerformanceDeltaTemp;
						'''';
						IF (@productVersion1 <= 10)
						BEGIN
							-- SQL Versions SQL2008R2 or lower

							SET @stmt += ''''
							WITH
							jrn AS (
								SELECT
									sj.name
									,sjh.job_id
									,sjh.instance_id
									,sjh.run_date
									,sjh.run_time
									,sjh.run_duration
									,sjh.run_status
									,ROW_NUMBER() OVER(PARTITION BY sjh.job_id ORDER BY sjh.instance_id) AS JobRunNumber
								FROM msdb.dbo.sysjobs AS sj
								INNER JOIN msdb.dbo.sysjobhistory AS sjh ON (sjh.job_id =  sj.job_id)
								WHERE (1 = 1)
									AND (sjh.step_id = 0)
							)
							'''';
						END;
			'';
			SET @stmt += ''
						SET @stmt += ''''
							INSERT INTO dbo.fhsmAgentJobsPerformanceDeltaTemp(Name, JobStatus, StartDateTime, DurationSeconds, JobId, InstanceId, PrevInstanceId)
							SELECT
								sj.name AS Name
								,sj.run_status AS JobStatus
								,ajt.StartDateTime
								,CASE WHEN (ajt.DurationSeconds = 0) THEN 1 ELSE ajt.DurationSeconds END AS DurationSeconds
								,sj.job_id AS JobId
								,sj.instance_id AS InstanceId
								,sj.PrevInstanceId AS PrevInstanceId
							FROM (
						'''';
						IF (@productVersion1 <= 10)
						BEGIN
							-- SQL Versions SQL2008R2 or lower

							SET @stmt += ''''
								SELECT
									jrn.name
									,jrn.job_id
									,jrn.instance_id
									,jrn.run_date
									,jrn.run_time
									,jrn.run_duration
									,jrn.run_status
									,COALESCE(prevJRN.instance_id, 0) AS PrevInstanceId
								FROM jrn
								LEFT OUTER JOIN jrn AS prevJRN ON
									(prevJRN.job_id = jrn.job_id)
									AND (prevJRN.JobRunNumber = jrn.JobRunNumber - 1)
							'''';
						END
						ELSE BEGIN
							-- SQL Versions SQL2012 or higher

							SET @stmt += ''''
								SELECT
									jrn.name
									,jrn.job_id
									,jrn.instance_id
									,jrn.run_date
									,jrn.run_time
									,jrn.run_duration
									,jrn.run_status
									,LAG(jrn.instance_id, 1, 0) OVER(PARTITION BY jrn.job_id ORDER BY jrn.JobRunNumber) AS PrevInstanceId
								FROM (
									SELECT
										sj.name
										,sjh.job_id
										,sjh.instance_id
										,sjh.run_date
										,sjh.run_time
										,sjh.run_duration
										,sjh.run_status
										,ROW_NUMBER() OVER(PARTITION BY sjh.job_id ORDER BY sjh.instance_id) AS JobRunNumber
									FROM msdb.dbo.sysjobs AS sj
									INNER JOIN msdb.dbo.sysjobhistory AS sjh ON (sjh.job_id =  sj.job_id)
									WHERE (1 = 1)
										AND (sjh.step_id = 0)
								) AS jrn
							'''';
						END;
			'';
			SET @stmt += ''
						SET @stmt += ''''
							) AS sj
							CROSS APPLY dbo.fhsmFNAgentJobTime(sj.run_date, sj.run_time, sj.run_duration) AS ajt
							WHERE (1 = 1)
								'''' + @whereStmt + '''';
						'''';
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now
							,@nowUTC = @nowUTC;
			'';
			SET @stmt += ''
						--
						-- Move temp data into data
						--
						SET @stmt = ''''
							TRUNCATE TABLE dbo.fhsmAgentJobsPerformanceDelta;
						'''';

						SET @stmt += ''''
							INSERT INTO dbo.fhsmAgentJobsPerformanceDelta(Name, JobStatus, StepsStatus, StartDateTime, DurationSeconds, TimestampUTC, Timestamp)
							SELECT
								sj.Name
								,sj.JobStatus
								,COALESCE(jobStepError.MinRunStatus, 1) AS StepsStatus
								,sj.StartDateTime
								,sj.DurationSeconds
								,@nowUTC
								,@now
							FROM dbo.fhsmAgentJobsPerformanceDeltaTemp AS sj
							OUTER APPLY (
								SELECT MIN(sjh.run_status) AS MinRunStatus
								FROM msdb.dbo.sysjobhistory AS sjh
								WHERE
									(sjh.run_status <> 1)
									AND (sjh.job_id = sj.JobId)
									AND (sjh.instance_id <= sj.InstanceId)
									AND (sjh.instance_id > sj.PrevInstanceId)
							) AS jobStepError;
						'''';
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now
							,@nowUTC = @nowUTC;
			'';
			SET @stmt += ''
						SET @stmt = ''''
							TRUNCATE TABLE dbo.fhsmAgentJobsPerformanceErrorDelta;

							INSERT INTO dbo.fhsmAgentJobsPerformanceErrorDelta(Name, StepId, StepName, RunStatus, StartDateTime, DurationSeconds, JobDurationSeconds, MessageId, Severity, Message, TimestampUTC, Timestamp)
							SELECT
								sj.name AS Name
								,sjh.step_id AS StepId
								,sjh.step_name AS StepName
								,sjh.[run_status] AS RunStatus
								,ajt.StartDateTime
								,ajt.DurationSeconds
								,job.run_duration AS JobDurationSeconds
								,sjh.sql_message_id AS MessageId
								,sjh.sql_severity AS Severity
								,sjh.message AS Message
								,@nowUTC
								,@now
							FROM msdb.dbo.sysjobs AS sj
							INNER JOIN msdb.dbo.sysjobhistory AS sjh ON (sj.job_id = sjh.job_id)
							CROSS APPLY dbo.fhsmFNAgentJobTime(sjh.run_date, sjh.run_time, sjh.run_duration) AS ajt
							CROSS APPLY (
								SELECT TOP 1 job.run_duration
								FROM msdb.dbo.sysjobhistory AS job
								CROSS APPLY dbo.fhsmFNAgentJobTime(job.run_date, job.run_time, job.run_duration) AS ajtParent
								WHERE (job.job_id = sj.job_id) AND (job.step_id = 0) AND (ajtParent.StartDateTime <= ajt.StartDateTime)
								ORDER BY ajtParent.StartDateTime DESC
							) AS job
							WHERE (1 = 1)
								AND (sjh.run_status <> 1)
								AND (sjh.step_id <> 0)
								'''' + @parameterStmt + ''''
								'''' + @whereStmtError + '''';
						'''';
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now
							,@nowUTC = @nowUTC;
					END;
			'';
			SET @stmt += ''
					--
					-- Check if the newest record (Rnk = 1) in dbo.fhsmAgentJobsPerformanceLatest exists in dbo.fhsmAgentJobsPerformanceDelta
					-- If not we are running to slow, or the SQL Server agent must have its Histiry settings changed
					-- We will only record one per hour bucket
					--
					BEGIN
						INSERT INTO dbo.fhsmAgentJobsPerformanceLatest(Name, JobStatus, StepsStatus, StartDateTime, DurationSeconds, Aggregated, TimestampUTC, Timestamp)
						SELECT a.Name, -1 AS JobStatus, -1 AS StepsStatus, a.StartDateTime, 0 AS DurationSeconds, 0 AS Aggregated, @nowUTC, @now
						FROM (
							SELECT
								jpl.Name,
								jpl.StartDateTime,
								ROW_NUMBER() OVER(PARTITION BY jpl.Name ORDER BY jpl.StartDateTime DESC) AS Rnk
							FROM dbo.fhsmAgentJobsPerformanceLatest AS jpl
						) AS a
						WHERE (a.Rnk = 1)
							AND NOT EXISTS (
								SELECT *
								FROM dbo.fhsmAgentJobsPerformanceDelta AS jpd
								WHERE (jpd.Name = a.Name) AND (jpd.StartDateTime = a.StartDateTime)
							)
							AND NOT EXISTS (
								SELECT *
								FROM dbo.fhsmAgentJobsPerformance AS jp
								WHERE (jp.JobStatus = -1) AND (jp.StepsStatus = -1) AND (jp.Name = a.Name) AND (jp.Date = CAST(a.StartDateTime AS date)) AND (jp.Hour = DATEPART(HOUR, a.StartDateTime))
							);
					END;
			'';
			SET @stmt += ''
					--
					-- Load newest records in the dbo.fhsmAgentJobsPerformanceLatest table and with Aggregated set to 0
					--
					BEGIN
						INSERT INTO dbo.fhsmAgentJobsPerformanceLatest(Name, JobStatus, StepsStatus, StartDateTime, DurationSeconds, Aggregated, TimestampUTC, Timestamp)
						SELECT Name, JobStatus, StepsStatus, StartDateTime, DurationSeconds, 0 AS Aggregated, TimestampUTC, Timestamp
						FROM dbo.fhsmAgentJobsPerformanceDelta AS jpd
						WHERE NOT EXISTS (
							SELECT *
							FROM dbo.fhsmAgentJobsPerformanceLatest AS jpl
							WHERE (jpl.Name = jpd.Name) AND (jpl.StartDateTime = jpd.StartDateTime)
						);
					END;
			'';
			SET @stmt += ''
					--
					-- Aggregate data into buckets
					--
					BEGIN
						MERGE dbo.fhsmAgentJobsPerformance AS tgt
						USING (
							SELECT
								jpl.Name,
								jpl.JobStatus,
								jpl.StepsStatus,
								CAST(jpl.StartDateTime AS date) AS Date,
								DATEPART(HOUR, jpl.StartDateTime) AS Hour,
								COUNT(*) AS Cnt,
								SUM(jpl.DurationSeconds) AS SumDurationSeconds,
								MIN(jpl.DurationSeconds) AS MinDurationSeconds,
								MAX(jpl.DurationSeconds) AS MaxDurationSeconds
							FROM dbo.fhsmAgentJobsPerformanceLatest AS jpl
							WHERE (jpl.Aggregated = 0)
							GROUP BY
								jpl.Name,
								jpl.JobStatus,
								jpl.StepsStatus,
								CAST(jpl.StartDateTime AS date),
								DATEPART(HOUR, jpl.StartDateTime)
						) AS src
						ON (src.Name = tgt.Name) AND (src.JobStatus = tgt.JobStatus) AND (src.StepsStatus = tgt.StepsStatus) AND (src.Date = tgt.Date) AND (src.Hour = tgt.Hour)
						WHEN MATCHED
							THEN
							UPDATE
							SET
								tgt.Cnt += src.Cnt,
								tgt.SumDurationSeconds += src.SumDurationSeconds,
								tgt.MinDurationSeconds = CASE WHEN (src.MinDurationSeconds < tgt.MinDurationSeconds) THEN src.MinDurationSeconds ELSE tgt.MinDurationSeconds END,
								tgt.MaxDurationSeconds = CASE WHEN (src.MaxDurationSeconds < tgt.MaxDurationSeconds) THEN src.MaxDurationSeconds ELSE tgt.MaxDurationSeconds END
						WHEN NOT MATCHED
							THEN
							INSERT(Name, JobStatus, StepsStatus, Date, Hour, Cnt, SumDurationSeconds, MinDurationSeconds, MaxDurationSeconds)
							VALUES(src.Name, src.JobStatus, src.StepsStatus, src.Date, src.Hour, src.Cnt, src.SumDurationSeconds, src.MinDurationSeconds, src.MaxDurationSeconds);
					END;
			'';
			SET @stmt += ''
					--
					-- Mark records as aggregated
					--
					BEGIN
						UPDATE jpl
						SET jpl.Aggregated = 1
						FROM dbo.fhsmAgentJobsPerformanceLatest AS jpl
						WHERE (jpl.Aggregated = 0);
					END;
			'';
			SET @stmt += ''
					--
					-- Delete older records (Rnk > 1) that are aggregated
					--
					BEGIN
						DELETE a
						FROM (
							SELECT
								ROW_NUMBER() OVER(PARTITION BY jpl.Name ORDER BY jpl.StartDateTime DESC) AS Rnk
							FROM dbo.fhsmAgentJobsPerformanceLatest AS jpl
							WHERE (jpl.Aggregated = 1)
						) AS a
						WHERE (a.Rnk > 1);
					END;
			'';
			SET @stmt += ''
					--
					-- Load newest error records in the dbo.fhsmAgentJobsPerformanceLatestError
					--
					BEGIN
						INSERT INTO dbo.fhsmAgentJobsPerformanceLatestError(Name, StepId, StepName, RunStatus, StartDateTime, DurationSeconds, JobDurationSeconds, MessageId, Severity, Message, TimestampUTC, Timestamp)
						SELECT Name, StepId, StepName, RunStatus, StartDateTime, DurationSeconds, JobDurationSeconds, MessageId, Severity, Message, TimestampUTC, Timestamp
						FROM dbo.fhsmAgentJobsPerformanceErrorDelta AS jped
						WHERE NOT EXISTS (
							SELECT *
							FROM dbo.fhsmAgentJobsPerformanceLatestError AS jple
							WHERE (jple.Name = jped.Name) AND (jple.StartDateTime = jped.StartDateTime)
						);
					END;
			'';
			SET @stmt += ''
					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPAgentJobs
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPAgentJobsPerformance'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlAgentJobsPerformance
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlAgentJobsPerformance'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlAgentJobsPerformance AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlAgentJobsPerformance (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Testing for NULL as a NULL parameter is allowed
								WHEN MATCHED AND ((tgt.Parameter <> src.Parameter) OR ((tgt.Parameter IS NULL) AND (src.Parameter IS NOT NULL)) OR ((tgt.Parameter IS NOT NULL) AND (src.Parameter IS NULL)))
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPControlAgentJobsPerformance
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPControlAgentJobsPerformance'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmAgentJobsPerformance''
				,1
				,''Date''
				,1
				,365
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmAgentJobsPerformanceLatestError''
				,1
				,''TimestampUTC''
				,1
				,365
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableAgentJobsPerformance						AS Enabled
				,0												AS DeploymentStatus
				,''Agent jobs performance''						AS Name
				,PARSENAME(''dbo.fhsmSPAgentJobsPerformance'', 1)	AS Task
				,10 * 60										AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
		) AS (
			SELECT
				''Agent job'' AS DimensionName
				,''AgentJobKey'' AS DimensionKey
				,''dbo.fhsmAgentJobsPerformance'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Date]'' AS SrcDateColumn
				,''src.[Name]'', NULL, NULL, NULL, NULL
				,''Job name'', NULL, NULL, NULL, NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.SrcColumn5 = src.SrcColumn5
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
				,tgt.OutputColumn5 = src.OutputColumn5
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4, src.SrcColumn5
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4, src.OutputColumn5
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmAgentJobsPerformance'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:AgeOfStatistics.sql modified: 2025.08.05 19.07.48
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableAgeOfStatistics bit;

	SET @enableAgeOfStatistics = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing StatisticsAge'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmStatisticsAge and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmStatisticsAge'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmStatisticsAge'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmStatisticsAge(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,IndexName nvarchar(128) NOT NULL
					,LastUpdated datetime2 NULL
					,Rows bigint NULL
					,RowsSampled bigint NULL
					,Steps int NULL
					,UnfilteredRows bigint NULL
					,ModificationCounter bigint NULL
					,PersistedSamplePercent float NULL
					,IsHypothetical bit NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmStatisticsAge PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmStatisticsAge'')) AND (i.name = ''NC_fhsmStatisticsAge_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmStatisticsAge_TimestampUTC] to table dbo.fhsmStatisticsAge'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmStatisticsAge_TimestampUTC ON dbo.fhsmStatisticsAge(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmStatisticsAge'')) AND (i.name = ''NC_fhsmStatisticsAge_Timestamp_LastUpdated''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmStatisticsAge_Timestamp_LastUpdated] to table dbo.fhsmStatisticsAge'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmStatisticsAge_Timestamp_LastUpdated ON dbo.fhsmStatisticsAge(Timestamp, LastUpdated) INCLUDE(DatabaseName, SchemaName, ObjectName, IndexName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmStatisticsAge'')) AND (i.name = ''NC_fhsmStatisticsAge_DatabaseName_SchemaName_ObjectName_IndexName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmStatisticsAge_DatabaseName_SchemaName_ObjectName_IndexName] to table dbo.fhsmStatisticsAge'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmStatisticsAge_DatabaseName_SchemaName_ObjectName_IndexName ON dbo.fhsmStatisticsAge(DatabaseName, SchemaName, ObjectName, IndexName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmStatisticsAge
		--
		BEGIN
			SET @objectName = ''dbo.fhsmStatisticsAge'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmStatisticsAgeIncremental and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmStatisticsAgeIncremental'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmStatisticsAgeIncremental'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmStatisticsAgeIncremental(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,IndexName nvarchar(128) NOT NULL
					,PartitionNumber int NOT NULL
					,LastUpdated datetime2 NULL
					,Rows bigint NULL
					,RowsSampled bigint NULL
					,Steps int NULL
					,UnfilteredRows bigint NULL
					,ModificationCounter bigint NULL
					,IsHypothetical bit NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmStatisticsAgeIncremental PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmStatisticsAgeIncremental'')) AND (i.name = ''NC_fhsmStatisticsAgeIncremental_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmStatisticsAgeIncremental_TimestampUTC] to table dbo.fhsmStatisticsAgeIncremental'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmStatisticsAgeIncremental_TimestampUTC ON dbo.fhsmStatisticsAgeIncremental(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmStatisticsAgeIncremental'')) AND (i.name = ''NC_fhsmStatisticsAgeIncremental_Timestamp_LastUpdated''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmStatisticsAgeIncremental_Timestamp_LastUpdated] to table dbo.fhsmStatisticsAgeIncremental'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmStatisticsAgeIncremental_Timestamp_LastUpdated ON dbo.fhsmStatisticsAgeIncremental(Timestamp, LastUpdated) INCLUDE(DatabaseName, SchemaName, ObjectName, IndexName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmStatisticsAgeIncremental'')) AND (i.name = ''NC_fhsmStatisticsAgeIncremental_DatabaseName_SchemaName_ObjectName_IndexName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmStatisticsAgeIncremental_DatabaseName_SchemaName_ObjectName_IndexName] to table dbo.fhsmStatisticsAgeIncremental'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmStatisticsAgeIncremental_DatabaseName_SchemaName_ObjectName_IndexName ON dbo.fhsmStatisticsAgeIncremental(DatabaseName, SchemaName, ObjectName, IndexName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmStatisticsAgeIncremental
		--
		BEGIN
			SET @objectName = ''dbo.fhsmStatisticsAgeIncremental'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Statistics age]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age'') + ''
				AS
				SELECT
					DATEDIFF(DAY, sa.LastUpdated, SYSDATETIME()) AS Age
					,sa.LastUpdated
					,sa.Rows
					,sa.RowsSampled
					,sa.Steps
					,sa.UnfilteredRows
					,sa.ModificationCounter
					,sa.PersistedSamplePercent
					,sa.IsHypothetical
					,CAST(sa.Timestamp AS date) AS Date
					,(DATEPART(HOUR, sa.Timestamp) * 60 * 60) + (DATEPART(MINUTE, sa.Timestamp) * 60) + (DATEPART(SECOND, sa.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, sa.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, sa.SchemaName, sa.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, sa.SchemaName, sa.ObjectName, sa.IndexName, DEFAULT, DEFAULT) AS k) AS IndexKey
				FROM dbo.fhsmStatisticsAge AS sa
				WHERE (sa.Timestamp = (SELECT MAX(sa2.Timestamp) FROM dbo.fhsmStatisticsAge AS sa2))
					AND (sa.LastUpdated IS NOT NULL);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Statistics age]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Statistics age detailed]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age detailed'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age detailed'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age detailed'') + ''
				AS
				SELECT
					DATEDIFF(DAY, sa.LastUpdated, sa.Timestamp) AS Age
					,sa.LastUpdated
					,sa.Rows
					,sa.RowsSampled
					,sa.Steps
					,sa.UnfilteredRows
					,sa.ModificationCounter
					,sa.PersistedSamplePercent
					,sa.Timestamp
					,CAST(sa.Timestamp AS date) AS Date
					,(DATEPART(HOUR, sa.Timestamp) * 60 * 60) + (DATEPART(MINUTE, sa.Timestamp) * 60) + (DATEPART(SECOND, sa.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, sa.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, sa.SchemaName, sa.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sa.DatabaseName, sa.SchemaName, sa.ObjectName, sa.IndexName, DEFAULT, DEFAULT) AS k) AS IndexKey
				FROM dbo.fhsmStatisticsAge AS sa
				WHERE (sa.LastUpdated IS NOT NULL);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Statistics age detailed]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age detailed'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Statistics age incremental]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age incremental'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age incremental'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age incremental'') + ''
				AS
				SELECT
					DATEDIFF(DAY, sai.LastUpdated, SYSDATETIME()) AS Age
					,sai.LastUpdated
					,sai.Rows
					,sai.RowsSampled
					,sai.Steps
					,sai.UnfilteredRows
					,sai.ModificationCounter
					,sai.IsHypothetical
					,sai.PartitionNumber
					,CAST(sai.Timestamp AS date) AS Date
					,(DATEPART(HOUR, sai.Timestamp) * 60 * 60) + (DATEPART(MINUTE, sai.Timestamp) * 60) + (DATEPART(SECOND, sai.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sai.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sai.DatabaseName, sai.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sai.DatabaseName, sai.SchemaName, sai.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sai.DatabaseName, sai.SchemaName, sai.ObjectName, sai.PartitionNumber, DEFAULT, DEFAULT) AS k) AS ObjectPartitionKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sai.DatabaseName, sai.SchemaName, sai.ObjectName, sai.IndexName, DEFAULT, DEFAULT) AS k) AS IndexKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(sai.DatabaseName, sai.SchemaName, sai.ObjectName, sai.IndexName, sai.PartitionNumber, DEFAULT) AS k) AS IndexPartitionKey
				FROM dbo.fhsmStatisticsAgeIncremental AS sai
				WHERE (sai.Timestamp = (SELECT MAX(sa2.Timestamp) FROM dbo.fhsmStatisticsAge AS sa2))
					AND (sai.LastUpdated IS NOT NULL);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Statistics age incremental]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Statistics age incremental'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPStatisticsAge
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPStatisticsAge'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPStatisticsAge AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPStatisticsAge (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;
					END;

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

					--
					-- Collect data
					--
					BEGIN
						--
						-- Test if persisted_sample_percent exists on dm_db_stats_properties
						--
						BEGIN
							DECLARE @persistedSamplePercentStmt nvarchar(max);

							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_db_stats_properties'''') AND (sc.name = ''''persisted_sample_percent'''')
							)
							BEGIN
								SET @persistedSamplePercentStmt = ''''ddsp.persisted_sample_percent'''';
							END
							ELSE BEGIN
								SET @persistedSamplePercentStmt = ''''NULL'''';
							END;
						END;

						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + ''''
									INSERT INTO '''' + QUOTENAME(DB_NAME()) + ''''.dbo.fhsmStatisticsAge(
										DatabaseName, SchemaName, ObjectName, IndexName
										,LastUpdated, Rows, RowsSampled, Steps
										,UnfilteredRows, ModificationCounter, PersistedSamplePercent, IsHypothetical
										,TimestampUTC, Timestamp
									)
									SELECT
										'''''''''''' + @database + '''''''''''' AS DatabaseName
										,sch.name AS SchemaName
										,o.name AS ObjectName
										,i.name AS IndexName
			'';
			IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''dm_db_stats_properties''))
			BEGIN
				SET @stmt += ''
										,ddsp.last_updated AS LastUpdated
										,ddsp.rows AS Rows
										,ddsp.rows_sampled AS RowsSampled
										,ddsp.steps AS Steps
										,ddsp.unfiltered_rows AS UnfilteredRows
										,ddsp.modification_counter AS ModificationCounter
										,'''' + @persistedSamplePercentStmt + '''' AS PersistedSamplePercent
				'';
			END;
			ELSE BEGIN
				SET @stmt += ''
										,STATS_DATE(i.object_id, i.index_id) AS LastUpdated
										,NULL AS Rows
										,NULL AS RowsSampled
										,NULL AS Steps
										,NULL AS UnfilteredRows
										,NULL AS ModificationCounter
										,NULL AS PersistedSamplePercent
				'';
			END;
			SET @stmt += ''
										,i.is_hypothetical AS IsHypothetical
										,@nowUTC
										,@now
									FROM sys.indexes AS i WITH (NOLOCK)
									INNER JOIN sys.objects AS o WITH (NOLOCK) ON (o.object_id = i.object_id)
									INNER JOIN sys.schemas AS sch WITH (NOLOCK) ON (sch.schema_id = o.schema_id)
			'';
			IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''dm_db_stats_properties''))
			BEGIN
				SET @stmt += ''
									CROSS APPLY sys.dm_db_stats_properties(o.object_id, i.index_id) AS ddsp
				'';
			END;
			SET @stmt += ''
									WHERE (o.type IN (''''''''U'''''''', ''''''''V'''''''')) AND (i.type <> 0);
								'''';
								BEGIN TRY
									EXEC sp_executesql
										@stmt
										,N''''@nowUTC datetime, @now datetime''''
										,@nowUTC = @nowUTC, @now = @now;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;

								IF EXISTS(
									SELECT *
									FROM master.sys.system_objects AS so
									WHERE (so.name = ''''dm_db_incremental_stats_properties'''')
								)
								BEGIN
									SET @stmt = ''''
										USE '''' + QUOTENAME(@database) + ''''
										INSERT INTO '''' + QUOTENAME(DB_NAME()) + ''''.dbo.fhsmStatisticsAgeIncremental(
											DatabaseName, SchemaName, ObjectName, IndexName, PartitionNumber
											,LastUpdated, Rows, RowsSampled, Steps
											,UnfilteredRows, ModificationCounter, IsHypothetical
											,TimestampUTC, Timestamp
										)
										SELECT
											'''''''''''' + @database + '''''''''''' AS DatabaseName
											,sch.name AS SchemaName
											,o.name AS ObjectName
											,i.name AS IndexName
											,ddsp.partition_number AS PartitionNumber
											,ddsp.last_updated AS LastUpdated
											,ddsp.rows AS Rows
											,ddsp.rows_sampled AS RowsSampled
											,ddsp.steps AS Steps
											,ddsp.unfiltered_rows AS UnfilteredRows
											,ddsp.modification_counter AS ModificationCounter
											,i.is_hypothetical AS IsHypothetical
											,@nowUTC
											,@now
										FROM sys.indexes AS i WITH (NOLOCK)
										INNER JOIN sys.objects AS o WITH (NOLOCK) ON (o.object_id = i.object_id)
										INNER JOIN sys.schemas AS sch WITH (NOLOCK) ON (sch.schema_id = o.schema_id)
										CROSS APPLY sys.dm_db_incremental_stats_properties(o.object_id, i.index_id) AS ddsp
										WHERE (o.type = ''''''''U'''''''') AND (i.type <> 0);
									'''';
									BEGIN TRY
										EXEC sp_executesql
											@stmt
											,N''''@nowUTC datetime, @now datetime''''
											,@nowUTC = @nowUTC, @now = @now;
									END TRY
									BEGIN CATCH
										SET @errorMsg = ERROR_MESSAGE();

										SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
									END CATCH;
								END;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPStatisticsAge
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPStatisticsAge'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlStatisticsAge
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlStatisticsAge'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlStatisticsAge AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlStatisticsAge (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlStatisticsAge
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlStatisticsAge'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmStatisticsAge''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmStatisticsAgeIncremental''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableAgeOfStatistics							AS Enabled
				,0												AS DeploymentStatus
				,''Age of statistics''							AS Name
				,PARSENAME(''dbo.fhsmSPStatisticsAge'', 1)		AS Task
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T06:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T07:00:00.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb''''''		AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmStatisticsAge'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE (src.Timestamp = (SELECT MAX(sa.Timestamp) FROM dbo.fhsmStatisticsAge AS sa))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmStatisticsAge'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE (src.Timestamp = (SELECT MAX(sa.Timestamp) FROM dbo.fhsmStatisticsAge AS sa))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL, NULL
				,''Database'', ''Schema'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmStatisticsAge'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE (src.Timestamp = (SELECT MAX(sa.Timestamp) FROM dbo.fhsmStatisticsAge AS sa))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL, NULL
				,''Database'', ''Schema'', ''Object'', NULL, NULL

			UNION ALL

			SELECT
				''Object partition'' AS DimensionName
				,''ObjectPartitionKey'' AS DimensionKey
				,''dbo.fhsmStatisticsAgeIncremental'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE (src.Timestamp = (SELECT MAX(sa.Timestamp) FROM dbo.fhsmStatisticsAge AS sa))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''CAST(src.[PartitionNumber] AS nvarchar)'', NULL
				,''Database'', ''Schema'', ''Object'', ''Partition'', NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmStatisticsAge'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE (src.Timestamp = (SELECT MAX(sa.Timestamp) FROM dbo.fhsmStatisticsAge AS sa))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''src.[IndexName]'', NULL
				,''Database'', ''Schema'', ''Object'', ''Index'', NULL

			UNION ALL

			SELECT
				''Index partition'' AS DimensionName
				,''IndexPartitionKey'' AS DimensionKey
				,''dbo.fhsmStatisticsAgeIncremental'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE (src.Timestamp = (SELECT MAX(sa.Timestamp) FROM dbo.fhsmStatisticsAge AS sa))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''src.[IndexName]'', ''CAST(src.[PartitionNumber] AS nvarchar)''
				,''Database'', ''Schema'', ''Object'', ''Index'', ''Partition''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.SrcColumn5 = src.SrcColumn5
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
				,tgt.OutputColumn5 = src.OutputColumn5
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4, src.SrcColumn5
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4, src.OutputColumn5
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmStatisticsAge'';
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmStatisticsAgeIncremental'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:BackupStatus.sql modified: 2025.08.05 19.08.03
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableBackupStatus bit;

	SET @enableBackupStatus = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing BackupStatus'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmBackupStatus and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmBackupStatus'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmBackupStatus'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmBackupStatus(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,BackupStartDate datetime NULL
					,BackupFinishDate datetime NULL
					,ExpirationDate datetime NULL
					,Type char(1) NULL
					,BackupSize numeric(20,0) NULL
					,CompressedBackupSize numeric(20,0) NULL
					,IsCopyOnly bit NOT NULL
					,IsDamaged bit NOT NULL
					,LogicalDeviceName nvarchar(128) NULL
					,PhysicalDeviceName nvarchar(260) NULL
					,BackupsetName nvarchar(128) NULL
					,BackupsetDescription nvarchar(128) NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_BackupStatus PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBackupStatus'')) AND (i.name = ''NC_fhsmBackupStatus_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmBackupStatus_TimestampUTC] to table dbo.fhsmBackupStatus'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmBackupStatus_TimestampUTC ON dbo.fhsmBackupStatus(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBackupStatus'')) AND (i.name = ''NC_fhsmBackupStatus_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmBackupStatus_Timestamp] to table dbo.fhsmBackupStatus'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmBackupStatus_Timestamp ON dbo.fhsmBackupStatus(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBackupStatus'')) AND (i.name = ''NC_fhsmBackupStatus_DatabaseName_BackupStartDate''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmBackupStatus_DatabaseName_BackupStartDate] to table dbo.fhsmBackupStatus'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmBackupStatus_DatabaseName_BackupStartDate ON dbo.fhsmBackupStatus(DatabaseName, BackupStartDate)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBackupStatus'')) AND (i.name = ''NC_fhsmBackupStatus_IsCopyOnly_IsDamaged''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmBackupStatus_IsCopyOnly_IsDamaged] to table dbo.fhsmBackupStatus'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmBackupStatus_IsCopyOnly_IsDamaged ON dbo.fhsmBackupStatus(IsCopyOnly ASC, IsDamaged ASC) INCLUDE(DatabaseName, BackupStartDate, Type)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmBackupStatus
		--
		BEGIN
			SET @objectName = ''dbo.fhsmBackupStatus'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Backup age]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup age'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup age'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup age'') + ''
				AS
				SELECT
					b.DatabaseName
					,b.RecoveryModeChangeTimestampUTC
					,b.RecoveryModel
					,CASE WHEN (b.LatestFullBackupStartDate = 0) THEN NULL ELSE b.LatestFullBackupStartDate END AS LatestFullBackupStartDate
					,DATEDIFF(MINUTE, b.LatestFullBackupStartDate, GETDATE()) / 60 AS LatestFullBackupAgeHours
					,CASE WHEN (b.LatestDiffBackupStartDate = 0) THEN NULL ELSE b.LatestDiffBackupStartDate END AS LatestDiffBackupStartDate
					,DATEDIFF(MINUTE, b.LatestDiffBackupStartDate, GETDATE()) / 60 AS LatestDiffBackupAgeHours
					,CASE WHEN (b.LatestLogBackupStartDate = 0) THEN NULL ELSE b.LatestLogBackupStartDate END AS LatestLogBackupStartDate
					,DATEDIFF(MINUTE, b.LatestLogBackupStartDate, GETDATE()) / 60 AS LatestLogBackupAgeHours
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
				FROM (
					SELECT
						a.DatabaseName
						,a.RecoveryModeChangeTimestampUTC
						,a.RecoveryModel
						,CASE
							WHEN (a.LatestFullBackupStartDate > a.RecoveryModeChangeTimestamp) THEN a.LatestFullBackupStartDate
							ELSE 0
						END AS LatestFullBackupStartDate
						,CASE
							WHEN (a.LatestDiffBackupStartDate > a.RecoveryModeChangeTimestamp) THEN a.LatestDiffBackupStartDate
							WHEN (a.LatestDiffBackupStartDate IS NOT NULL) THEN 0
						END AS LatestDiffBackupStartDate
						,CASE
							WHEN (a.RecoveryModel IN (''''FULL'''', ''''BULK_LOGGED'''')) THEN CASE
								WHEN (a.LatestLogBackupStartDate > a.RecoveryModeChangeTimestamp) THEN a.LatestLogBackupStartDate
								ELSE 0
							END
						END AS LatestLogBackupStartDate
					FROM (
						SELECT
							d.DatabaseName
							,d.TimestampUTC AS RecoveryModeChangeTimestampUTC
							,d.Timestamp AS RecoveryModeChangeTimestamp
							,CASE d.recovery_model
								WHEN ''''1'''' THEN ''''FULL''''		-- Check for Database and Log
								WHEN ''''2'''' THEN ''''BULK_LOGGED''''	-- Check for Database and Log
								WHEN ''''3'''' THEN ''''SIMPLE''''		-- Check for Database
								ELSE ''''?:'''' + d.recovery_model
							END AS RecoveryModel
							,latest.LatestFullBackupStartDate
							,latest.LatestDiffBackupStartDate
							,latest.LatestLogBackupStartDate
						FROM (
							SELECT dbState.DatabaseName, dbState.TimestampUTC, dbState.Timestamp, dbState.Value AS [recovery_model]
							FROM dbo.fhsmDatabaseState AS dbState
							WHERE
								(dbState.Query = 31)
								AND (dbState.ValidTo = ''''9999-12-31 23:59:59.000'''')
								AND (dbState.[Key] = ''''recovery_model'''')
								AND (dbState.DatabaseName <> ''''tempdb'''')
						) AS d
				'';
			SET @stmt += ''
						LEFT OUTER JOIN (
							SELECT
								bsRanked.DatabaseName
								,MAX(CASE WHEN (bsRanked.Type = ''''D'''') THEN bsRanked.BackupStartDate END) AS LatestFullBackupStartDate
								,MAX(CASE WHEN (bsRanked.Type = ''''I'''') THEN bsRanked.BackupStartDate END) AS LatestDiffBackupStartDate
								,MAX(CASE WHEN (bsRanked.Type = ''''L'''') THEN bsRanked.BackupStartDate END) AS LatestLogBackupStartDate
							FROM (
								SELECT
									bs.DatabaseName
									,bs.Type
									,bs.BackupStartDate
									,ROW_NUMBER() OVER(PARTITION BY bs.DatabaseName, bs.Type ORDER BY bs.BackupStartDate DESC) AS _Rnk
								FROM dbo.fhsmBackupStatus AS bs
								WHERE (bs.IsCopyOnly = 0) AND (bs.IsDamaged = 0)
							) AS bsRanked
							WHERE (bsRanked._Rnk = 1)
							GROUP BY bsRanked.DatabaseName
						) AS latest ON (d.DatabaseName = latest.DatabaseName)
					) AS a
				) AS b;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Backup age]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup age'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Backup status]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup status'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup status'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup status'') + ''
				AS
				SELECT
					bs.DatabaseName
					,bs.BackupStartDate
					,bs.BackupFinishDate
					,COALESCE(NULLIF(DATEDIFF(SECOND, bs.BackupStartDate, bs.BackupFinishDate), 0), 1) AS Duration		-- Duration of 0 sec. will always be 1 sec.
					,bs.ExpirationDate
					,CASE bs.Type
						WHEN ''''D'''' THEN ''''Database''''
						WHEN ''''I'''' THEN ''''Differential database''''
						WHEN ''''L'''' THEN ''''Log''''
						WHEN ''''F'''' THEN ''''File/filegroup''''
						WHEN ''''G'''' THEN ''''Differential file''''
						WHEN ''''P'''' THEN ''''Partial''''
						WHEN ''''Q'''' THEN ''''Differential partial''''
						ELSE ''''?:'''' + COALESCE(bs.Type, ''''<NULL>'''')
					END AS Type
					,bs.BackupSize
					,bs.CompressedBackupSize
					,bs.IsCopyOnly
					,bs.IsDamaged
					,bs.LogicalDeviceName
					,bs.PhysicalDeviceName
					,bs.BackupsetName
					,bs.BackupsetDescription
					,bs.Timestamp
					,CAST(bs.Timestamp AS date) AS Date
					,(DATEPART(HOUR, bs.Timestamp) * 60 * 60) + (DATEPART(MINUTE, bs.Timestamp) * 60) + (DATEPART(SECOND, bs.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(bs.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(1, bs.Type, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS BackupTypeJunkDimensionKey
				FROM dbo.fhsmBackupStatus AS bs;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Backup status]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Backup status'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPBackupStatus
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPBackupStatus'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPBackupStatus AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPBackupStatus (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						INSERT INTO dbo.fhsmBackupStatus(
							DatabaseName
							,BackupStartDate, BackupFinishDate, ExpirationDate
							,Type
							,BackupSize, CompressedBackupSize
							,IsCopyOnly, IsDamaged
							,LogicalDeviceName, PhysicalDeviceName
							,BackupsetName, BackupsetDescription
							,TimestampUTC, Timestamp
						)
						SELECT
							bs.database_name
							,bs.backup_start_date, bs.backup_finish_date, bs.expiration_date
							,bs.type
							,bs.backup_size, bs.compressed_backup_size
							,bs.is_copy_only, bs.is_damaged
							,bmf.logical_device_name, bmf.physical_device_name
							,bs.name AS backupset_name, bs.description AS backupset_description
							,@nowUTC, @now
						FROM msdb.dbo.backupmediafamily AS bmf
						INNER JOIN msdb.dbo.backupset AS bs ON (bmf.media_set_id = bs.media_set_id)
						WHERE NOT EXISTS (
							SELECT *
							FROM dbo.fhsmBackupStatus AS existingBS
							WHERE (existingBS.DatabaseName COLLATE DATABASE_DEFAULT = bs.database_name) AND (existingBS.BackupStartDate = bs.backup_start_date)
						)
						ORDER BY
							bs.database_name, 
							bs.backup_finish_date;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPBackupStatus
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPBackupStatus'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmBackupStatus''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmBackupStatus''
				,2
				,''TimestampUTC''
				,1
				,7
				,''Type = ''''L''''''
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableBackupStatus								AS Enabled
				,0												AS DeploymentStatus
				,''Backup status''								AS Name
				,PARSENAME(''dbo.fhsmSPBackupStatus'', 1)			AS Task
				,60 * 60										AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3
			,OutputColumn1, OutputColumn2, OutputColumn3
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmBackupStatus'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL
				,''Database'', NULL, NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3
				,OutputColumn1, OutputColumn2, OutputColumn3
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmBackupStatus'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:BlocksAndDeadlocks.sql modified: 2025.08.05 19.08.25
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableBlocksAndDeadlocks bit;

	SET @enableBlocksAndDeadlocks = 0;
END;

--
-- Specify where the event files are located
--
BEGIN
	DECLARE @blocksAndDeadlocksFilePath nvarchar(260);

	SET @blocksAndDeadlocksFilePath = NULL;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing BlocksAndDeadlocks'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @blockedProcessThreshold int;
	DECLARE @blockedProcessThresholdChanges TABLE(
		Action nvarchar(10),
		DeletedKey nvarchar(128),
		DeletedValue nvarchar(128),
		InsertedKey nvarchar(128),
		InsertedValue nvarchar(128)
	);
	DECLARE @edition nvarchar(128);
	DECLARE @message nvarchar(max);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL is 2012 or higher
	--
	IF (@productVersion1 < 11)
	BEGIN
		RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
		RAISERROR(''!!! Can not install BlocksAndDeadlocks on SQL versions lower than SQL2012'', 0, 1) WITH NOWAIT;
		RAISERROR(''!!!'', 0, 1) WITH NOWAIT;

		--
		-- We have to install empty PBI views in order to satisfy the Power BI report
		--
		BEGIN
			--
			-- Create fact view @pbiSchema.[Blocked process]
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'') + ''
					AS
					SELECT
						TOP (0)
						CAST(NULL AS nvarchar(16)) AS Type
						,CAST(NULL AS int) AS SPID
						,CAST(NULL AS nvarchar(max)) AS Statement
						,CAST(NULL AS int) AS DataSet
						,CAST(NULL AS datetime2(3)) AS EventTimestampUTC
						,CAST(NULL AS date) AS Date
						,CAST(NULL AS int) AS TimeKey
						,CAST(NULL AS bigint) AS BlocksAndDeadlocksKey
						,CAST(NULL AS bigint) AS DatabaseKey;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Blocked process]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create fact view @pbiSchema.[Deadlock]
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'') + ''
					AS
					SELECT
						TOP (0)
						CAST(NULL AS int) AS SPID
						,CAST(NULL AS nvarchar(max)) AS InputbufStatement
						,CAST(NULL AS nvarchar(max)) AS FrameStatement
						,CAST(NULL AS int) AS DataSet
						,CAST(NULL AS datetime2(3)) AS EventTimestampUTC
						,CAST(NULL AS date) AS Date
						,CAST(NULL AS int) AS TimeKey
						,CAST(NULL AS bigint) AS BlocksAndDeadlocksKey
						,CAST(NULL AS bigint) AS DatabaseKey;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Deadlock]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create fact view @pbiSchema.[Blocks and deadlocks]
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'') + ''
					AS
					SELECT
						TOP (0)
						CAST(NULL AS nvarchar(max)) AS ClientApp
						,CAST(NULL AS nvarchar(max)) AS HostName
						,CAST(NULL AS nvarchar(max)) AS LoginName
						,CAST(NULL AS bigint) AS BlocksAndDeadlocksKey;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Blocks and deadlocks]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- We have to install empty Info views in order to satisfy the documentation
		--
		BEGIN
			--
			-- Create info view dbo.fhsmInfoBlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmInfoBlocks'''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW dbo.fhsmInfoBlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW dbo.fhsmInfoBlocks
					AS
					SELECT
						TOP (0)
						CAST(NULL AS XML) AS BlockXML,
						CAST(NULL AS datetime2(3)) AS EventTimestampUTC,
						CAST(NULL AS datetime) AS Timestamp,
						CAST(NULL AS datetime) AS TimestampUTC,
						CAST(NULL AS nvarchar(260)) AS FileName,
						CAST(NULL AS bigint) AS FileOffset,
						CAST(NULL AS int) AS Id;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on info view dbo.fhsmInfoBlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmInfoBlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create info view dbo.fhsmInfoDeadlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmInfoDeadlocks'''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW dbo.fhsmInfoDeadlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW dbo.fhsmInfoDeadlocks
					AS
					SELECT
						TOP (0)
						CAST(NULL AS XML) AS DeadlockXML,
						CAST(NULL AS XML) AS DeadlockGraph,
						CAST(NULL AS datetime2(3)) AS EventTimestampUTC,
						CAST(NULL AS datetime) AS Timestamp,
						CAST(NULL AS datetime) AS TimestampUTC,
						CAST(NULL AS nvarchar(260)) AS FileName,
						CAST(NULL AS bigint) AS FileOffset,
						CAST(NULL AS int) AS Id;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on info view dbo.fhsmInfoDeadlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmInfoDeadlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- We have to install empty control stored procedure in order to satisfy the documentation
		--
		BEGIN
			--
			-- Create stored procedure dbo.fhsmSPControlBlocksAndDeadlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPControlBlocksAndDeadlocks'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPControlBlocksAndDeadlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPControlBlocksAndDeadlocks (
						@Type nvarchar(16)
						,@Command nvarchar(16)
						,@Key nvarchar(128) = NULL
						,@Name nvarchar(128) = NULL
						,@Parameter nvarchar(max) = NULL
						,@Task nvarchar(128) = NULL
						,@Value nvarchar(128) = NULL
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						RAISERROR(''''!!!'''', 0, 1) WITH NOWAIT;
						RAISERROR(''''!!! Can not configure BlocksAndDeadlocks on SQL versions lower than SQL2012'''', 0, 1) WITH NOWAIT;
						RAISERROR(''''!!!'''', 0, 1) WITH NOWAIT;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlBlocksAndDeadlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlBlocksAndDeadlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END
	ELSE BEGIN
		--
		-- Check if SQL version allows to use data compression
		--
		BEGIN
			SET @tableCompressionStmt = '''';

			SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

			IF (@edition = ''SQL Azure'')
				OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
				OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
				OR (@productVersion1 > 13)
				OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
				OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
			BEGIN
				SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
			END;
		END;

		--
		-- Print message if Blocked process reporting threshold is not set and with valid value
		--
		BEGIN
			SET @blockedProcessThreshold = (
				SELECT CAST(c.value_in_use AS int)
				FROM sys.configurations AS c
				WHERE (c.configuration_id = 1569)
			);

			IF (@blockedProcessThreshold = 0)
			BEGIN
				RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
				RAISERROR(''!!! Blocked process reporting threshold is not set'', 0, 1) WITH NOWAIT;
				RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
			END
			ELSE IF (@blockedProcessThreshold < 5)
			BEGIN
				RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
				RAISERROR(''!!! Blocked process reporting threshold is set to lower than 5 seconds'', 0, 1) WITH NOWAIT;
				RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
			END;

			WITH
			conf([Key], Value) AS(
				SELECT
					''BlockedProcessThreshold'' AS [Key]
					,CAST(@blockedProcessThreshold AS nvarchar) AS Value
			)
			MERGE dbo.fhsmConfigurations AS tgt
			USING conf AS src ON (src.[Key] = tgt.[Key] COLLATE SQL_Latin1_General_CP1_CI_AS)
			-- Not testing for NULL as a NULL parameter is not allowed
			WHEN MATCHED AND (tgt.Value <> src.Value)
				THEN UPDATE
					SET tgt.Value = src.Value
			WHEN NOT MATCHED BY TARGET
				THEN INSERT([Key], Value)
				VALUES(src.[Key], src.Value)
			OUTPUT
		        $action,
				deleted.[Key],
				deleted.Value,
				inserted.[Key],
				inserted.Value
			INTO @blockedProcessThresholdChanges;

			IF (@@ROWCOUNT <> 0)
			BEGIN
				SET @message = (
					SELECT ''Blocked process reporting threshold is '''''' + src.InsertedValue + '''''''' + COALESCE('' - changed from '''''' + src.DeletedValue + '''''''', '''')
					FROM @blockedProcessThresholdChanges AS src
				);
				IF (@message IS NOT NULL)
				BEGIN
					RAISERROR(@message, 0, 1) WITH NOWAIT;
					EXEC dbo.fhsmSPLog @name = ''Blocks and deadlocks - installation'', @version = @version, @task = ''BlocksAndDeadlocks'', @type = ''Info'', @message = @message;
				END;
			END;
		END;

		--
		-- Create tables
		--
		BEGIN
			--
			-- Create XML schema collection if it not already exists
			--
			IF NOT EXISTS(
				SELECT *
				FROM sys.xml_schema_collections AS xsc
				WHERE (xsc.schema_id = SCHEMA_ID(''dbo'')) AND (xsc.name = ''fhsmBlocksAndDeadlocksXMLSchemaCollection'')
			)
			BEGIN
				RAISERROR(''Creating XML schema collection dbo.fhsmBlocksAndDeadlocksXMLSchemaCollection'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE XML SCHEMA COLLECTION dbo.fhsmBlocksAndDeadlocksXMLSchemaCollection
					AS N''''
					<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
						<xs:element name="event">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="data" maxOccurs="unbounded" minOccurs="0">
										<xs:complexType>
											<xs:sequence>
												<xs:element name="value"/>
												<xs:element type="xs:string" name="text" minOccurs="0"/>
											</xs:sequence>
											<xs:attribute type="xs:string" name="name" use="optional"/>
										</xs:complexType>
									</xs:element>
									<xs:element name="action" maxOccurs="unbounded" minOccurs="0">
										<xs:complexType>
											<xs:sequence>
												<xs:element type="xs:string" name="value"/>
											</xs:sequence>
											<xs:attribute type="xs:string" name="name" use="optional"/>
											<xs:attribute type="xs:string" name="package" use="optional"/>
										</xs:complexType>
									</xs:element>
								</xs:sequence>
								<xs:attribute type="xs:string" name="name"/>
								<xs:attribute type="xs:string" name="package"/>
								<xs:attribute type="xs:dateTime" name="timestamp"/>
							</xs:complexType>
						</xs:element>
					</xs:schema>'''';
				'';
				EXEC(@stmt);
			END;

			--
			-- Create table dbo.fhsmBlocksAndDeadlocks and indexes if they not already exists
			--
			IF OBJECT_ID(''dbo.fhsmBlocksAndDeadlocks'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmBlocksAndDeadlocks'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmBlocksAndDeadlocks(
						Id int identity(1,1) NOT NULL
						,EventTimestampUTC datetime2(3) NOT NULL
						,FileName nvarchar(260) NOT NULL
						,FileOffset bigint NOT NULL
						,EventData XML(dbo.fhsmBlocksAndDeadlocksXMLSchemaCollection) NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmBlocksAndDeadlocks PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBlocksAndDeadlocks'')) AND (i.name = ''NC_fhsmBlocksAndDeadlocks_EventTimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmBlocksAndDeadlocks_EventTimestampUTC] to table dbo.fhsmBlocksAndDeadlocks'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmBlocksAndDeadlocks_EventTimestampUTC ON dbo.fhsmBlocksAndDeadlocks(EventTimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBlocksAndDeadlocks'')) AND (i.name = ''NC_fhsmBlocksAndDeadlocks_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmBlocksAndDeadlocks_TimestampUTC] to table dbo.fhsmBlocksAndDeadlocks'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmBlocksAndDeadlocks_TimestampUTC ON dbo.fhsmBlocksAndDeadlocks(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmBlocksAndDeadlocks'')) AND (i.name = ''NC_fhsmBlocksAndDeadlocks_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmBlocksAndDeadlocks_Timestamp] to table dbo.fhsmBlocksAndDeadlocks'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmBlocksAndDeadlocks_Timestamp ON dbo.fhsmBlocksAndDeadlocks(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmBlocksAndDeadlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmBlocksAndDeadlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create functions
		--

		--
		-- Create PBI views
		--
		BEGIN
			--
			-- Create fact view @pbiSchema.[Blocked process]
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'') + ''
					AS
					SELECT
						CAST(a.Type AS nvarchar(16)) AS Type
						,a.SPID
						,CASE WHEN ASCII(LEFT(a.Statement, 1)) = 10 THEN SUBSTRING(a.Statement, 2, LEN(a.Statement)) ELSE a.Statement END AS Statement
						,a.Id AS DataSet
						,a.EventTimestampUTC
						,CAST(a.EventTimestampUTC AS date) AS Date
						,(DATEPART(HOUR, a.EventTimestampUTC) * 60 * 60) + (DATEPART(MINUTE, a.EventTimestampUTC) * 60) + (DATEPART(SECOND, a.EventTimestampUTC)) AS TimeKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.ClientApp, a.HostName, a.LoginName, DEFAULT, DEFAULT, DEFAULT) AS k) AS BlocksAndDeadlocksKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.CurrentDBName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					FROM (
						SELECT
							CASE b.rootData.value(''''local-name(/*[1])'''', ''''nvarchar(max)'''')
								WHEN ''''blocking-process'''' THEN ''''Blocking''''
								WHEN ''''blocked-process'''' THEN ''''Blocked''''
							END AS Type
							,b.rootData.value(''''(*/process/@hostname)[1]'''', ''''nvarchar(max)'''') AS HostName
							,b.rootData.value(''''(*/process/@clientapp)[1]'''', ''''nvarchar(max)'''') AS ClientApp
							,b.rootData.value(''''(*/process/@loginname)[1]'''', ''''nvarchar(max)'''') AS LoginName
							,b.rootData.value(''''(*/process/@currentdbname)[1]'''', ''''nvarchar(max)'''') AS CurrentDBName
							,CAST(b.rootData.value(''''(*/process/@spid)[1]'''', ''''nvarchar(max)'''') AS int) AS SPID
							,b.rootData.value(''''(*/process/inputbuf/text())[1]'''', ''''nvarchar(max)'''') AS Statement
							,b.Id
							,b.EventTimestampUTC
						FROM (
							SELECT
								t.c.query(''''(.)[1]'''') AS rootData
								,f.Id
								,f.EventTimestampUTC
							FROM (
								SELECT
									b.EventTimestampUTC
									,b.EventData
									,b.Id
								FROM dbo.fhsmBlocksAndDeadlocks AS b
								WHERE (b.EventData.value(''''(event/@name)[1]'''', ''''nvarchar(max)'''') = ''''blocked_process_report'''')
									AND (
										b.EventData.query(''''(event/data[@name="blocked_process"]/value/blocked-process-report/blocked-process/process)[1]'''').value(''''(process/@spid)[1]'''', ''''nvarchar(max)'''')
										<>
										b.EventData.query(''''(event/data[@name="blocked_process"]/value/blocked-process-report/blocking-process/process)[1]'''').value(''''(process/@spid)[1]'''', ''''nvarchar(max)'''')
									)
							) AS f
							CROSS APPLY f.EventData.nodes(''''/event/data[@name="blocked_process"]/value/blocked-process-report/*'''') AS t(c)
						) AS b
					) AS a
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Blocked process]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocked process'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create fact view @pbiSchema.[Deadlock]
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'') + ''
					AS
					SELECT
						a.SPID
						,CASE WHEN ASCII(LEFT(a.InputbufStatement, 1)) = 10 THEN SUBSTRING(a.InputbufStatement, 2, LEN(a.InputbufStatement)) ELSE a.InputbufStatement END AS InputbufStatement
						,CASE WHEN ASCII(LEFT(a.FrameStatement,    1)) = 10 THEN SUBSTRING(a.FrameStatement,    2, LEN(a.FrameStatement))    ELSE a.FrameStatement    END AS FrameStatement
						,a.Id AS DataSet
						,a.EventTimestampUTC
						,CAST(a.EventTimestampUTC AS date) AS Date
						,(DATEPART(HOUR, a.EventTimestampUTC) * 60 * 60) + (DATEPART(MINUTE, a.EventTimestampUTC) * 60) + (DATEPART(SECOND, a.EventTimestampUTC)) AS TimeKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.ClientApp, a.HostName, a.LoginName, DEFAULT, DEFAULT, DEFAULT) AS k) AS BlocksAndDeadlocksKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.CurrentDBName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					FROM (
						SELECT
							b.rootData.value(''''(process/@hostname)[1]'''', ''''nvarchar(max)'''') AS HostName
							,b.rootData.value(''''(process/@clientapp)[1]'''', ''''nvarchar(max)'''') AS ClientApp
							,b.rootData.value(''''(process/@loginname)[1]'''', ''''nvarchar(max)'''') AS LoginName
							,b.rootData.value(''''(process/@currentdbname)[1]'''', ''''nvarchar(max)'''') AS CurrentDBName
							,CAST(b.rootData.value(''''(process/@spid)[1]'''', ''''nvarchar(max)'''') AS int) AS SPID
							,b.inputbufData.value(''''(inputbuf/text())[1]'''', ''''nvarchar(max)'''') AS InputbufStatement
							,b.frameData.value(''''(frame/text())[1]'''', ''''nvarchar(max)'''') AS FrameStatement
							,b.Id
							,b.EventTimestampUTC
						FROM (
							SELECT
								t.c.query(''''(.)[1]'''') AS rootData
								,t.c.query(''''(inputbuf)[1]'''') AS inputbufData
								,t.c.query(''''(executionStack/frame)[1]'''') AS frameData
								,f.Id
								,f.EventTimestampUTC
							FROM (
								SELECT
									dl.EventTimestampUTC
									,dl.FileName
									,dl.FileOffset
									,dl.EventData
									,dl.Id
								FROM dbo.fhsmBlocksAndDeadlocks AS dl
								WHERE (dl.EventData.value(''''(event/@name)[1]'''', ''''nvarchar(max)'''') = ''''xml_deadlock_report'''')
							) AS f
							CROSS APPLY f.EventData.nodes(''''/event/data/value/deadlock/process-list/process'''') AS t(c)
						) AS b
					) AS a;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Deadlock]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Deadlock'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create dimension view @pbiSchema.[Blocks and deadlocks]
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'') + ''
					AS
					SELECT
						a.ClientApp
						,a.HostName
						,a.LoginName
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.ClientApp, a.HostName, a.LoginName, DEFAULT, DEFAULT, DEFAULT) AS k) AS BlocksAndDeadlocksKey
					FROM (
						SELECT
							DISTINCT
							b.blockedProcessData.value(''''(process/@hostname)[1]'''', ''''nvarchar(max)'''') AS HostName
							,b.blockedProcessData.value(''''(process/@clientapp)[1]'''', ''''nvarchar(max)'''') AS ClientApp
							,b.blockedProcessData.value(''''(process/@loginname)[1]'''', ''''nvarchar(max)'''') AS LoginName
						FROM (
							SELECT
								f.EventData.query(''''(event/data[@name="blocked_process"]/value/blocked-process-report/blocked-process/process)[1]'''') AS blockedProcessData
								,f.EventData.query(''''(event/data[@name="blocked_process"]/value/blocked-process-report/blocking-process/process)[1]'''') AS blockingProcessData
							FROM dbo.fhsmBlocksAndDeadlocks AS f
							WHERE (f.EventData.value(''''(event/@name)[1]'''', ''''nvarchar(max)'''') = ''''blocked_process_report'''')
						) AS b
						WHERE CAST(b.blockedProcessData.value(''''(process/@spid)[1]'''', ''''nvarchar(max)'''') AS int) <> CAST(b.blockingProcessData.value(''''(process/@spid)[1]'''', ''''nvarchar(max)'''') AS int)

						UNION

						SELECT
							DISTINCT
							b.rootData.value(''''(process/@hostname)[1]'''', ''''nvarchar(max)'''') AS HostName
							,b.rootData.value(''''(process/@clientapp)[1]'''', ''''nvarchar(max)'''') AS ClientApp
							,b.rootData.value(''''(process/@loginname)[1]'''', ''''nvarchar(max)'''') AS LoginName
						FROM (
							SELECT
								t.c.query(''''(.)[1]'''') AS rootData
							FROM (
								SELECT dl.EventData
								FROM dbo.fhsmBlocksAndDeadlocks AS dl
								WHERE (dl.EventData.value(''''(event/@name)[1]'''', ''''nvarchar(max)'''') = ''''xml_deadlock_report'''')
							) AS f
							CROSS APPLY f.EventData.nodes(''''/event/data/value/deadlock/process-list/process'''') AS t(c)
						) AS b
					) AS a;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on dimension view @pbiSchema.[Blocks and deadlocks]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Blocks and deadlocks'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create Info views
		--
		BEGIN
			--
			-- Create info view dbo.fhsmInfoBlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmInfoBlocks'''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW dbo.fhsmInfoBlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW dbo.fhsmInfoBlocks
					AS
					SELECT
						EventData AS BlockXML,
						EventTimestampUTC,
						Timestamp,
						TimestampUTC,
						FileName,
						FileOffset,
						Id
					FROM dbo.fhsmBlocksAndDeadlocks
					WHERE (EventData.value(''''(event/@name)[1]'''', ''''nvarchar(max)'''') = ''''blocked_process_report'''');
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on info view dbo.fhsmInfoBlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmInfoBlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create info view dbo.fhsmInfoDeadlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmInfoDeadlocks'''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW dbo.fhsmInfoDeadlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW dbo.fhsmInfoDeadlocks
					AS
					SELECT
						EventData AS DeadlockXML,
						EventData.query(''''(event/data/value/deadlock)[1]'''') AS DeadlockGraph,
						EventTimestampUTC,
						Timestamp,
						TimestampUTC,
						FileName,
						FileOffset,
						Id
					FROM dbo.fhsmBlocksAndDeadlocks
					WHERE (EventData.value(''''(event/@name)[1]'''', ''''nvarchar(max)'''') = ''''xml_deadlock_report'''');
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on info view dbo.fhsmInfoDeadlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmInfoDeadlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedures
		--
		BEGIN
			--
			-- Create stored procedure dbo.fhsmSPBlocksAndDeadlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPBlocksAndDeadlocks'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPBlocksAndDeadlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPBlocksAndDeadlocks (
						@name nvarchar(128)
						,@version nvarchar(128) OUTPUT
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @blockedProcessThreshold int;
						DECLARE @blockedProcessThresholdChanges TABLE(
							Action nvarchar(10),
							DeletedKey nvarchar(128),
							DeletedValue nvarchar(128),
							InsertedKey nvarchar(128),
							InsertedValue nvarchar(128)
						);
						DECLARE @errorMsg nvarchar(max);
						DECLARE @fileName nvarchar(260);
						DECLARE @fileOffset bigint;
						DECLARE @filePath nvarchar(260);
						DECLARE @filePathEvent nvarchar(260);
						DECLARE @message nvarchar(max);
						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @parameter nvarchar(max);
						DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
						DECLARE @runningFilePath nvarchar(260);
						DECLARE @sessionName nvarchar(128);
						DECLARE @sessionNameOldStyle nvarchar(128);
						DECLARE @stmt nvarchar(max);
						DECLARE @testFileName nvarchar(260);
						DECLARE @thisTask nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--
						-- Get the parameter for the command
						--
						BEGIN
							SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

							INSERT INTO @parameterTable([Key], Value)
							SELECT
								(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
								,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
							FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

							SET @filePath = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@FilePath''''));
							SET @filePath = NULLIF(REPLACE(@filePath, '''''''''''''''', ''''''''), '''''''');
						END;

						--
						-- Initialize variables
						--
						BEGIN
							SET @sessionName = DB_NAME() + ''''BlocksAndDeadlocks'''';
							SET @sessionNameOldStyle = ''''FHSMBlocksAndDeadlocks'''';
							SET @filePathEvent = COALESCE(@filePath + ''''\'''', '''''''') + @sessionName + ''''.xel'''';
							SET @filePath = REPLACE(@filePathEvent, ''''.xel'''', ''''*.xel'''');
						END;

						--
						-- Delete session with old name
						--
						IF (@sessionName <> @sessionNameOldStyle)
							AND EXISTS(
								SELECT *
								FROM sys.server_event_sessions AS ses
								WHERE (ses.name = @sessionNameOldStyle)
							)
						BEGIN
							SET @stmt = ''''DROP EVENT SESSION '''' + QUOTENAME(@sessionNameOldStyle) + '''' ON SERVER;'''';
							EXEC(@stmt);
						END;
				'';
				SET @stmt += ''
						--
						-- Register configuration changes
						--
						BEGIN
							SET @blockedProcessThreshold = (
								SELECT CAST(c.value_in_use AS int)
								FROM sys.configurations AS c
								WHERE (c.configuration_id = 1569)
							);

							WITH
							conf([Key], Value) AS(
								SELECT
									''''BlockedProcessThreshold'''' AS [Key]
									,CAST(@blockedProcessThreshold AS nvarchar) AS Value
							)
							MERGE dbo.fhsmConfigurations AS tgt
							USING conf AS src ON (src.[Key] = tgt.[Key] COLLATE SQL_Latin1_General_CP1_CI_AS)
							-- Not testing for NULL as a NULL parameter is not allowed
							WHEN MATCHED AND (tgt.Value <> src.Value)
								THEN UPDATE
									SET tgt.Value = src.Value
							WHEN NOT MATCHED BY TARGET
								THEN INSERT([Key], Value)
								VALUES(src.[Key], src.Value)
							OUTPUT
								$action,
								deleted.[Key],
								deleted.Value,
								inserted.[Key],
								inserted.Value
							INTO @blockedProcessThresholdChanges;

							IF (@@ROWCOUNT <> 0)
							BEGIN
								SET @message = (
									SELECT ''''Blocked process reporting threshold is '''''''''''' + src.InsertedValue + '''''''''''''''' + COALESCE('''' - changed from '''''''''''' + src.DeletedValue + '''''''''''''''', '''''''')
									FROM @blockedProcessThresholdChanges AS src
								);
								IF (@message IS NOT NULL)
								BEGIN
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
								END;
							END;
						END;
				'';
				SET @stmt += ''
						--
						-- Setup or change event session if @filePath is not configured or the same
						--
						BEGIN
							SET @runningFilePath = (
								SELECT CAST(sesf.value AS nvarchar(260))
								FROM sys.server_event_sessions AS ses
								INNER JOIN sys.server_event_session_fields AS sesf ON (sesf.event_session_id = ses.event_session_id)
								WHERE (ses.name = @sessionName) AND (sesf.name = ''''FILENAME'''')
							);

							IF (@runningFilePath <> @filePathEvent) OR (@runningFilePath IS NULL)
							BEGIN
								IF EXISTS(
									SELECT *
									FROM sys.server_event_sessions AS ses
									WHERE (ses.name = @sessionName)
								)
								BEGIN
									SET @stmt = ''''DROP EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER;'''';
									EXEC(@stmt);
								END;

								SET @stmt = ''''
									CREATE EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER
									ADD EVENT sqlserver.blocked_process_report(
										ACTION(
											sqlserver.client_app_name,
											sqlserver.client_hostname,
											sqlserver.database_name
										)
									),
									ADD EVENT sqlserver.xml_deadlock_report(
										ACTION(
											sqlserver.client_app_name,
											sqlserver.client_hostname,
											sqlserver.database_name
										)
									)
									ADD TARGET package0.asynchronous_file_target(
										SET
										filename = N''''''''<FILENAME>'''''''',
										max_file_size = (10),
										max_rollover_files = 2
									)
									WITH (
										EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS,
										MAX_DISPATCH_LATENCY = 15 SECONDS,
										STARTUP_STATE = ON
									);
								'''';

								SET @stmt = REPLACE(@stmt, ''''<FILENAME>'''', @filePathEvent);
								EXEC(@stmt);

								SET @stmt = ''''ALTER EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER STATE = START;'''';
								EXEC(@stmt);
							END;
						END;
				'';
				SET @stmt += ''
						--
						-- Get latest file name and offset
						--
						BEGIN
							SELECT TOP (1)
								@fileName = f.FileName
								,@fileOffset = f.FileOffset
							FROM dbo.fhsmBlocksAndDeadlocks AS f
							ORDER BY f.Id DESC;

							BEGIN TRY
								SET @testFileName = (
									SELECT TOP (1) f.file_name
									FROM sys.fn_xe_file_target_read_file(@filePath, NULL, @fileName, @fileOffset) AS f
								);
							END TRY
							BEGIN CATCH
								SET @fileName = NULL;
								SET @fileOffset = NULL;
							END CATCH;
						END;
				'';
				SET @stmt += ''
						--
						-- Collect data
						--
						BEGIN
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							BEGIN TRY
								INSERT INTO dbo.fhsmBlocksAndDeadlocks(EventTimestampUTC, FileName, FileOffset, EventData, TimestampUTC, Timestamp)
								SELECT a.EventTimestampUTC, a.FileName, a.FileOffset, a.EventData, a.TimestampUTC, a.Timestamp
								FROM (
									SELECT
										'' + CASE WHEN (@productVersion1 <= 13) THEN ''@nowUTC'' ELSE ''f.timestamp_utc'' END + '' AS EventTimestampUTC
										,f.file_name AS FileName
										,f.file_offset AS FileOffset
										,CAST(f.event_data AS varchar(max)) AS EventData
										,@nowUTC AS TimestampUTC
										,@now AS Timestamp
									FROM sys.fn_xe_file_target_read_file(@filePath, NULL, @fileName, @fileOffset) AS f
								) AS a
								WHERE NOT EXISTS(
									SELECT *
									FROM dbo.fhsmBlocksAndDeadlocks AS t
									WHERE (t.EventTimestampUTC = a.EventTimestampUTC)
								)
								ORDER BY
									'' + CASE WHEN (@productVersion1 <= 13) THEN '''' ELSE ''a.EventTimestampUTC,'' END + ''
									a.FileName,
									a.FileOffset;
							END TRY
							BEGIN CATCH
								SET @errorMsg = ERROR_MESSAGE();

								SET @message = ''''Failed due to - '''' + @errorMsg;
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
							END CATCH;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPBlocksAndDeadlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPBlocksAndDeadlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;

			--
			-- Create stored procedure dbo.fhsmSPControlBlocksAndDeadlocks
			--
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPControlBlocksAndDeadlocks'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPControlBlocksAndDeadlocks AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPControlBlocksAndDeadlocks (
						@Type nvarchar(16)
						,@Command nvarchar(16)
						,@Key nvarchar(128) = NULL
						,@Name nvarchar(128) = NULL
						,@Parameter nvarchar(max) = NULL
						,@Task nvarchar(128) = NULL
						,@Value nvarchar(128) = NULL
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @blockedProcessThreshold int;
						DECLARE @blockedProcessThresholdChanges TABLE(
							Action nvarchar(10),
							DeletedKey nvarchar(128),
							DeletedValue nvarchar(128),
							InsertedKey nvarchar(128),
							InsertedValue nvarchar(128)
						);
						DECLARE @filePath nvarchar(260);
						DECLARE @filePathEvent nvarchar(260);
						DECLARE @jobStatus int;
						DECLARE @message nvarchar(max);
						DECLARE @parameterChanges TABLE(
							Action nvarchar(10),
							DeletedTask nvarchar(128),
							DeletedName nvarchar(128),
							DeletedParameter nvarchar(max),
							InsertedTask nvarchar(128),
							InsertedName nvarchar(128),
							InsertedParameter nvarchar(max)
						);
						DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
						DECLARE @runningFilePath nvarchar(260);
						DECLARE @sessionName nvarchar(128);
						DECLARE @showAdvancedOptions int;
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);
						DECLARE @valueInt int;
						DECLARE @version nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';
				'';
				SET @stmt += ''
						IF (@Type = ''''Configuration'''')
						BEGIN
							IF (@Command = ''''set'''') AND (@Key = ''''BlockedProcessThreshold'''')
							BEGIN
								SET @valueInt = dbo.fhsmFNTryParseAsInt(@Value);

								IF (@valueInt IS NULL)
								BEGIN
									SET @message = ''''Illegal @Value:'''''''''''' + COALESCE(@Value, ''''<NULL>'''') + '''''''''''''''';
									RAISERROR(@message, 0, 1) WITH NOWAIT;
									RETURN -1;
								END

								SET @blockedProcessThreshold = (
									SELECT CAST(c.value_in_use AS int)
									FROM sys.configurations AS c
									WHERE (c.configuration_id = 1569)
								);

								SET @showAdvancedOptions = (
									SELECT CAST(c.value_in_use AS int)
									FROM sys.configurations AS c
									WHERE (c.configuration_id = 518)
								);

								IF (@blockedProcessThreshold <> @valueInt)
								BEGIN
									IF (@showAdvancedOptions = 0)
									BEGIN
										SET @stmt = ''''
											EXEC sp_configure ''''''''show advanced options'''''''', 1;
											RECONFIGURE;
										'''';
										EXEC(@stmt);
									END

									SET @stmt = ''''
										EXEC sp_configure ''''''''blocked process threshold'''''''', '''' + @Value + '''';
										RECONFIGURE;
									'''';
									EXEC(@stmt);

									IF (@showAdvancedOptions = 0)
									BEGIN
										SET @stmt = ''''
											EXEC sp_configure ''''''''show advanced options'''''''', 0;
											RECONFIGURE;
										'''';
										EXEC(@stmt);
									END;

									--
									-- Register configuration changes
									--
									BEGIN
										SET @blockedProcessThreshold = (
											SELECT CAST(c.value_in_use AS int)
											FROM sys.configurations AS c
											WHERE (c.configuration_id = 1569)
										);

										WITH
										conf([Key], Value) AS(
											SELECT
												''''BlockedProcessThreshold'''' AS [Key]
												,CAST(@blockedProcessThreshold AS nvarchar) AS Value
										)
										MERGE dbo.fhsmConfigurations AS tgt
										USING conf AS src ON (src.[Key] = tgt.[Key] COLLATE SQL_Latin1_General_CP1_CI_AS)
										-- Not testing for NULL as a NULL parameter is not allowed
										WHEN MATCHED AND (tgt.Value <> src.Value)
											THEN UPDATE
												SET tgt.Value = src.Value
										WHEN NOT MATCHED BY TARGET
											THEN INSERT([Key], Value)
											VALUES(src.[Key], src.Value)
										OUTPUT
											$action,
											deleted.[Key],
											deleted.Value,
											inserted.[Key],
											inserted.Value
										INTO @blockedProcessThresholdChanges;

										IF (@@ROWCOUNT <> 0)
										BEGIN
											SET @message = (
												SELECT ''''Blocked process reporting threshold is '''''''''''' + src.InsertedValue + '''''''''''''''' + COALESCE('''' - changed from '''''''''''' + src.DeletedValue + '''''''''''''''', '''''''')
												FROM @blockedProcessThresholdChanges AS src
											);
											IF (@message IS NOT NULL)
											BEGIN
												EXEC dbo.fhsmSPLog @name = @thisTask, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
											END;
										END;
									END;
								END
							END
							ELSE BEGIN
								SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''', @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''' and @Key:'''''''''''' + COALESCE(@Key, ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -9;
							END;
						END
				'';
				SET @stmt += ''
						ELSE IF (@Type = ''''Parameter'''')
						BEGIN
							IF (@Command = ''''set'''')
							BEGIN
								SET @Parameter = NULLIF(@Parameter, '''''''');

								IF NOT EXISTS (
									SELECT *
									FROM dbo.fhsmSchedules AS s
									WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
								)
								BEGIN
									SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
									RAISERROR(@message, 0, 1) WITH NOWAIT;
									RETURN -11;
								END;

								EXEC dbo.fhsmSPAgentJobControl @command = ''''Disable'''', @jobStatus = @jobStatus OUTPUT;

								--
								-- Register configuration changes
								--
								BEGIN
									WITH
									conf(Task, Name, Parameter) AS(
										SELECT
											@Task AS Task
											,@Name AS Name
											,@Parameter AS Parameter
									)
									MERGE dbo.fhsmSchedules AS tgt
									USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
									-- Not testing for NULL as a NULL parameter is not allowed
									WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
										THEN UPDATE
											SET tgt.Parameter = src.Parameter
									WHEN NOT MATCHED BY TARGET
										THEN INSERT(Task, Name, Parameter)
										VALUES(src.Task, src.Name, src.Parameter)
									OUTPUT
										$action,
										deleted.Task,
										deleted.Name,
										deleted.Parameter,
										inserted.Task,
										inserted.Name,
										inserted.Parameter
									INTO @parameterChanges;

									IF (@@ROWCOUNT <> 0)
									BEGIN
										SET @message = (
											SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
											FROM @parameterChanges AS src
										);
										IF (@message IS NOT NULL)
										BEGIN
											EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
										END;
									END;
								END;
				'';
				SET @stmt += ''
								--
								-- Setup or change event session if @filePath is not configured or the same
								--
								BEGIN
									--
									-- Get the parameter for the command
									--
									BEGIN
										SET @Parameter = dbo.fhsmFNGetTaskParameter(@Task, @Name);

										INSERT INTO @parameterTable([Key], Value)
										SELECT
											(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
											,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
										FROM dbo.fhsmFNSplitString(@Parameter, '''';'''') AS p;

										SET @filePath = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@FilePath''''));
										SET @filePath = NULLIF(REPLACE(@filePath, '''''''''''''''', ''''''''), '''''''');
									END;

									--
									-- Initialize variables
									--
									BEGIN
										SET @sessionName = DB_NAME() + ''''BlocksAndDeadlocks'''';
										SET @filePathEvent = COALESCE(@filePath + ''''\'''', '''''''') + @sessionName + ''''.xel'''';
										SET @filePath = REPLACE(@filePathEvent, ''''.xel'''', ''''*.xel'''');
									END;

									SET @runningFilePath = (
										SELECT CAST(sesf.value AS nvarchar(260))
										FROM sys.server_event_sessions AS ses
										INNER JOIN sys.server_event_session_fields AS sesf ON (sesf.event_session_id = ses.event_session_id)
										WHERE (ses.name = @sessionName) AND (sesf.name = ''''FILENAME'''')
									);

									IF (@runningFilePath <> @filePathEvent) OR (@runningFilePath IS NULL)
									BEGIN
										IF EXISTS(
											SELECT *
											FROM sys.server_event_sessions AS ses
											WHERE (ses.name = @sessionName)
										)
										BEGIN
											SET @stmt = ''''DROP EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER;'''';
											EXEC(@stmt);
										END;

										SET @stmt = ''''
											CREATE EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER
											ADD EVENT sqlserver.blocked_process_report(
												ACTION(
													sqlserver.client_app_name,
													sqlserver.client_hostname,
													sqlserver.database_name
												)
											),
											ADD EVENT sqlserver.xml_deadlock_report(
												ACTION(
													sqlserver.client_app_name,
													sqlserver.client_hostname,
													sqlserver.database_name
												)
											)
											ADD TARGET package0.asynchronous_file_target(
												SET
												filename = N''''''''<FILENAME>'''''''',
												max_file_size = (10),
												max_rollover_files = 2
											)
											WITH (
												EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS,
												MAX_DISPATCH_LATENCY = 15 SECONDS,
												STARTUP_STATE = ON
											);
										'''';

										SET @stmt = REPLACE(@stmt, ''''<FILENAME>'''', @filePathEvent);
										EXEC(@stmt);

										SET @stmt = ''''ALTER EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER STATE = START;'''';
										EXEC(@stmt);
									END;
								END;

								IF (@jobStatus = 1)
								BEGIN
									EXEC dbo.fhsmSPAgentJobControl @command = ''''Enable'''', @jobStatus = @jobStatus OUTPUT;
								END;
							END
							ELSE BEGIN
								SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -19;
							END;
						END
				'';
				SET @stmt += ''
						ELSE IF (@Type = ''''Uninstall'''')
						BEGIN
							--
							-- Initialize variables
							--
							BEGIN
								SET @sessionName = DB_NAME() + ''''BlocksAndDeadlocks'''';
							END;

							--
							-- Disable task
							--
							BEGIN
								UPDATE s
								SET s.Enabled = 0
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name);

								SET @message = ''''Disabling schedule'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
							END;

							--
							-- Delete extended event
							--
							BEGIN
								IF EXISTS(
									SELECT *
									FROM sys.server_event_sessions AS ses
									WHERE (ses.name = @sessionName)
								)
								BEGIN
									SET @stmt = ''''DROP EVENT SESSION '''' + QUOTENAME(@sessionName) + '''' ON SERVER;'''';
									EXEC(@stmt);

									SET @message = ''''Dropping extended event session:'''''''''''' + @sessionName + '''''''''''''''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
								END;
							END;
						END
				'';
				SET @stmt += ''
						ELSE BEGIN
							SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -999;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlBlocksAndDeadlocks
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlBlocksAndDeadlocks'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Register retention
		--
		BEGIN
			WITH
			retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
				SELECT
					1
					,''dbo.fhsmBlocksAndDeadlocks''
					,1
					,''TimestampUTC''
					,1
					,7
					,NULL
			)
			MERGE dbo.fhsmRetentions AS tgt
			USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
			WHEN NOT MATCHED BY TARGET
				THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
				VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
		END;

		--
		-- Register schedules
		--
		BEGIN
			WITH
			schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
				SELECT
					@enableBlocksAndDeadlocks												AS Enabled
					,0																		AS DeploymentStatus
					,''Blocks and deadlocks''													AS Name
					,PARSENAME(''dbo.fhsmSPBlocksAndDeadlocks'', 1)							AS Task
					,5 * 60																	AS ExecutionDelaySec
					,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))							AS FromTime
					,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))							AS ToTime
					,1, 1, 1, 1, 1, 1, 1													-- Monday..Sunday
					,''@FilePath = '''''' + COALESCE(@blocksAndDeadlocksFilePath, '''') + ''''''''	AS Parameter
			)
			MERGE dbo.fhsmSchedules AS tgt
			USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
			WHEN NOT MATCHED BY TARGET
				THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
				VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
		END;

		--
		-- Register dimensions
		--

		--
		-- Update dimensions based upon the fact tables
		--
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:Capacity.sql modified: 2025.08.05 19.08.46
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableCapacity bit;

	SET @enableCapacity = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing Capacity'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL is 2008
	--
	IF ((@productVersion1 = 10) AND (@productVersion2 = 0))
	BEGIN
		RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
		RAISERROR(''!!! Can not install the Disk size part on SQL version SQL2008'', 0, 1) WITH NOWAIT;
		RAISERROR(''!!!'', 0, 1) WITH NOWAIT;
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- The services ''Database size'', ''Partitioned indexes'', and ''Table size'' will be marked as disabled and deprecated as this Capacity service takes over
	--
	BEGIN
		UPDATE s
		SET
			s.Enabled = 0,
			s.DeploymentStatus = -1
		FROM dbo.fhsmSchedules AS s
		WHERE (s.Name IN (''Database size'', ''Partitioned indexes'', ''Table size''))
			AND ((s.Enabled <> 0) OR (s.DeploymentStatus <> -1));
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmAllocationUnits and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAllocationUnits'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAllocationUnits'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAllocationUnits(
						Id int identity(1,1) NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,FilegroupName sysname NOT NULL
						,SchemaName sysname NOT NULL
						,ObjectName sysname NOT NULL
						,IndexName sysname NULL
						,PartitionNumber int NOT NULL
						,AllocationUnitType tinyint NOT NULL
						,TotalPages bigint NULL
						,UsedPages bigint NULL
						,DataPages bigint NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmAllocationUnits PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAllocationUnits'')) AND (i.name = ''NC_fhsmAllocationUnits_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAllocationUnits_TimestampUTC] to table dbo.fhsmAllocationUnits'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAllocationUnits_TimestampUTC ON dbo.fhsmAllocationUnits(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAllocationUnits'')) AND (i.name = ''NC_fhsmAllocationUnits_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAllocationUnits_Timestamp] to table dbo.fhsmAllocationUnits'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAllocationUnits_Timestamp ON dbo.fhsmAllocationUnits(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAllocationUnits
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAllocationUnits'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmDatabaseSize and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmDatabaseSize'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmDatabaseSize(
						Id int identity(1,1) NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,LogicalName nvarchar(128) NOT NULL
						,PhysicalName nvarchar(260) NULL
						,Type tinyint NOT NULL
						,VolumeMountPoint nvarchar(512) NULL
						,LogicalVolumeName nvarchar(512) NULL
						,FilegroupName nvarchar(128) NULL
						,FileGroupType char(2) NULL
						,CurrentSize int NOT NULL
						,UsedSize int NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmDatabaseSize PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			--
			-- Adding column PhysicalName to table dbo.fhsmDatabaseSize if it not already exists
			--
			IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (c.name = ''PhysicalName''))
			BEGIN
				RAISERROR(''Adding column [PhysicalName] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					ALTER TABLE dbo.fhsmDatabaseSize
						ADD PhysicalName nvarchar(260) NULL;
				'';
				EXEC(@stmt);
			END;

			--
			-- Adding column VolumeMountPoint to table dbo.fhsmDatabaseSize if it not already exists
			--
			IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (c.name = ''VolumeMountPoint''))
			BEGIN
				RAISERROR(''Adding column [VolumeMountPoint] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					ALTER TABLE dbo.fhsmDatabaseSize
						ADD VolumeMountPoint nvarchar(512) NULL;
				'';
				EXEC(@stmt);
			END;

			--
			-- Adding column LogicalVolumeName to table dbo.fhsmDatabaseSize if it not already exists
			--
			IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (c.name = ''LogicalVolumeName''))
			BEGIN
				RAISERROR(''Adding column [LogicalVolumeName] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					ALTER TABLE dbo.fhsmDatabaseSize
						ADD LogicalVolumeName nvarchar(512) NULL;
				'';
				EXEC(@stmt);
			END;

			--
			-- Adding column FilegroupName to table dbo.fhsmDatabaseSize if it not already exists
			--
			IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (c.name = ''FilegroupName''))
			BEGIN
				RAISERROR(''Adding column [FilegroupName] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					ALTER TABLE dbo.fhsmDatabaseSize
						ADD FilegroupName nvarchar(128) NULL;
				'';
				EXEC(@stmt);
			END;

			--
			-- Adding column FileGroupType to table dbo.fhsmDatabaseSize if it not already exists
			--
			IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (c.name = ''FileGroupType''))
			BEGIN
				RAISERROR(''Adding column [FileGroupType] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					ALTER TABLE dbo.fhsmDatabaseSize
						ADD FileGroupType char(2) NULL;
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (i.name = ''NC_fhsmDatabaseSize_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseSize_TimestampUTC] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseSize_TimestampUTC ON dbo.fhsmDatabaseSize(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (i.name = ''NC_fhsmDatabaseSize_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseSize_Timestamp] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseSize_Timestamp ON dbo.fhsmDatabaseSize(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseSize'')) AND (i.name = ''NC_fhsmDatabaseSize_DatabaseName_LogicalName_Type''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDatabaseSize_DatabaseName_LogicalName_Type] to table dbo.fhsmDatabaseSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDatabaseSize_DatabaseName_LogicalName_Type ON dbo.fhsmDatabaseSize(DatabaseName, LogicalName, Type)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmDatabaseSize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmDatabaseSize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmDiskSize and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmDiskSize'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmDiskSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmDiskSize(
						Id int identity(1,1) NOT NULL
						,VolumeMountPoint nvarchar(512) NULL
						,LogicalVolumeName nvarchar(512) NULL
						,FileSystemType nvarchar(512) NULL
						,TotalBytes bigint NOT NULL
						,FreeBytes bigint NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmDiskSize PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDiskSize'')) AND (i.name = ''NC_fhsmDiskSize_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDiskSize_TimestampUTC] to table dbo.fhsmDiskSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDiskSize_TimestampUTC ON dbo.fhsmDiskSize(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDiskSize'')) AND (i.name = ''NC_fhsmDiskSize_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDiskSize_Timestamp] to table dbo.fhsmDiskSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDiskSize_Timestamp ON dbo.fhsmDiskSize(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmDiskSize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmDiskSize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmPartitionedIndexes and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmPartitionedIndexes'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmPartitionedIndexes'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmPartitionedIndexes(
						Id int identity(1,1) NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,SchemaName nvarchar(128) NOT NULL
						,ObjectName nvarchar(128) NOT NULL
						,IndexName nvarchar(128) NULL
						,IndexTypeDesc nvarchar(60) NOT NULL
						,PartitionSchemeName nvarchar(128) NOT NULL
						,PartitionFilegroupName nvarchar(128) NOT NULL
						,PartitionFunctionName nvarchar(128) NOT NULL
						,PartitionFunctionValueOnRight bit NOT NULL
						,PartitionFunctionCreateDate datetime NOT NULL
						,PartitionFunctionModifyDate datetime NOT NULL
						,PartitionBoundaryValue sql_variant NULL
						,PartitionColumn nvarchar(128) NOT NULL
						,PartitionNumber int NOT NULL
						,PartitionCompressionTypeDesc nvarchar(60) NOT NULL
						,PartitionRowCount bigint NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmPartitionedIndexes PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPartitionedIndexes'')) AND (i.name = ''NC_fhsmPartitionedIndexes_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmPartitionedIndexes_TimestampUTC] to table dbo.fhsmPartitionedIndexes'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmPartitionedIndexes_TimestampUTC ON dbo.fhsmPartitionedIndexes(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPartitionedIndexes'')) AND (i.name = ''NC_fhsmPartitionedIndexes_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmPartitionedIndexes_Timestamp] to table dbo.fhsmPartitionedIndexes'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmPartitionedIndexes_Timestamp ON dbo.fhsmPartitionedIndexes(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPartitionedIndexes'')) AND (i.name = ''NC_fhsmPartitionedIndexes_DatabaseName''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmPartitionedIndexes_DatabaseName] to table dbo.fhsmPartitionedIndexes'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmPartitionedIndexes_DatabaseName ON dbo.fhsmPartitionedIndexes(DatabaseName)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmPartitionedIndexes
			--
			BEGIN
				SET @objectName = ''dbo.fhsmPartitionedIndexes'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmTableSize and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmTableSize'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmTableSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmTableSize(
						Id int identity(1,1) NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,SchemaName nvarchar(128) NOT NULL
						,ObjectName nvarchar(128) NOT NULL
						,IndexName nvarchar(128) NULL
						,PartitionNumber int NOT NULL
						,IsMemoryOptimized bit NOT NULL
						,Rows bigint NOT NULL
						,Reserved int NULL
						,Data int NULL
						,IndexSize int NULL
						,Unused int NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmTableSize PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTableSize'')) AND (i.name = ''NC_fhsmTableSize_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmTableSize_TimestampUTC] to table dbo.fhsmTableSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmTableSize_TimestampUTC ON dbo.fhsmTableSize(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTableSize'')) AND (i.name = ''NC_fhsmTableSize_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmTableSize_Timestamp] to table dbo.fhsmTableSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmTableSize_Timestamp ON dbo.fhsmTableSize(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTableSize'')) AND (i.name = ''NC_fhsmTableSize_DatabaseName_SchemaName_ObjectName_IndexName''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmTableSize_DatabaseName_SchemaName_ObjectName_IndexName] to table dbo.fhsmTableSize'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmTableSize_DatabaseName_SchemaName_ObjectName_IndexName ON dbo.fhsmTableSize(DatabaseName, SchemaName, ObjectName, IndexName)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmTableSize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmTableSize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Allocation units]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Allocation units'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Allocation units'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Allocation units'') + ''
					AS
					SELECT
						au.PartitionNumber
						,CASE au.AllocationUnitType
							WHEN 0 THEN ''''Dropped''''
							WHEN 1 THEN ''''IN_ROW_DATA''''
							WHEN 2 THEN ''''LOB_DATA''''
							WHEN 3 THEN ''''ROW_OVERFLOW_DATA''''
						END AS AllocationUnitTypeDesc
						,au.TotalPages * 8 AS TotalSpaceKB
						,au.UsedPages * 8 AS UsedSpaceKB
						,au.DataPages * 8 AS DataSpaceKB
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(au.DatabaseName, au.SchemaName,    au.ObjectName, COALESCE(au.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(au.DatabaseName, au.FilegroupName, DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS FileGroupKey
						FROM dbo.fhsmAllocationUnits AS au
						WHERE
							(au.TimestampUTC = (
								SELECT MAX(au2.TimestampUTC)
								FROM dbo.fhsmAllocationUnits AS au2
							))
							AND (
								(au.TotalPages <> 0)
								OR (au.UsedPages <> 0)
								OR (au.DataPages <> 0)
							);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Allocation units]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Allocation units'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Database size]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database size'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database size'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database size'') + ''
					AS
					SELECT
						ds.CurrentSize
						,ds.UsedSize
						,CAST(ds.Timestamp AS date) AS Date
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.DatabaseName, ds.LogicalName, ds.PhysicalName,
							CASE ds.Type
								WHEN 0 THEN ''''Data''''
								WHEN 1 THEN ''''Log''''
								WHEN 2 THEN ''''Filestream''''
								WHEN 4 THEN ''''Fulltext''''
								ELSE ''''Other''''
							END,
						ds.FilegroupName, DEFAULT) AS k) AS DatabaseFileKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.VolumeMountPoint, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DiskKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.DatabaseName, ds.FilegroupName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS FileGroupKey
					FROM dbo.fhsmDatabaseSize AS ds
					WHERE (ds.Timestamp IN (
						SELECT a.Timestamp
						FROM (
							SELECT
								ds2.Timestamp
								,ROW_NUMBER() OVER(PARTITION BY CAST(ds2.Timestamp AS date) ORDER BY ds2.Timestamp DESC) AS _Rnk_
							FROM dbo.fhsmDatabaseSize AS ds2
						) AS a
						WHERE (a._Rnk_ = 1)
					));
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Database size]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database size'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Disk size]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Disk size'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Disk size'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Disk size'') + ''
					AS
					SELECT
						ds.TotalBytes
						,ds.FreeBytes
						,CAST(ds.Timestamp AS date) AS Date
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ds.VolumeMountPoint, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DiskKey
					FROM dbo.fhsmDiskSize AS ds
					WHERE (ds.Timestamp IN (
						SELECT a.Timestamp
						FROM (
							SELECT
								ds2.Timestamp
								,ROW_NUMBER() OVER(PARTITION BY CAST(ds2.Timestamp AS date) ORDER BY ds2.Timestamp DESC) AS _Rnk_
							FROM dbo.fhsmDiskSize AS ds2
						) AS a
						WHERE (a._Rnk_ = 1)
					));
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Disk size]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Disk size'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Partitioned indexes]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Partitioned indexes'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Partitioned indexes'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Partitioned indexes'') + ''
					AS
				'';
				IF (@productVersion1 <= 10)
				BEGIN
					-- SQL Versions SQL2008R2 or lower

					SET @stmt += ''
						WITH partitionedIndexes AS (
							SELECT
								pi.DatabaseName
								,pi.SchemaName 
								,pi.ObjectName
								,pi.IndexName
								,pi.IndexTypeDesc
								,pi.PartitionSchemeName
								,pi.PartitionFilegroupName
								,pi.PartitionFunctionName
								,pi.PartitionFunctionValueOnRight
								,pi.PartitionFunctionCreateDate
								,pi.PartitionFunctionModifyDate
								,pi.PartitionBoundaryValue
								,pi.PartitionColumn
								,pi.PartitionNumber
								,pi.PartitionCompressionTypeDesc
								,pi.PartitionRowCount
								,pi.Timestamp
								,ROW_NUMBER() OVER(PARTITION BY pi.TimestampUTC, pi.DatabaseName, pi.SchemaName, pi.ObjectName, pi.IndexName ORDER BY pi.PartitionNumber) AS Idx
							FROM dbo.fhsmPartitionedIndexes AS pi
							WHERE (pi.Timestamp IN (
								SELECT a.Timestamp
								FROM (
									SELECT
										pi2.Timestamp
										,ROW_NUMBER() OVER(PARTITION BY CAST(pi2.Timestamp AS date) ORDER BY pi2.Timestamp DESC) AS _Rnk_
									FROM dbo.fhsmPartitionedIndexes AS pi2
								) AS a
								WHERE (a._Rnk_ = 1)
							))
						)
					'';
					SET @stmt += ''
						SELECT
							pi.IndexTypeDesc
							,pi.PartitionSchemeName
							,pi.PartitionFilegroupName
							,pi.PartitionFunctionName
							,pi.PartitionFunctionValueOnRight
							,CASE 
								WHEN pi.PartitionFunctionValueOnRight = 0 
								THEN
									pi.PartitionColumn
									+ '''' > ''''
									+ CAST(ISNULL(lagPI.PartitionBoundaryValue, ''''Infinity'''') AS nvarchar)
									+ '''' and ''''
									+ pi.PartitionColumn
									+ '''' <= ''''
									+ CAST(ISNULL(pi.PartitionBoundaryValue, ''''Infinity'''') AS nvarchar) 
								ELSE
									pi.PartitionColumn
									+ '''' >= ''''
									+ CAST(ISNULL(pi.PartitionBoundaryValue, ''''Infinity'''') AS nvarchar)
									+ '''' and ''''
									+ pi.PartitionColumn
									+ '''' < ''''
									+ CAST(ISNULL(leadPI.PartitionBoundaryValue, ''''Infinity'''') AS nvarchar)
							END AS PartitionRange
							,ROW_NUMBER() OVER(ORDER BY pi.Timestamp DESC, pi.DatabaseName, pi.SchemaName, pi.ObjectName, pi.IndexName, CASE WHEN pi.PartitionFunctionValueOnRight = 0 THEN CASE WHEN pi.PartitionBoundaryValue IS NULL THEN 2 ELSE 1 END ELSE CASE WHEN pi.PartitionBoundaryValue IS NULL THEN 1 ELSE 2 END END, pi.PartitionBoundaryValue) AS SortOrder
							,pi.PartitionFunctionCreateDate
							,pi.PartitionFunctionModifyDate
							,pi.PartitionBoundaryValue
							,pi.PartitionColumn
							,pi.PartitionNumber
							,pi.PartitionCompressionTypeDesc
							,pi.PartitionRowCount
							,CAST(pi.Timestamp AS date) AS Date
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, DEFAULT,                   DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS DatabaseKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.SchemaName,             DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS SchemaKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.SchemaName,             pi.ObjectName, DEFAULT,                          DEFAULT, DEFAULT) AS k) AS ObjectKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.SchemaName,             pi.ObjectName, COALESCE(pi.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.PartitionFilegroupName, DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS FileGroupKey
						FROM partitionedIndexes AS pi
						LEFT OUTER JOIN partitionedIndexes AS lagPI ON
							(lagPI.Timestamp = pi.Timestamp)
							AND (lagPI.DatabaseName = pi.DatabaseName)
							AND (lagPI.SchemaName = pi.SchemaName)
							AND (lagPI.ObjectName = pi.ObjectName)
							AND ((lagPI.IndexName = pi.IndexName) OR ((lagPI.IndexName IS NULL) AND (pi.IndexName IS NULL)))
							AND (lagPI.Idx = pi.Idx - 1)
						LEFT OUTER JOIN partitionedIndexes AS leadPI ON
							(leadPI.Timestamp = pi.Timestamp)
							AND (leadPI.DatabaseName = pi.DatabaseName)
							AND (leadPI.SchemaName = pi.SchemaName)
							AND (leadPI.ObjectName = pi.ObjectName)
							AND ((leadPI.IndexName = pi.IndexName) OR ((leadPI.IndexName IS NULL) AND (pi.IndexName IS NULL)))
							AND (leadPI.Idx = pi.Idx + 1);
					'';
				END
				ELSE BEGIN
					-- SQL Versions SQL2012 or higher

					SET @stmt += ''
						SELECT
							pi.IndexTypeDesc
							,pi.PartitionSchemeName
							,pi.PartitionFilegroupName
							,pi.PartitionFunctionName
							,pi.PartitionFunctionValueOnRight
							,CASE 
								WHEN pi.PartitionFunctionValueOnRight = 0 
								THEN
									pi.PartitionColumn
									+ '''' > ''''
									+ CAST(ISNULL(LAG(pi.PartitionBoundaryValue) OVER(PARTITION BY pi.Timestamp, pi.DatabaseName, pi.SchemaName, pi.ObjectName, pi.IndexName ORDER BY pi.PartitionNumber), ''''Infinity'''') AS nvarchar)
									+ '''' and ''''
									+ pi.PartitionColumn
									+ '''' <= ''''
									+ CAST(ISNULL(pi.PartitionBoundaryValue, ''''Infinity'''') AS nvarchar) 
								ELSE
									pi.PartitionColumn
									+ '''' >= ''''
									+ CAST(ISNULL(pi.PartitionBoundaryValue, ''''Infinity'''') AS nvarchar)
									+ '''' and ''''
									+ pi.PartitionColumn
									+ '''' < ''''
									+ CAST(ISNULL(LEAD(pi.PartitionBoundaryValue) OVER(PARTITION BY pi.Timestamp, pi.DatabaseName, pi.SchemaName, pi.ObjectName, pi.IndexName ORDER BY pi.PartitionNumber), ''''Infinity'''') AS nvarchar)
							END AS PartitionRange
							,ROW_NUMBER() OVER(ORDER BY pi.Timestamp DESC, pi.DatabaseName, pi.SchemaName, pi.ObjectName, pi.IndexName, CASE WHEN pi.PartitionFunctionValueOnRight = 0 THEN CASE WHEN pi.PartitionBoundaryValue IS NULL THEN 2 ELSE 1 END ELSE CASE WHEN pi.PartitionBoundaryValue IS NULL THEN 1 ELSE 2 END END, pi.PartitionBoundaryValue) AS SortOrder
							,pi.PartitionFunctionCreateDate
							,pi.PartitionFunctionModifyDate
							,pi.PartitionBoundaryValue
							,pi.PartitionColumn
							,pi.PartitionNumber
							,pi.PartitionCompressionTypeDesc
							,pi.PartitionRowCount
							,CAST(pi.Timestamp AS date) AS Date
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, DEFAULT,                   DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS DatabaseKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.SchemaName,             DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS SchemaKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.SchemaName,             pi.ObjectName, DEFAULT,                          DEFAULT, DEFAULT) AS k) AS ObjectKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.SchemaName,             pi.ObjectName, COALESCE(pi.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
							,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pi.DatabaseName, pi.PartitionFilegroupName, DEFAULT,       DEFAULT,                          DEFAULT, DEFAULT) AS k) AS FileGroupKey
						FROM dbo.fhsmPartitionedIndexes AS pi
						WHERE (pi.Timestamp IN (
							SELECT a.Timestamp
							FROM (
								SELECT
									pi2.Timestamp
									,ROW_NUMBER() OVER(PARTITION BY CAST(pi2.Timestamp AS date) ORDER BY pi2.Timestamp DESC) AS _Rnk_
								FROM dbo.fhsmPartitionedIndexes AS pi2
							) AS a
							WHERE (a._Rnk_ = 1)
						));
					'';
				END;
				SET @stmt += ''
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Partitioned indexes]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Partitioned indexes'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Table size]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Table size'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Table size'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Table size'') + ''
					AS
					SELECT
						ts.Rows
						,ts.Reserved
						,ts.Data
						,ts.IndexSize
						,ts.Unused
						,CAST(ts.Timestamp AS date) AS Date
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ts.DatabaseName, DEFAULT,       DEFAULT,       DEFAULT,                          DEFAULT,            DEFAULT) AS k) AS DatabaseKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ts.DatabaseName, ts.SchemaName, DEFAULT,       DEFAULT,                          DEFAULT,            DEFAULT) AS k) AS SchemaKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ts.DatabaseName, ts.SchemaName, ts.ObjectName, DEFAULT,                          DEFAULT,            DEFAULT) AS k) AS ObjectKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ts.DatabaseName, ts.SchemaName, ts.ObjectName, COALESCE(ts.IndexName, ''''N.A.''''), DEFAULT,            DEFAULT) AS k) AS IndexKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ts.DatabaseName, ts.SchemaName, ts.ObjectName, ts.PartitionNumber,               DEFAULT,            DEFAULT) AS k) AS ObjectPartitionKey
						,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(ts.DatabaseName, ts.SchemaName, ts.ObjectName, COALESCE(ts.IndexName, ''''N.A.''''), ts.PartitionNumber, DEFAULT) AS k) AS IndexPartitionKey
					FROM dbo.fhsmTableSize AS ts
					WHERE (ts.Timestamp IN (
						SELECT a.Timestamp
						FROM (
							SELECT
								ts2.Timestamp
								,ROW_NUMBER() OVER(PARTITION BY CAST(ts2.Timestamp AS date) ORDER BY ts2.Timestamp DESC) AS _Rnk_
							FROM dbo.fhsmTableSize AS ts2
						) AS a
						WHERE (a._Rnk_ = 1)
					));
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Table size]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Table size'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPAllocationUnits
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPAllocationUnits'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPAllocationUnits AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPAllocationUnits (
						@name nvarchar(128),
						@parameter nvarchar(max)
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @database nvarchar(128);
						DECLARE @databases nvarchar(max);
						DECLARE @errorMsg nvarchar(max);
						DECLARE @message nvarchar(max);
						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
						DECLARE @replicaId uniqueidentifier;
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);
						DECLARE @version nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--
						-- Parse the parameter for the command
						--
						BEGIN
							INSERT INTO @parameterTable([Key], Value)
							SELECT
								(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
								,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
							FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

							SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

							--
							-- Trim @databases if Ola Hallengren style has been chosen
							--
							BEGIN
								SET @databases = LTRIM(RTRIM(@databases));
								WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
								BEGIN
									SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
								END;
							END;
						END;

						--
						-- Get the list of databases to process
						--
						BEGIN
							SELECT d.DatabaseName, d.[Order]
							INTO #dbList
							FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
						END;

						--
						-- Collect data
						--
						BEGIN
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
							FROM #dbList AS dl
							INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
							ORDER BY dl.[Order];

							OPEN dCur;

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM dCur
								INTO @database, @replicaId;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								--
								-- If is a member of a replica, we will only execute when running on the primary
								--
								IF (@replicaId IS NULL)
				'';
				IF (@productVersion1 >= 11)
				BEGIN
					-- SQL Versions SQL2012 or higher
					SET @stmt += ''
									OR (
										(
											SELECT
											CASE
												WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
												ELSE 0
											END AS IsPrimaryServer
											FROM master.sys.availability_groups AS ag
											INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
											INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
											WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
										) = 1
									)
					'';
				END;
				SET @stmt += ''
								BEGIN
									SET @stmt = ''''
										USE '''' + QUOTENAME(@database) + '''';

										SELECT
											DB_NAME()								AS DatabaseName
											,COALESCE(fg.name, ''''''''N.A.'''''''')		AS FilegroupName
											,sch.name								AS SchemaName
											,o.name									AS ObjectName
											,i.name									AS IndexName
											,p.partition_number						AS PartitionNumber
											,au.type								AS AllocationUnitType
											,SUM(au.total_pages)					AS TotalPages
											,SUM(au.used_pages)						AS UsedPages
											,SUM(au.data_pages)						AS DataPages
											,@nowUTC, @now
										FROM sys.database_files AS df
										INNER JOIN sys.filegroups AS fg ON (fg.data_space_id = df.data_space_id)
										INNER JOIN sys.allocation_units AS au ON (au.data_space_id = fg.data_space_id)
										INNER JOIN sys.partitions AS p ON (p.hobt_id = au.container_id)
										INNER JOIN sys.indexes AS i ON (i.object_id = p.object_id) AND (i.index_id = p.index_id)
										INNER JOIN sys.objects AS o ON (o.object_id = i.object_id)
										INNER JOIN sys.schemas AS sch ON (sch.schema_id = o.schema_id)
										WHERE (1 = 1)
											AND (o.type <> ''''''''V'''''''')
										GROUP BY
											fg.name
											,sch.name
											,o.name
											,i.name
											,p.partition_number
											,au.type;
									'''';
									BEGIN TRY
										INSERT INTO dbo.fhsmAllocationUnits(
											DatabaseName, FilegroupName, SchemaName, ObjectName, IndexName, PartitionNumber, AllocationUnitType
											,TotalPages, UsedPages, DataPages, TimestampUTC, Timestamp
										)
										EXEC sp_executesql
											@stmt
											,N''''@now datetime, @nowUTC datetime''''
											,@now = @now, @nowUTC = @nowUTC;
									END TRY
									BEGIN CATCH
										SET @errorMsg = ERROR_MESSAGE();

										SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
									END CATCH;
								END
								ELSE BEGIN
									SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
								END;
							END;

							CLOSE dCur;
							DEALLOCATE dCur;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPAllocationUnits
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPAllocationUnits'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPDatabaseSize
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPDatabaseSize'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPDatabaseSize AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPDatabaseSize (
						@name nvarchar(128),
						@parameter nvarchar(max)
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @database nvarchar(128);
						DECLARE @databases nvarchar(max);
						DECLARE @errorMsg nvarchar(max);
						DECLARE @message nvarchar(max);
						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
						DECLARE @replicaId uniqueidentifier;
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);
						DECLARE @version nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--
						-- Get the parameter for the command
						--
						BEGIN
							INSERT INTO @parameterTable([Key], Value)
							SELECT
								(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
								,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
							FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

							SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

							--
							-- Trim @databases if Ola Hallengren style has been chosen
							--
							BEGIN
								SET @databases = LTRIM(RTRIM(@databases));
								WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
								BEGIN
									SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
								END;
							END;
						END;

						--
						-- Get the list of databases to process
						--
						BEGIN
							SELECT d.DatabaseName, d.[Order]
							INTO #dbList
							FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
						END;

						--
						-- Collect data
						--
						BEGIN
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
							FROM #dbList AS dl
							INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
							ORDER BY dl.[Order];

							OPEN dCur;

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM dCur
								INTO @database, @replicaId;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								--
								-- If is a member of a replica, we will only execute when running on the primary
								--
								IF (@replicaId IS NULL)
				'';
				IF (@productVersion1 >= 11)
				BEGIN
					-- SQL Versions SQL2012 or higher
					SET @stmt += ''
									OR (
										(
											SELECT
											CASE
												WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
												ELSE 0
											END AS IsPrimaryServer
											FROM master.sys.availability_groups AS ag
											INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
											INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
											WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
										) = 1
									)
					'';
				END;
				SET @stmt += ''
								BEGIN
									SET @stmt = ''''
										USE '''' + QUOTENAME(@database) + '''';

										SELECT
											DB_NAME() AS DatabaseName
											,a.LogicalName
											,a.PhysicalName
											,a.Type
											,a.VolumeMountPoint
											,a.LogicalVolumeName
											,COALESCE(a.FilegroupName, ''''''''N.A.'''''''') AS FilegroupName
											,a.FileGroupType
											,a.CurrentSize
											,a.UsedSize
											,@nowUTC, @now
										FROM (
											SELECT
												df.name						AS LogicalName
												,df.physical_name			AS PhysicalName
												,df.type					AS Type
				'';
				IF ((@productVersion1 = 10) AND (@productVersion2 = 0))
				BEGIN
					-- SQL Versions SQL2008
					SET @stmt += ''
												,CAST(NULL AS nvarchar(512))	AS VolumeMountPoint
												,CAST(NULL AS nvarchar(512))	AS LogicalVolumeName
					'';
				END
				ELSE BEGIN
					-- SQL Versions SQL2008R2 or higher
					SET @stmt += ''
												,dovs.volume_mount_point	AS VolumeMountPoint
												,dovs.logical_volume_name	AS LogicalVolumeName
					'';
				END;
				SET @stmt += ''
												,fg.name					AS FilegroupName
												,fg.type					AS FileGroupType
												,CAST((df.size / 128.0) AS int) AS CurrentSize
												,CAST((CAST(FILEPROPERTY(df.name, ''''''''SpaceUsed'''''''') AS int) / 128.0) AS int) AS UsedSize
											FROM sys.database_files AS df WITH (NOLOCK)
				'';
				IF NOT ((@productVersion1 = 10) AND (@productVersion2 = 0))
				BEGIN
					-- SQL Versions SQL2008R2 or higher
					SET @stmt += ''
											CROSS APPLY sys.dm_os_volume_stats(DB_ID(), df.file_id) AS dovs
					'';
				END;
				SET @stmt += ''
											LEFT OUTER JOIN sys.filegroups AS fg WITH (NOLOCK) ON (fg.data_space_id = df.data_space_id)
										) AS a;
									'''';
									BEGIN TRY
										INSERT INTO dbo.fhsmDatabaseSize(DatabaseName, LogicalName, PhysicalName, Type, VolumeMountPoint, LogicalVolumeName, FilegroupName, FileGroupType, CurrentSize, UsedSize, TimestampUTC, Timestamp)
										EXEC sp_executesql
											@stmt
											,N''''@now datetime, @nowUTC datetime''''
											,@now = @now, @nowUTC = @nowUTC;
									END TRY
									BEGIN CATCH
										SET @errorMsg = ERROR_MESSAGE();

										SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
									END CATCH;
								END
								ELSE BEGIN
									SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
								END;
							END;

							CLOSE dCur;
							DEALLOCATE dCur;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPDatabaseSize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPDatabaseSize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPDiskSize
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPDiskSize'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPDiskSize AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPDiskSize
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						INSERT INTO dbo.fhsmDiskSize(VolumeMountPoint, LogicalVolumeName, FileSystemType, TotalBytes, FreeBytes, TimestampUTC, Timestamp)
						SELECT
							d.volume_mount_point	AS VolumeMountPoint
							,d.logical_volume_name	AS LogicalVolumeName
							,d.file_system_type		AS FileSystemType
							,d.total_bytes			AS TotalBytes
							,d.available_bytes		AS FreeBytes
							,@nowUTC				AS TimestampUTC
							,@now					AS Timestamp
						FROM (
							SELECT
								rankedDovs.volume_mount_point,
								rankedDovs.logical_volume_name,
								rankedDovs.file_system_type,
								rankedDovs.total_bytes,
								rankedDovs.available_bytes
							FROM (
								SELECT
									dovs.volume_mount_point,
									dovs.logical_volume_name,
									dovs.file_system_type,
									dovs.total_bytes,
									dovs.available_bytes,
									ROW_NUMBER() OVER(PARTITION BY dovs.volume_mount_point ORDER BY dovs.available_bytes) AS Rnk
								FROM sys.master_files AS mf
								CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.file_id) AS dovs
							) AS rankedDovs
							WHERE (rankedDovs.Rnk = 1)
						) AS d;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPDiskSize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPDiskSize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPPartitionedIndexes
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPPartitionedIndexes'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPPartitionedIndexes AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPPartitionedIndexes (
						@name nvarchar(128),
						@parameter nvarchar(max)
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @database nvarchar(128);
						DECLARE @databases nvarchar(max);
						DECLARE @errorMsg nvarchar(max);
						DECLARE @message nvarchar(max);
						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
						DECLARE @replicaId uniqueidentifier;
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);
						DECLARE @version nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--
						-- Get the parameter for the command
						--
						BEGIN
							INSERT INTO @parameterTable([Key], Value)
							SELECT
								(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
								,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
							FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

							SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

							--
							-- Trim @databases if Ola Hallengren style has been chosen
							--
							BEGIN
								SET @databases = LTRIM(RTRIM(@databases));
								WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
								BEGIN
									SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
								END;
							END;
						END;
				'';
				SET @stmt += ''

						--
						-- Get the list of databases to process
						--
						BEGIN
							SELECT d.DatabaseName, d.[Order]
							INTO #dbList
							FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
						END;

						--
						-- Collect data
						--
						BEGIN
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
							FROM #dbList AS dl
							INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
							ORDER BY dl.[Order];

							OPEN dCur;
				'';
				SET @stmt += ''

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM dCur
								INTO @database, @replicaId;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								--
								-- If is a member of a replica, we will only execute when running on the primary
								--
								IF (@replicaId IS NULL)
				'';
				IF (@productVersion1 >= 11)
				BEGIN
					-- SQL Versions SQL2012 or higher
					SET @stmt += ''
									OR (
										(
											SELECT
											CASE
												WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
												ELSE 0
											END AS IsPrimaryServer
											FROM master.sys.availability_groups AS ag
											INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
											INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
											WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
										) = 1
									)
					'';
				END;
				SET @stmt += ''
								BEGIN
									SET @stmt = ''''
										USE '''' + QUOTENAME(@database) + '''';

										SELECT
											DB_NAME() AS DatabaseName
											,sch.name AS SchemaName
											,o.name AS ObjectName
											,i.name AS IndexName
											,i.type_desc AS IndexTypeDesc
											,ps.name AS PartitionSchemeName
											,ds.name AS PartitionFilegroupName
											,pf.name AS PartitionFunctionName
											,pf.boundary_value_on_right AS PartitionFunctionValueOnRight
											,pf.create_date AS PartitionFunctionCreateDate
											,pf.modify_date AS PartitionFunctionModifyDate
											,prv.value AS PartitionBoundaryValue
											,c.name AS PartitionColumn
											,pstats.partition_number AS PartitionNumber
											,p.data_compression_desc AS PartitionCompressionTypeDesc
											,pstats.row_count AS PartitionRowCount
											,@nowUTC, @now
										FROM sys.dm_db_partition_stats AS pstats
										INNER JOIN sys.objects AS o ON (o.object_id = pstats.object_id)
										INNER JOIN sys.schemas AS sch ON (sch.schema_id = o.schema_id)
										INNER JOIN sys.partitions AS p ON (p.partition_id = pstats.partition_id)
										INNER JOIN sys.destination_data_spaces AS dds ON (dds.destination_id = pstats.partition_number)
										INNER JOIN sys.data_spaces AS ds ON (ds.data_space_id = dds.data_space_id)
										INNER JOIN sys.partition_schemes AS ps ON (ps.data_space_id = dds.partition_scheme_id)
										INNER JOIN sys.partition_functions AS pf ON (pf.function_id = ps.function_id)
										INNER JOIN sys.indexes AS i ON (i.object_id = pstats.object_id) AND (i.index_id = pstats.index_id) AND (i.data_space_id = dds.partition_scheme_id)
										INNER JOIN sys.index_columns AS ic ON (ic.index_id = i.index_id) AND (ic.object_id = i.object_id) AND (ic.partition_ordinal > 0)
										INNER JOIN sys.columns AS c ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
										LEFT OUTER JOIN sys.partition_range_values AS prv ON (prv.function_id = pf.function_id) AND (pstats.partition_number = (CASE pf.boundary_value_on_right WHEN 0 THEN prv.boundary_id ELSE (prv.boundary_id + 1) END))
									'''';
									BEGIN TRY
										INSERT INTO dbo.fhsmPartitionedIndexes(
											DatabaseName, SchemaName, ObjectName, IndexName, IndexTypeDesc
											,PartitionSchemeName
											,PartitionFilegroupName, PartitionFunctionName, PartitionFunctionValueOnRight, PartitionFunctionCreateDate, PartitionFunctionModifyDate, PartitionBoundaryValue, PartitionColumn
											,PartitionNumber, PartitionCompressionTypeDesc, PartitionRowCount
											,TimestampUTC, Timestamp
										)
										EXEC sp_executesql
											@stmt
											,N''''@now datetime, @nowUTC datetime''''
											,@now = @now, @nowUTC = @nowUTC;
									END TRY
									BEGIN CATCH
										SET @errorMsg = ERROR_MESSAGE();

										SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
									END CATCH;
								END
								ELSE BEGIN
									SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
								END;
							END;

							CLOSE dCur;
							DEALLOCATE dCur;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPPartitionedIndexes
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPPartitionedIndexes'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPSpaceUsed
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPSpaceUsed'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPSpaceUsed AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPSpaceUsed (
						@database nvarchar(128)
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @isMemoryOptimizedStmt nvarchar(max);
						DECLARE @stmt nvarchar(max);

						--
						-- Test if version_generated_inrow (and thereby all other *version*) exists on dm_db_index_operational_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''tables'''') AND (sc.name = ''''is_memory_optimized'''')
							)
							BEGIN
								SET @isMemoryOptimizedStmt = ''''
									/*
									** If the table is memory-optimized, return NULL for reserved, data, index_size and unused.
									*/
									IF (SELECT t.is_memory_optimized FROM '''' + QUOTENAME(@database) + ''''.sys.tables AS t WITH (NOLOCK) WHERE t.object_id = @objectId) = 1
									BEGIN
										INSERT INTO @spaceUsed(DatabaseName, SchemaName, ObjectName, IndexName, PartitionNumber, IsMemoryOptimized, Rows, Reserved, Data, IndexSize, Unused)
										SELECT
											@database AS DatabaseName
											,@schema AS SchemaName
											,@object AS ObjectName
											,i.name AS IndexName 
											,1 AS PartitionNumber
											,1 AS IsMemoryOptimized
											,SUM(p.rows) AS Rows
											,NULL AS Reserved
											,NULL AS Data
											,NULL AS IndexSize
											,NULL AS Unused
										FROM '''' + QUOTENAME(@database) + ''''.sys.partitions AS p WITH (NOLOCK)
										LEFT OUTER JOIN '''' + QUOTENAME(@database) + ''''.sys.indexes AS i WITH (NOLOCK) ON (i.object_id = p.object_id) AND (i.index_id = p.index_id)
										WHERE (p.index_id IN (0, 1, 5)) AND (p.object_id = @objectId)
										GROUP BY i.name;
									END
								'''';
							END
							ELSE BEGIN
								SET @isMemoryOptimizedStmt = ''''
									/*
									** Dummy code as this SQL server version does not support memory optimized tables
									*/
									IF (1 = 0)
									BEGIN
										SET @objectId = @objectId;
									END
								'''';
							END;
						END;

						SET @stmt = ''''
							DECLARE @object nvarchar(128);
							DECLARE @objectId int;
							DECLARE @pages bigint;
							DECLARE @reservedpages bigint;
							DECLARE @rowCount bigint;
							DECLARE @schema nvarchar(128);
							DECLARE @spaceUsed TABLE(
								DatabaseName nvarchar(128), SchemaName nvarchar(128), ObjectName nvarchar(128), IndexName nvarchar(128), PartitionNumber int
								,IsMemoryOptimized bit, Rows bigint, Reserved int, Data int, IndexSize int, Unused int
							);
							DECLARE @usedpages bigint;

							DECLARE oCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT sch.name AS [Schema], o.name AS Object, o.object_id AS ObjectId
							FROM '''' + QUOTENAME(@database) + ''''.sys.schemas AS sch WITH (NOLOCK)
							INNER JOIN '''' + QUOTENAME(@database) + ''''.sys.objects AS o WITH (NOLOCK) ON (o.schema_id = sch.schema_id)
							WHERE (o.type = ''''''''U'''''''')
							ORDER BY sch.name, o.name;

							OPEN OCur;

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM oCur
								INTO @schema, @object, @objectId;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								'''' + @isMemoryOptimizedStmt + ''''
								ELSE BEGIN
									INSERT INTO @spaceUsed(DatabaseName, SchemaName, ObjectName, IndexName, PartitionNumber, IsMemoryOptimized, Rows, Reserved, Data, IndexSize, Unused)
									SELECT
										@database AS DatabaseName
										,@schema AS SchemaName
										,@object AS ObjectName
										,a.IndexName
										,a.PartitionNumber
										,0 AS IsMemoryOptimized
										,a.[RowCount] AS Rows
										,((a.ReservedPageCount + a.XMLFullReservedPageCount) * 8) AS Reserved
										,(a.Pages * 8) AS Data
										,((CASE WHEN (a.UsedPageCount + a.XMLFullUsedPageCount) > a.Pages THEN ((a.UsedPageCount + a.XMLFullUsedPageCount) - a.Pages) ELSE 0 END) * 8) AS IndexSize
										,((CASE WHEN (a.ReservedPageCount + a.XMLFullReservedPageCount) > (a.UsedPageCount + a.XMLFullUsedPageCount) THEN ((a.ReservedPageCount + a.XMLFullReservedPageCount) - (a.UsedPageCount + a.XMLFullUsedPageCount)) ELSE 0 END) * 8) AS Unused
									FROM (
										/*
										** Now calculate the summary data.
										*  Note that LOB Data and Row-overflow Data are counted as Data Pages for the base table
										*  For non-clustered indices they are counted towards the index pages
										*/
										SELECT
											ddps.object_id
											,i.name AS IndexName
											,ddps.partition_number AS PartitionNumber
											,ddps.reserved_page_count AS ReservedPageCount
											,ddps.used_page_count AS UsedPageCount
											,CASE
												WHEN (ddps.index_id < 2) THEN (ddps.in_row_data_page_count + ddps.lob_used_page_count + ddps.row_overflow_used_page_count)
												ELSE (ddps.lob_used_page_count + ddps.row_overflow_used_page_count)
											END AS Pages
											,ddps.row_count AS [RowCount]
											,COALESCE(XMLFull.ReservedPageCount, 0) AS XMLFullReservedPageCount
											,COALESCE(XMLFull.UsedPageCount, 0) AS XMLFullUsedPageCount
										FROM '''' + QUOTENAME(@database) + ''''.sys.dm_db_partition_stats AS ddps WITH (NOLOCK)
										LEFT OUTER JOIN '''' + QUOTENAME(@database) + ''''.sys.indexes AS i WITH (NOLOCK) ON (i.object_id = ddps.object_id) AND (i.index_id = ddps.index_id)
										OUTER APPLY (
											/*
											** Check if table has XML Indexes or Fulltext Indexes which use internal tables tied to this table
											*/
											SELECT
												p.reserved_page_count AS ReservedPageCount
												,p.used_page_count AS UsedPageCount
											FROM '''' + QUOTENAME(@database) + ''''.sys.dm_db_partition_stats AS p WITH (NOLOCK)
											INNER JOIN '''' + QUOTENAME(@database) + ''''.sys.internal_tables AS it WITH (NOLOCK) ON (it.object_id = p.object_id)
											WHERE (it.parent_id = ddps.object_id) AND (p.partition_id = ddps.partition_id) AND (it.internal_type IN (202, 204, 207, 211, 212, 213, 214, 215, 216, 221, 222, 236))
										) AS XMLFull
										WHERE (ddps.object_id = @objectId)
									) AS a;
								END;
							END;

							CLOSE OCur;
							DEALLOCATE OCur;

							SELECT *
							FROM @spaceUsed AS su
							ORDER BY su.DatabaseName, su.SchemaName, su.ObjectName, su.IndexName;
						'''';
						EXEC sp_executesql
							@stmt
							,N''''@database nvarchar(128)''''
							,@database = @database;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPSpaceUsed
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPSpaceUsed'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPTableSize
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID(''''dbo.fhsmSPTableSize'''', ''''P'''') IS NULL
					BEGIN
						EXEC(''''CREATE PROC dbo.fhsmSPTableSize AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER PROC dbo.fhsmSPTableSize (
						@name nvarchar(128),
						@parameter nvarchar(max)
					)
					AS
					BEGIN
						SET NOCOUNT ON;

						DECLARE @database nvarchar(128);
						DECLARE @databases nvarchar(max);
						DECLARE @errorMsg nvarchar(max);
						DECLARE @message nvarchar(max);
						DECLARE @now datetime;
						DECLARE @nowUTC datetime;
						DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
						DECLARE @replicaId uniqueidentifier;
						DECLARE @spaceUsed TABLE(DatabaseName nvarchar(128), SchemaName nvarchar(128), ObjectName nvarchar(128), IndexName nvarchar(128), PartitionNumber int, IsMemoryOptimized bit, Rows bigint, Reserved int, Data int, IndexSize int, Unused int);
						DECLARE @stmt nvarchar(max);
						DECLARE @thisTask nvarchar(128);
						DECLARE @version nvarchar(128);

						SET @thisTask = OBJECT_NAME(@@PROCID);
						SET @version = '''''' + @version + '''''';

						--
						-- Get the parameter for the command
						--
						BEGIN
							INSERT INTO @parameterTable([Key], Value)
							SELECT
								(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
								,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
							FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

							SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

							--
							-- Trim @databases if Ola Hallengren style has been chosen
							--
							BEGIN
								SET @databases = LTRIM(RTRIM(@databases));
								WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
								BEGIN
									SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
								END;
							END;
						END;

						--
						-- Get the list of databases to process
						--
						BEGIN
							SELECT d.DatabaseName, d.[Order]
							INTO #dbList
							FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
						END;

						--
						-- Collect data
						--
						BEGIN
							SELECT
								@now = SYSDATETIME()
								,@nowUTC = SYSUTCDATETIME();

							DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
							SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
							FROM #dbList AS dl
							INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
							ORDER BY dl.[Order];

							OPEN dCur;

							WHILE (1 = 1)
							BEGIN
								FETCH NEXT FROM dCur
								INTO @database, @replicaId;

								IF (@@FETCH_STATUS <> 0)
								BEGIN
									BREAK;
								END;

								--
								-- If is a member of a replica, we will only execute when running on the primary
								--
								IF (@replicaId IS NULL)
				'';
				IF (@productVersion1 >= 11)
				BEGIN
					-- SQL Versions SQL2012 or higher
					SET @stmt += ''
									OR (
										(
											SELECT
											CASE
												WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
												ELSE 0
											END AS IsPrimaryServer
											FROM master.sys.availability_groups AS ag
											INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
											INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
											WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
										) = 1
									)
					'';
				END;
				SET @stmt += ''
								BEGIN
									DELETE @spaceUsed;

									BEGIN TRY
										SET @stmt = ''''EXEC dbo.fhsmSPSpaceUsed @database = @database;'''';
										INSERT INTO @spaceUsed
										EXEC sp_executesql
											@stmt
											,N''''@database nvarchar(128)''''
											,@database = @database;

										INSERT INTO dbo.fhsmTableSize(DatabaseName, SchemaName, ObjectName, IndexName, PartitionNumber, IsMemoryOptimized, Rows, Reserved, Data, IndexSize, Unused, TimestampUTC, Timestamp)
										SELECT su.DatabaseName, su.SchemaName, su.ObjectName, su.IndexName, su.PartitionNumber, su.IsMemoryOptimized, su.Rows, su.Reserved, su.Data, su.IndexSize, su.Unused, @nowUTC, @now
										FROM @spaceUsed AS su;
									END TRY
									BEGIN CATCH
										SET @errorMsg = ERROR_MESSAGE();

										SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
										EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
									END CATCH;
								END
								ELSE BEGIN
									SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
								END;
							END;

							CLOSE dCur;
							DEALLOCATE dCur;
						END;

						RETURN 0;
					END;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPTableSize
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPTableSize'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPCapacity
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPCapacity'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPCapacity AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = '''';
			SET @stmt += ''
				ALTER PROC dbo.fhsmSPCapacity (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @processingId int;
					DECLARE @processingTimestamp datetime;
					DECLARE @processingTimestampUTC datetime;
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
			'';
			SET @stmt += ''
						--
						-- Calling dbo.fhsmSPAllocationUnits
						--
						BEGIN
							SET @message = ''''Before calling dbo.fhsmSPAllocationUnits'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

							--
							-- Insert Processing record and remember the @id in the variable @processingId
							-- Type: 1: Calling dbo.fhsmSPAllocationUnits
							--
							SET @processingId = NULL;
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 1, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							EXEC dbo.fhsmSPAllocationUnits @name = @name, @parameter = @parameter;

							--
							-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
							-- Type: 1: Loading data into dbo.fhsmSPAllocationUnits
							--
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 1, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							SET @message = ''''After calling dbo.fhsmSPAllocationUnits'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
						END;
			'';
			SET @stmt += ''
						--
						-- Calling dbo.fhsmSPDatabaseSize
						--
						BEGIN
							SET @message = ''''Before calling dbo.fhsmSPDatabaseSize'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

							--
							-- Insert Processing record and remember the @id in the variable @processingId
							-- Type: 2: Calling dbo.fhsmSPDatabaseSize
							--
							SET @processingId = NULL;
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 2, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							EXEC dbo.fhsmSPDatabaseSize @name = @name, @parameter = @parameter;

							--
							-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
							-- Type: 2: Loading data into dbo.fhsmSPDatabaseSize
							--
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 2, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							SET @message = ''''After calling dbo.fhsmSPDatabaseSize'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
						END;
			'';
		--
		-- SQL Versions SQL2008R2 or higher
		--
		IF NOT ((@productVersion1 = 10) AND (@productVersion2 = 0))
		BEGIN
			SET @stmt += ''
						--
						-- Calling dbo.fhsmSPDiskSize
						--
						BEGIN
							SET @message = ''''Before calling dbo.fhsmSPDiskSize'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

							--
							-- Insert Processing record and remember the @id in the variable @processingId
							-- Type: 3: Calling dbo.fhsmSPDiskSize
							--
							SET @processingId = NULL;
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 3, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							EXEC dbo.fhsmSPDiskSize;

							--
							-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
							-- Type: 3: Loading data into dbo.fhsmSPDiskSize
							--
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 3, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							SET @message = ''''After calling dbo.fhsmSPDiskSize'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
						END;
			'';
		END;
			SET @stmt += ''
						--
						-- Calling dbo.fhsmSPPartitionedIndexes
						--
						BEGIN
							SET @message = ''''Before calling dbo.fhsmSPPartitionedIndexes'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

							--
							-- Insert Processing record and remember the @id in the variable @processingId
							-- Type: 4: Calling dbo.fhsmSPPartitionedIndexes
							--
							SET @processingId = NULL;
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 4, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							EXEC dbo.fhsmSPPartitionedIndexes @name = @name, @parameter = @parameter;

							--
							-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
							-- Type: 4: Loading data into dbo.fhsmSPPartitionedIndexes
							--
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 4, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							SET @message = ''''After calling dbo.fhsmSPPartitionedIndexes'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
						END;
			'';
			SET @stmt += ''
						--
						-- Calling dbo.fhsmSPTableSize
						--
						BEGIN
							SET @message = ''''Before calling dbo.fhsmSPTableSize'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

							--
							-- Insert Processing record and remember the @id in the variable @processingId
							-- Type: 5: Calling dbo.fhsmSPTableSize
							--
							SET @processingId = NULL;
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 5, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							EXEC dbo.fhsmSPTableSize @name = @name, @parameter = @parameter;

							--
							-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
							-- Type: 5: Loading data into dbo.fhsmSPTableSize
							--
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 5, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							SET @message = ''''After calling dbo.fhsmSPTableSize'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
						END;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPCapacity
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPCapacity'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlCapacity
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlCapacity'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlCapacity AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlCapacity (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlCapacity
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlCapacity'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
		AS (
			SELECT
				1								AS Enabled
				,''dbo.fhsmAllocationUnits''		AS TableName
				,1								AS Sequence
				,''TimestampUTC''					AS TimeColumn
				,1								AS IsUtc
				,30								AS Days
				,NULL							AS Filter

			UNION ALL

			SELECT
				1								AS Enabled
				,''dbo.fhsmDatabaseSize''			AS TableName
				,1								AS Sequence
				,''TimestampUTC''					AS TimeColumn
				,1								AS IsUtc
				,180							AS Days
				,NULL							AS Filter

			UNION ALL

			SELECT
				1								AS Enabled
				,''dbo.fhsmDiskSize''				AS TableName
				,1								AS Sequence
				,''TimestampUTC''					AS TimeColumn
				,1								AS IsUtc
				,180							AS Days
				,NULL							AS Filter

			UNION ALL

			SELECT
				1								AS Enabled
				,''dbo.fhsmPartitionedIndexes''	AS TableName
				,1								AS Sequence
				,''TimestampUTC''					AS TimeColumn
				,1								AS IsUtc
				,730							AS Days
				,NULL							AS Filter

			UNION ALL

			SELECT
				1								AS Enabled
				,''dbo.fhsmTableSize''			AS TableName
				,1								AS Sequence
				,''TimestampUTC''					AS TimeColumn
				,1								AS IsUtc
				,60								AS Days
				,NULL							AS Filter
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableCapacity										AS Enabled
				,0													AS DeploymentStatus
				,''Capacity''											AS Name
				,PARSENAME(''dbo.fhsmSPCapacity'', 1)					AS Task
				,12 * 60 * 60										AS ExecutionDelaySec
				,CAST(''1900-1-1T07:00:00.0000'' AS datetime2(0))		AS FromTime
				,CAST(''1900-1-1T08:00:00.0000'' AS datetime2(0))		AS ToTime
				,1, 1, 1, 1, 1, 1, 1								-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb, tempdb''''''	AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
		) AS (
			--
			-- dbo.fhsmAllocationUnits
			--
			SELECT
				''File group'' AS DimensionName
				,''FileGroupKey'' AS DimensionKey
				,''dbo.fhsmAllocationUnits'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[FilegroupName]'', NULL, NULL, NULL
				,''Database'', ''File group'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmAllocationUnits'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', NULL
				,''Database'', ''Schema'', ''Object'', ''Index'', NULL

			--
			-- dbo.fhsmDatabaseSize
			--
			UNION ALL

			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmDatabaseSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Database file'' AS DimensionName
				,''DatabaseFileKey'' AS DimensionKey
				,''dbo.fhsmDatabaseSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[LogicalName]'', ''src.[PhysicalName]'', ''CASE src.[Type] WHEN 0 THEN ''''Data'''' WHEN 1 THEN ''''Log'''' WHEN 2 THEN ''''Filestream'''' WHEN 4 THEN ''''Fulltext'''' ELSE ''''Other'''' END'', ''src.[FilegroupName]''
				,''Database name'', ''Logical name'', ''Physical name'', ''Type'', ''File group''

			UNION ALL

			SELECT
				''Disk'' AS DimensionName
				,''DiskKey'' AS DimensionKey
				,''dbo.fhsmDatabaseSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[VolumeMountPoint]'', NULL, NULL, NULL, NULL
				,''Disk'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''File group'' AS DimensionName
				,''FileGroupKey'' AS DimensionKey
				,''dbo.fhsmDatabaseSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[FilegroupName]'', NULL, NULL, NULL
				,''Database'', ''File group'', NULL, NULL, NULL

			--
			-- dbo.fhsmDiskSize
			--
			UNION ALL

			SELECT
				''Disk'' AS DimensionName
				,''DiskKey'' AS DimensionKey
				,''dbo.fhsmDiskSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[VolumeMountPoint]'', NULL, NULL, NULL, NULL
				,''Disk'', NULL, NULL, NULL, NULL

			--
			-- dbo.fhsmPartitionedIndexes
			--
			UNION ALL

			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmPartitionedIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmPartitionedIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL, NULL
				,''Database'', ''Schema'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmPartitionedIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL, NULL
				,''Database'', ''Schema'', ''Object'', NULL, NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmPartitionedIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', NULL
				,''Database'', ''Schema'', ''Object'', ''Index'', NULL

			UNION ALL

			SELECT
				''File group'' AS DimensionName
				,''FileGroupKey'' AS DimensionKey
				,''dbo.fhsmPartitionedIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[PartitionFilegroupName]'', NULL, NULL, NULL
				,''Database'', ''File group'', NULL, NULL, NULL

			--
			-- dbo.fhsmTableSize
			--
			UNION ALL

			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmTableSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmTableSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL, NULL
				,''Database'', ''Schema'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmTableSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL, NULL
				,''Database'', ''Schema'', ''Object'', NULL, NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmTableSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', NULL
				,''Database'', ''Schema'', ''Object'', ''Index'', NULL

			UNION ALL

			SELECT
				''Object partition'' AS DimensionName
				,''ObjectPartitionKey'' AS DimensionKey
				,''dbo.fhsmTableSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''CAST(src.[PartitionNumber] AS nvarchar)'', NULL
				,''Database'', ''Schema'', ''Object'', ''Partition'', NULL

			UNION ALL

			SELECT
				''Index partition'' AS DimensionName
				,''IndexPartitionKey'' AS DimensionKey
				,''dbo.fhsmTableSize'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', ''CAST(src.[PartitionNumber] AS nvarchar)''
				,''Database'', ''Schema'', ''Object'', ''Index'', ''Partition''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.SrcColumn5 = src.SrcColumn5
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
				,tgt.OutputColumn5 = src.OutputColumn5
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4, src.SrcColumn5
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4, src.OutputColumn5
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmAllocationUnits'';
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmDatabaseSize'';
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmDiskSize'';
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmPartitionedIndexes'';
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmTableSize'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:Connections.sql modified: 2025.08.05 19.09.11
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableConnections bit;

	SET @enableConnections = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing Connections'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmConnections and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmConnections'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmConnections'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmConnections(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,HostName nvarchar(128) NULL
					,ProgramName nvarchar(128) NULL
					,ClientInterfaceName nvarchar(32) NULL
					,IsUserProcess bit NOT NULL
					,ConnectionCount int NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_Connections PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmConnections'')) AND (i.name = ''NC_fhsmConnections_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmConnections_TimestampUTC] to table dbo.fhsmConnections'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmConnections_TimestampUTC ON dbo.fhsmConnections(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmConnections'')) AND (i.name = ''NC_fhsmConnections_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmConnections_Timestamp] to table dbo.fhsmConnections'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmConnections_Timestamp ON dbo.fhsmConnections(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmConnections
		--
		BEGIN
			SET @objectName = ''dbo.fhsmConnections'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN

		--
		-- Create fact view @pbiSchema.[Connections]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Connections'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Connections'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Connections'') + ''
				AS
				SELECT
					c.IsUserProcess
					,c.ConnectionCount
					,c.Timestamp
					,CAST(c.Timestamp AS date) AS Date
					,(DATEPART(HOUR, c.Timestamp) * 60 * 60) + (DATEPART(MINUTE, c.Timestamp) * 60) + (DATEPART(SECOND, c.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(c.DatabaseName, DEFAULT,    DEFAULT,       DEFAULT,               DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(c.DatabaseName, c.HostName, c.ProgramName, c.ClientInterfaceName, DEFAULT, DEFAULT) AS k) AS ConnectionInfoKey
				FROM dbo.fhsmConnections AS c;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Connections]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Connections'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPConnections
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPConnections'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPConnections AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPConnections (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						--
						-- Test if database_id exists on dm_exec_sessions
						--
						BEGIN
							DECLARE @databaseIdGroupStmt nvarchar(max);
							DECLARE @databaseIdStmt nvarchar(max);
							DECLARE @databaseIdJoinStmt nvarchar(max);
							DECLARE @databaseIdWhereStmt nvarchar(max);

							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_exec_sessions'''') AND (sc.name = ''''database_id'''')
							)
							BEGIN
								SET @databaseIdGroupStmt= ''''d.name,'''';
								SET @databaseIdStmt = ''''d.Name'''';
								SET @databaseIdJoinStmt = ''''INNER JOIN sys.databases AS d WITH (NOLOCK) ON (d.database_id = des.database_id)'''';
								SET @databaseIdWhereStmt= ''''WHERE (des.database_id > 0)'''';
							END
							ELSE BEGIN
								SET @databaseIdGroupStmt= '''''''';
								SET @databaseIdStmt = ''''''''''''N.A.'''''''''''';
								SET @databaseIdJoinStmt = '''''''';
								SET @databaseIdWhereStmt= '''''''';
							END;
						END;

						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						SET @stmt = ''''
							INSERT INTO dbo.fhsmConnections(
								DatabaseName, HostName, ProgramName, ClientInterfaceName
								,IsUserProcess, ConnectionCount
								,TimestampUTC, Timestamp
							)
							SELECT
								'''' + @databaseIdStmt + '''' AS DatabaseName,
								des.host_name AS HostName,
								des.program_name AS ProgramName,
								des.client_interface_name AS ClientInterfaceName,
								des.is_user_process AS IsUserProcess,
								COUNT(*) AS ConnectionCount,
								@nowUTC, @now
							FROM sys.dm_exec_sessions AS des WITH (NOLOCK)
							'''' + @databaseIdJoinStmt + ''''
							'''' + @databaseIdWhereStmt + ''''
							GROUP BY
								'''' + @databaseIdGroupStmt + ''''
								des.host_name,
								des.program_name,
								des.client_interface_name,
								des.is_user_process;
						'''';
						EXEC sp_executesql
							@stmt
							,N''''@nowUTC datetime, @now datetime''''
							,@nowUTC = @nowUTC, @now = @now;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPConnections
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPConnections'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmConnections''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableConnections								AS Enabled
				,0												AS DeploymentStatus
				,''Connections''									AS Name
				,PARSENAME(''dbo.fhsmSPConnections'', 1)			AS Task
				,5 * 60											AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmConnections'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Connection info'' AS DimensionName
				,''ConnectionInfoKey'' AS DimensionKey
				,''dbo.fhsmConnections'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[HostName]'', ''src.[ProgramName]'', ''src.[ClientInterfaceName]''
				,''Database'', ''Host'', ''Program'', ''ClientInterface''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmConnections'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:CPUUtilization.sql modified: 2025.08.05 19.09.27
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableCPUUtilization bit;

	SET @enableCPUUtilization = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing CPUUtilization'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmCPUUtilization and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmCPUUtilization'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmCPUUtilization'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmCPUUtilization(
					Id int identity(1,1) NOT NULL
					,EventTimeUTC datetime NOT NULL
					,EventTime datetime NOT NULL
					,SQLProcessUtilization tinyint NOT NULL
					,SystemIdle tinyint NOT NULL
					,PageFaults int NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_CPUUtilization PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmCPUUtilization'')) AND (i.name = ''NC_fhsmCPUUtilization_EventTimeUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmCPUUtilization_EventTimeUTC] to table dbo.fhsmCPUUtilization'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmCPUUtilization_EventTimeUTC ON dbo.fhsmCPUUtilization(EventTimeUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmCPUUtilization'')) AND (i.name = ''NC_fhsmCPUUtilization_EventTime''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmCPUUtilization_EventTime] to table dbo.fhsmCPUUtilization'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmCPUUtilization_EventTime ON dbo.fhsmCPUUtilization(EventTime)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmCPUUtilization
		--
		BEGIN
			SET @objectName = ''dbo.fhsmCPUUtilization'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmCPUPerDatabase and indexes if they not already exists
		-- Create table dbo.fhsmCPUPerDatabase if it not already exists
		--
		IF OBJECT_ID(''dbo.fhsmCPUPerDatabase'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmCPUPerDatabase'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmCPUPerDatabase(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,CPUTimeMs bigint NOT NULL
					,CPUPercent decimal(5,2) NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_CPUPerDatabase PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmCPUPerDatabase'')) AND (i.name = ''NC_fhsmCPUPerDatabase_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmCPUPerDatabase_TimestampUTC] to table dbo.fhsmCPUPerDatabase'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmCPUPerDatabase_TimestampUTC ON dbo.fhsmCPUPerDatabase(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmCPUPerDatabase'')) AND (i.name = ''NC_fhsmCPUPerDatabase_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmCPUPerDatabase_Timestamp] to table dbo.fhsmCPUPerDatabase'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmCPUPerDatabase_Timestamp ON dbo.fhsmCPUPerDatabase(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmCPUPerDatabase
		--
		BEGIN
			SET @objectName = ''dbo.fhsmCPUPerDatabase'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[CPU utilization]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU utilization'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU utilization'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU utilization'') + ''
				AS
				SELECT
					cu.SQLProcessUtilization
					,cu.SystemIdle
					,100 - cu.SystemIdle - cu.SQLProcessUtilization AS OtherProcessUtilization
					,cu.PageFaults
					,cu.EventTime
					,CAST(cu.EventTime AS date) AS Date
					,(DATEPART(HOUR, cu.EventTime) * 60 * 60) + (DATEPART(MINUTE, cu.EventTime) * 60) + (DATEPART(SECOND, cu.EventTime)) AS TimeKey
				FROM dbo.fhsmCPUUtilization AS cu;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[CPU utilization]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU utilization'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[CPU per database]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU per database'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU per database'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU per database'') + ''
				AS
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
				WITH cpuPerDatabase AS (
					SELECT
						cpd.DatabaseName
						,cpd.CPUTimeMs
						,cpd.CPUPercent
						,cpd.Timestamp
						,ROW_NUMBER() OVER(PARTITION BY cpd.DatabaseName ORDER BY cpd.TimestampUTC) AS Idx
					FROM dbo.fhsmCPUPerDatabase AS cpd
				)
				'';
			END;
			SET @stmt += ''
				SELECT
					CASE
						WHEN (a.PreviousCPUTimeMs IS NULL) THEN NULL				-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
						WHEN (a.PreviousCPUTimeMs > a.CPUTimeMs) THEN a.CPUTimeMs	-- Either has the counters had an overflow or the server har been restarted
						ELSE a.CPUTimeMs - a.PreviousCPUTimeMs						-- Difference
					END AS CPUTimeMs
					,a.CPUPercent
					,a.Timestamp
					,CAST(a.Timestamp AS date) AS Date
					,(DATEPART(HOUR, a.Timestamp) * 60 * 60) + (DATEPART(MINUTE, a.Timestamp) * 60) + (DATEPART(SECOND, a.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
			'';
			SET @stmt += ''
					FROM (
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
						SELECT
							cpd.DatabaseName
							,cpd.CPUTimeMs
							,prevCpd.CPUTimeMs AS PreviousCPUTimeMs
							,cpd.CPUPercent
							,cpd.Timestamp
						FROM cpuPerDatabase AS cpd
						LEFT OUTER JOIN cpuPerDatabase AS prevCpd ON
							(prevCpd.DatabaseName = cpd.DatabaseName)
							AND (prevCpd.Idx = cpd.Idx - 1)
				'';
			END
			ELSE BEGIN
				-- SQL Versions SQL2012 or higher

				SET @stmt += ''
						SELECT
							cpd.DatabaseName
							,cpd.CPUTimeMs
							,LAG(cpd.CPUTimeMs) OVER(PARTITION BY cpd.DatabaseName ORDER BY cpd.TimestampUTC) AS PreviousCPUTimeMs
							,cpd.CPUPercent
							,cpd.Timestamp
						FROM dbo.fhsmCPUPerDatabase AS cpd
				'';
			END;
			SET @stmt += ''
				) AS a;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[CPU per database]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''CPU per database'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPCPUUtilization
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPCPUUtilization'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPCPUUtilization AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPCPUUtilization (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @ms_ticks_now bigint;
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT @ms_ticks_now = dosi.ms_ticks FROM sys.dm_os_sys_info AS dosi WITH (NOLOCK);

						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						INSERT INTO dbo.fhsmCPUUtilization(EventTime, EventTimeUTC, SQLProcessUtilization, SystemIdle, PageFaults, TimestampUTC, Timestamp)
						SELECT c.EventTime, c.EventTimeUTC, c.SQLProcessUtilization, c.SystemIdle, c.PageFaults, @nowUTC, @now
						FROM (
							SELECT
								 dateadd(ms, - 1 * (@ms_ticks_now - b.Timestamp), @now) AS EventTime
								,dateadd(ms, - 1 * (@ms_ticks_now - b.Timestamp), @nowUTC) AS EventTimeUTC
								,b.SQLProcessUtilization
								,b.SystemIdle
								,b.PageFaults
							FROM (
								SELECT
									a.record.value(''''(./Record/@id)[1]'''', ''''int'''') AS record_id
									,a.record.value(''''(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]'''', ''''int'''') AS SystemIdle
									,a.record.value(''''(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]'''', ''''int'''') AS SQLProcessUtilization
									,a.record.value(''''(./Record/SchedulerMonitorEvent/SystemHealth/PageFaults)[1]'''', ''''int'''') AS PageFaults
									,a.Timestamp
								FROM (
									SELECT
										TIMESTAMP AS Timestamp
										,CAST(dorb.record AS xml) AS record
									FROM sys.dm_os_ring_buffers AS dorb WITH (NOLOCK)
									WHERE (dorb.ring_buffer_type = N''''RING_BUFFER_SCHEDULER_MONITOR'''') AND (dorb.record LIKE ''''%<SystemHealth>%'''')
								) AS a
							) AS b
						) AS c
						WHERE NOT EXISTS (
							SELECT *
							FROM dbo.fhsmCPUUtilization AS cu
							WHERE (ABS(DATEDIFF(second, cu.EventTimeUTC, c.EventTimeUTC)) < 10)
						)
						OPTION (RECOMPILE);

						WITH
						dbCPUStats AS (
							SELECT
								pa.DatabaseId
								,DB_NAME(pa.DatabaseId) AS DatabaseName
								,SUM(qs.total_worker_time / 1000) AS CPUTimeMs
							 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
							 CROSS APPLY (
								SELECT CAST(depa.value AS int) AS DatabaseId
								FROM sys.dm_exec_plan_attributes(qs.plan_handle) AS depa
								WHERE (depa.attribute = N''''dbid'''')
							) AS pa
							GROUP BY pa.DatabaseId
						)
						INSERT INTO dbo.fhsmCPUPerDatabase(DatabaseName, CPUTimeMs, CPUPercent, TimestampUTC, Timestamp)
						SELECT
							dcs.DatabaseName
							,dcs.CPUTimeMs
							,CAST(dcs.CPUTimeMs * 1.0 / SUM(dcs.CPUTimeMs) OVER() * 100.0 AS decimal(5, 2)) AS CPUPercent
							,@nowUTC, @now
						FROM dbCPUStats AS dcs
						WHERE (dcs.DatabaseId <> 32767) -- ResourceDB
						OPTION (RECOMPILE);
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPCPUUtilization
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPCPUUtilization'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmCPUUtilization''
				,1
				,''EventTimeUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);

		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmCPUPerDatabase''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableCPUUtilization							AS Enabled
				,0												AS DeploymentStatus
				,''CPU utilization''								AS Name
				,PARSENAME(''dbo.fhsmSPCPUUtilization'', 1)		AS Task
				,5 * 60											AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3
			,OutputColumn1, OutputColumn2, OutputColumn3
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmCPUPerDatabase'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL
				,''Database'', NULL, NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3
				,OutputColumn1, OutputColumn2, OutputColumn3
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmCPUPerDatabase'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:DatabaseIO.sql modified: 2025.08.05 19.09.41
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableDatabaseIO bit;

	SET @enableDatabaseIO = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing DatabaseIO'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmDatabaseIO and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmDatabaseIO'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmDatabaseIO(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,LogicalName nvarchar(128) NOT NULL
					,PhysicalName nvarchar(260) NULL
					,Type tinyint NOT NULL
					,VolumeMountPoint nvarchar(512) NULL
					,LogicalVolumeName nvarchar(512) NULL
					,FilegroupName nvarchar(128) NULL
					,FileGroupType char(2) NULL
					,SampleMS bigint NOT NULL
					,IOStall bigint NOT NULL
					,NumOfReads bigint NOT NULL
					,NumOfBytesRead bigint NOT NULL
					,IOStallReadMS bigint NOT NULL
					,IOStallQueuedReadMS bigint NULL
					,NumOfWrites bigint NOT NULL
					,NumOfBytesWritten bigint NOT NULL
					,IOStallWriteMS bigint NOT NULL
					,IOStallQueuedWriteMS bigint NULL
					,SizeOnDiskBytes bigint NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_DatabaseIO PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column PhysicalName to table dbo.fhsmDatabaseIO if it not already exists
		--
		IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (c.name = ''PhysicalName''))
		BEGIN
			RAISERROR(''Adding column [PhysicalName] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				ALTER TABLE dbo.fhsmDatabaseIO
					ADD PhysicalName nvarchar(260) NULL;
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column VolumeMountPoint to table dbo.fhsmDatabaseIO if it not already exists
		--
		IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (c.name = ''VolumeMountPoint''))
		BEGIN
			RAISERROR(''Adding column [VolumeMountPoint] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				ALTER TABLE dbo.fhsmDatabaseIO
					ADD VolumeMountPoint nvarchar(512) NULL;
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column LogicalVolumeName to table dbo.fhsmDatabaseIO if it not already exists
		--
		IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (c.name = ''LogicalVolumeName''))
		BEGIN
			RAISERROR(''Adding column [LogicalVolumeName] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				ALTER TABLE dbo.fhsmDatabaseIO
					ADD LogicalVolumeName nvarchar(512) NULL;
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column FilegroupName to table dbo.fhsmDatabaseIO if it not already exists
		--
		IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (c.name = ''FilegroupName''))
		BEGIN
			RAISERROR(''Adding column [FilegroupName] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				ALTER TABLE dbo.fhsmDatabaseIO
					ADD FilegroupName nvarchar(128) NULL;
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column FileGroupType to table dbo.fhsmDatabaseIO if it not already exists
		--
		IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (c.name = ''FileGroupType''))
		BEGIN
			RAISERROR(''Adding column [FileGroupType] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				ALTER TABLE dbo.fhsmDatabaseIO
					ADD FileGroupType char(2) NULL;
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (i.name = ''NC_fhsmDatabaseIO_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmDatabaseIO_TimestampUTC] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmDatabaseIO_TimestampUTC ON dbo.fhsmDatabaseIO(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (i.name = ''NC_fhsmDatabaseIO_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmDatabaseIO_Timestamp] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmDatabaseIO_Timestamp ON dbo.fhsmDatabaseIO(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDatabaseIO'')) AND (i.name = ''NC_fhsmDatabaseIO_DatabaseName_LogicalName_Type''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmDatabaseIO_DatabaseName_LogicalName_Type] to table dbo.fhsmDatabaseIO'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmDatabaseIO_DatabaseName_LogicalName_Type ON dbo.fhsmDatabaseIO(DatabaseName, LogicalName, Type)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmDatabaseIO
		--
		BEGIN
			SET @objectName = ''dbo.fhsmDatabaseIO'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Database IO]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database IO'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database IO'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database IO'') + ''
				AS
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
				WITH databaseIO AS (
					SELECT
						dio.DatabaseName
						,dio.LogicalName
						,dio.PhysicalName
						,dio.VolumeMountPoint
						,dio.FilegroupName
						,dio.Type
						,dio.SampleMS
						,dio.IOStall
						,dio.NumOfReads
						,dio.NumOfBytesRead
						,dio.IOStallReadMS
						,dio.IOStallQueuedReadMS
						,dio.NumOfWrites
						,dio.NumOfBytesWritten
						,dio.IOStallWriteMS
						,dio.IOStallQueuedWriteMS
						,dio.Timestamp
						,CAST(dio.Timestamp AS date) AS Date
						,ROW_NUMBER() OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS Idx
					FROM dbo.fhsmDatabaseIO AS dio
				)
				'';
			END;
			SET @stmt += ''
				SELECT
					b.DeltaNumOfReads AS NumOfReads
					,b.DeltaNumOfBytesRead AS NumOfBytesRead
					,CASE
						WHEN b.DeltaNumOfReads = 0 THEN NULL
						ELSE b.DeltaIOStallReadMS / CAST(b.DeltaNumOfReads AS decimal(12,1))
					END AS ReadLatencyMS
					,b.DeltaNumOfWrites AS NumOfWrites
					,b.DeltaNumOfBytesWritten AS NumOfBytesWritten
					,CASE
						WHEN b.DeltaNumOfWrites = 0 THEN NULL
						ELSE b.DeltaIOStallWriteMS / CAST(b.DeltaNumOfWrites AS decimal(12,1))
					END AS WriteLatencyMS

					,b.Timestamp
					,CAST(b.Timestamp AS date) AS Date
					,(DATEPART(HOUR, b.Timestamp) * 60 * 60) + (DATEPART(MINUTE, b.Timestamp) * 60) + (DATEPART(SECOND, b.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.LogicalName, b.PhysicalName,
						CASE b.Type
							WHEN 0 THEN ''''Data''''
							WHEN 1 THEN ''''Log''''
							WHEN 2 THEN ''''Filestream''''
							WHEN 4 THEN ''''Fulltext''''
							ELSE ''''Other''''
						END,
					b.FilegroupName, DEFAULT) AS k) AS DatabaseFileKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.VolumeMountPoint, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DiskKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.FilegroupName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS FileGroupKey
			'';
			SET @stmt += ''
				FROM (
					SELECT
						CASE
							WHEN (a.PreviousIOStall IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL					-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
							WHEN (a.PreviousIOStall > a.IOStall) OR (a.PreviousSampleMS > a.SampleMS) THEN a.IOStall	-- Either has the counters had an overflow or the server har been restarted
							ELSE a.IOStall - a.PreviousIOStall															-- Difference
						END AS DeltaIOStall
						,CASE
							WHEN (a.PreviousNumOfReads IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousNumOfReads > a.NumOfReads) OR (a.PreviousSampleMS > a.SampleMS) THEN a.NumOfReads
							ELSE a.NumOfReads - a.PreviousNumOfReads
						END AS DeltaNumOfReads
						,CASE
							WHEN (a.PreviousNumOfBytesRead IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousNumOfBytesRead > a.NumOfBytesRead) OR (a.PreviousSampleMS > a.SampleMS) THEN a.NumOfBytesRead
							ELSE a.NumOfBytesRead - a.PreviousNumOfBytesRead
						END AS DeltaNumOfBytesRead
						,CASE
							WHEN (a.PreviousIOStallReadMS IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousIOStallReadMS > a.IOStallReadMS) OR (a.PreviousSampleMS > a.SampleMS) THEN a.IOStallReadMS
							ELSE a.IOStallReadMS - a.PreviousIOStallReadMS
						END AS DeltaIOStallReadMS
						,CASE
							WHEN (a.PreviousIOStallQueuedReadMS IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousIOStallQueuedReadMS > a.IOStallQueuedReadMS) OR (a.PreviousSampleMS > a.SampleMS) THEN a.IOStallQueuedReadMS
							ELSE a.IOStallQueuedReadMS - a.PreviousIOStallQueuedReadMS
						END AS DeltaIOStallQueuedReadMS
						,CASE
							WHEN (a.PreviousNumOfWrites IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousNumOfWrites > a.NumOfWrites) OR (a.PreviousSampleMS > a.SampleMS) THEN a.NumOfWrites
							ELSE a.NumOfWrites - a.PreviousNumOfWrites
						END AS DeltaNumOfWrites
						,CASE
							WHEN (a.PreviousNumOfBytesWritten IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousNumOfBytesWritten > a.NumOfBytesWritten) OR (a.PreviousSampleMS > a.SampleMS) THEN a.NumOfBytesWritten
							ELSE a.NumOfBytesWritten - a.PreviousNumOfBytesWritten
						END AS DeltaNumOfBytesWritten
						,CASE
							WHEN (a.PreviousIOStallWriteMS IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousIOStallWriteMS > a.IOStallWriteMS) OR (a.PreviousSampleMS > a.SampleMS) THEN a.IOStallWriteMS
							ELSE a.IOStallWriteMS - a.PreviousIOStallWriteMS
						END AS DeltaIOStallWriteMS
						,CASE
							WHEN (a.PreviousIOStallQueuedWriteMS IS NULL) OR (a.PreviousSampleMS IS NULL) THEN NULL
							WHEN (a.PreviousIOStallQueuedWriteMS > a.IOStallQueuedWriteMS) OR (a.PreviousSampleMS > a.SampleMS) THEN a.IOStallQueuedWriteMS
							ELSE a.IOStallQueuedWriteMS - a.PreviousIOStallQueuedWriteMS
						END AS DeltaIOStallQueuedWriteMS

						,a.Timestamp
						,a.DatabaseName
						,a.LogicalName
						,a.PhysicalName
						,a.VolumeMountPoint
						,a.FilegroupName
						,a.Type
			'';
			SET @stmt += ''
					FROM (
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
						SELECT
							dio.SampleMS
							,prevDio.SampleMS AS PreviousSampleMS

							,dio.IOStall
							,prevDio.IOStall AS PreviousIOStall

							,dio.NumOfReads
							,prevDio.NumOfReads AS PreviousNumOfReads

							,dio.NumOfBytesRead
							,prevDio.NumOfBytesRead AS PreviousNumOfBytesRead

							,dio.IOStallReadMS
							,prevDio.IOStallReadMS AS PreviousIOStallReadMS

							,dio.IOStallQueuedReadMS
							,prevDio.IOStallQueuedReadMS AS PreviousIOStallQueuedReadMS

							,dio.NumOfWrites
							,prevDio.NumOfWrites AS PreviousNumOfWrites

							,dio.NumOfBytesWritten
							,prevDio.NumOfBytesWritten AS PreviousNumOfBytesWritten

							,dio.IOStallWriteMS
							,prevDio.IOStallWriteMS AS PreviousIOStallWriteMS

							,dio.IOStallQueuedWriteMS
							,prevDio.IOStallQueuedWriteMS AS PreviousIOStallQueuedWriteMS

							,dio.Timestamp
							,dio.DatabaseName
							,dio.LogicalName
							,dio.PhysicalName
							,dio.VolumeMountPoint
							,dio.FilegroupName
							,dio.Type
						FROM databaseIO AS dio
						LEFT OUTER JOIN databaseIO AS prevDio ON
							(prevDio.DatabaseName = dio.DatabaseName)
							AND (prevDio.LogicalName = dio.LogicalName)
							AND (prevDio.Type = dio.Type)
							AND (prevDio.Idx = dio.Idx - 1)
				'';
			END
			ELSE BEGIN
				-- SQL Versions SQL2012 or higher

				SET @stmt += ''
						SELECT
							dio.SampleMS
							,LAG(dio.SampleMS) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousSampleMS

							,dio.IOStall
							,LAG(dio.IOStall) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousIOStall

							,dio.NumOfReads
							,LAG(dio.NumOfReads) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousNumOfReads

							,dio.NumOfBytesRead
							,LAG(dio.NumOfBytesRead) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousNumOfBytesRead

							,dio.IOStallReadMS
							,LAG(dio.IOStallReadMS) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousIOStallReadMS

							,dio.IOStallQueuedReadMS
							,LAG(dio.IOStallQueuedReadMS) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousIOStallQueuedReadMS

							,dio.NumOfWrites
							,LAG(dio.NumOfWrites) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousNumOfWrites

							,dio.NumOfBytesWritten
							,LAG(dio.NumOfBytesWritten) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousNumOfBytesWritten

							,dio.IOStallWriteMS
							,LAG(dio.IOStallWriteMS) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousIOStallWriteMS

							,dio.IOStallQueuedWriteMS
							,LAG(dio.IOStallQueuedWriteMS) OVER(PARTITION BY dio.DatabaseName, dio.LogicalName, dio.Type ORDER BY dio.TimestampUTC) AS PreviousIOStallQueuedWriteMS

							,dio.Timestamp
							,dio.DatabaseName
							,dio.LogicalName
							,dio.PhysicalName
							,dio.VolumeMountPoint
							,dio.FilegroupName
							,dio.Type
						FROM dbo.fhsmDatabaseIO AS dio
				'';
			END;
			SET @stmt += ''
					) AS a
				) AS b
			'';
			SET @stmt += ''
				WHERE
					(b.DeltaIOStall <> 0)
					OR (b.DeltaNumOfReads <> 0)
					OR (b.DeltaNumOfBytesRead <> 0)
					OR (b.DeltaIOStallReadMS <> 0)
					OR (b.DeltaIOStallQueuedReadMS <> 0)
					OR (b.DeltaNumOfWrites <> 0)
					OR (b.DeltaNumOfBytesWritten <> 0)
					OR (b.DeltaIOStallWriteMS <> 0)
					OR (b.DeltaIOStallQueuedWriteMS <> 0);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Database IO]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Database IO'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPDatabaseIO
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPDatabaseIO'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPDatabaseIO AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPDatabaseIO (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @ioStallQueuedReadMSStmt nvarchar(max);
					DECLARE @ioStallQueuedWriteMSStmt nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;
					END;

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						--
						-- Test if io_stall_queued_read_ms (and thereby also io_stall_queued_write_ms) exists on dm_io_virtual_file_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_io_virtual_file_stats'''') AND (sc.name = ''''io_stall_queued_read_ms'''')
							)
							BEGIN
								SET @ioStallQueuedReadMSStmt = ''''divfs.io_stall_queued_read_ms'''';
								SET @ioStallQueuedWriteMSStmt = ''''divfs.io_stall_queued_write_ms'''';
							END
							ELSE BEGIN
								SET @ioStallQueuedReadMSStmt = ''''NULL'''';
								SET @ioStallQueuedWriteMSStmt = ''''NULL'''';
							END;
						END;

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + '''';

									SELECT
										DB_NAME() AS DatabaseName
										,df.name, df.physical_name, df.Type
				'';
				IF ((@productVersion1 = 10) AND (@productVersion2 = 0))
				BEGIN
					-- SQL Versions SQL2008
					SET @stmt += ''
										,CAST(NULL AS nvarchar(512))	AS VolumeMountPoint
										,CAST(NULL AS nvarchar(512))	AS LogicalVolumeName
					'';
				END
				ELSE BEGIN
					-- SQL Versions SQL2008R2 or higher
					SET @stmt += ''
										,dovs.volume_mount_point	AS VolumeMountPoint
										,dovs.logical_volume_name	AS LogicalVolumeName
					'';
				END;
				SET @stmt += ''
										,fg.name					AS FilegroupName
										,fg.type					AS FileGroupType
										,divfs.sample_ms
										,divfs.io_stall
										,divfs.num_of_reads, divfs.num_of_bytes_read, divfs.io_stall_read_ms, '''' + @ioStallQueuedReadMSStmt + ''''
										,divfs.num_of_writes, divfs.num_of_bytes_written, divfs.io_stall_write_ms, '''' + @ioStallQueuedWriteMSStmt + ''''
										,divfs.size_on_disk_bytes
										,@nowUTC, @now
									FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS divfs
									INNER JOIN sys.database_files AS df WITH (NOLOCK) ON (divfs.file_id = df.file_id)
				'';
				IF NOT ((@productVersion1 = 10) AND (@productVersion2 = 0))
				BEGIN
					-- SQL Versions SQL2008R2 or higher
					SET @stmt += ''
									CROSS APPLY sys.dm_os_volume_stats(DB_ID(), df.file_id) AS dovs
					'';
				END;
				SET @stmt += ''
									LEFT OUTER JOIN sys.filegroups AS fg WITH (NOLOCK) ON (fg.data_space_id = df.data_space_id);
								'''';
								BEGIN TRY
									INSERT INTO dbo.fhsmDatabaseIO(
										DatabaseName, LogicalName, PhysicalName, Type
										,VolumeMountPoint, LogicalVolumeName
										,FilegroupName, FileGroupType
										,SampleMS, IOStall
										,NumOfReads, NumOfBytesRead, IOStallReadMS, IOStallQueuedReadMS
										,NumOfWrites, NumOfBytesWritten, IOStallWriteMS, IOStallQueuedWriteMS
										,SizeOnDiskBytes
										,TimestampUTC, Timestamp
									)
									EXEC sp_executesql
										@stmt
										,N''''@now datetime, @nowUTC datetime''''
										,@now = @now, @nowUTC = @nowUTC;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPDatabaseIO
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPDatabaseIO'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlDatabaseIO
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlDatabaseIO'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlDatabaseIO AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlDatabaseIO (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlDatabaseIO
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlDatabaseIO'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmDatabaseIO''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableDatabaseIO								AS Enabled
				,0												AS DeploymentStatus
				,''Database IO''									AS Name
				,PARSENAME(''dbo.fhsmSPDatabaseIO'', 1)			AS Task
				,15 * 60										AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''ALL_DATABASES''''''				AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmDatabaseIO'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Database file'' AS DimensionName
				,''DatabaseFileKey'' AS DimensionKey
				,''dbo.fhsmDatabaseIO'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[LogicalName]'', ''src.[PhysicalName]'', ''CASE src.[Type] WHEN 0 THEN ''''Data'''' WHEN 1 THEN ''''Log'''' WHEN 2 THEN ''''Filestream'''' WHEN 4 THEN ''''Fulltext'''' ELSE ''''Other'''' END'', ''src.[FilegroupName]''
				,''Database name'', ''Logical name'', ''Physical name'', ''Type'', ''File group''

			UNION ALL

			SELECT
				''Disk'' AS DimensionName
				,''DiskKey'' AS DimensionKey
				,''dbo.fhsmDatabaseIO'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[VolumeMountPoint]'', NULL, NULL, NULL, NULL
				,''Disk'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''File group'' AS DimensionName
				,''FileGroupKey'' AS DimensionKey
				,''dbo.fhsmDatabaseIO'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[FilegroupName]'', NULL, NULL, NULL
				,''Database'', ''File group'', NULL, NULL, NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.SrcColumn5 = src.SrcColumn5
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
				,tgt.OutputColumn5 = src.OutputColumn5
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4, src.SrcColumn5
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4, src.OutputColumn5
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmDatabaseIO'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:IndexOperational.sql modified: 2025.08.05 19.10.12
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableIndexOperational bit;

	SET @enableIndexOperational = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexOperational'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmIndexOperational and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmIndexOperational'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmIndexOperational'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmIndexOperational(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,IndexName nvarchar(128) NULL
					,LeafInsertCount bigint NOT NULL
					,LeafDeleteCount bigint NOT NULL
					,LeafUpdateCount bigint NOT NULL
					,LeafGhostCount bigint NOT NULL
					,NonleafInsertCount bigint NOT NULL
					,NonleafDeleteCount bigint NOT NULL
					,NonleafUpdateCount bigint NOT NULL
					,LeafAllocationCount bigint NOT NULL
					,NonleafAllocationCount bigint NOT NULL
					,LeafPageMergeCount bigint NOT NULL
					,NonleafPageMergeCount bigint NOT NULL
					,RangeScanCount bigint NOT NULL
					,SingletonLookupCount bigint NOT NULL
					,ForwardedFetchCount bigint NOT NULL
					,LOBFetchInPages bigint NOT NULL
					,LOBFetchInBytes bigint NOT NULL
					,LOBOrphanCreateCount bigint NOT NULL
					,LOBOrphanInsertCount bigint NOT NULL
					,RowOverflowFetchInPages bigint NOT NULL
					,RowOverflowFetchInBytes bigint NOT NULL
					,ColumnValuePushOffRowCount bigint NOT NULL
					,ColumnValuePullInRowCount bigint NOT NULL
					,RowLockCount bigint NOT NULL
					,RowLockWaitCount bigint NOT NULL
					,RowLockWaitInMS bigint NOT NULL
					,PageLockCount bigint NOT NULL
					,PageLockWaitCount bigint NOT NULL
					,PageLockWaitInMS bigint NOT NULL
					,IndexLockPromotionAttemptCount bigint NOT NULL
					,IndexLockPromotionCount bigint NOT NULL
					,PageLatchWaitCount bigint NOT NULL
					,PageLatchWaitInMS bigint NOT NULL
					,PageIOLatchWaitCount bigint NOT NULL
					,PageIOLatchWaitInMS bigint NOT NULL
					,TreePageLatchWaitCount bigint NOT NULL
					,TreePageLatchWaitInMS bigint NOT NULL
					,TreePageIOLatchWaitCount bigint NOT NULL
					,TreePageIOLatchWaitInMS bigint NOT NULL
					,PageCompressionAttemptCount bigint NOT NULL
					,PageCompressionSuccessCount bigint NOT NULL
					,VersionGeneratedInrow bigint NULL
					,VersionGeneratedOffrow bigint NULL
					,GhostVersionInrow bigint NULL
					,GhostVersionOffrow bigint NULL
					,InsertOverGhostVersionInrow bigint NULL
					,InsertOverGhostVersionOffrow bigint NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmIndexOperational PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexOperational'')) AND (i.name = ''NC_fhsmIndexOperational_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmIndexOperational_TimestampUTC] to table dbo.fhsmIndexOperational'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmIndexOperational_TimestampUTC ON dbo.fhsmIndexOperational(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexOperational'')) AND (i.name = ''NC_fhsmIndexOperational_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmIndexOperational_Timestamp] to table dbo.fhsmIndexOperational'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmIndexOperational_Timestamp ON dbo.fhsmIndexOperational(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexOperational'')) AND (i.name = ''NC_fhsmIndexOperational_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmIndexOperational_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC] to table dbo.fhsmIndexOperational'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmIndexOperational_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC ON dbo.fhsmIndexOperational(DatabaseName, SchemaName, ObjectName, IndexName, TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmIndexOperational
		--
		BEGIN
			SET @objectName = ''dbo.fhsmIndexOperational'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmIndexOperationalReport if it not already exists
		--
		IF OBJECT_ID(''dbo.fhsmIndexOperationalReport'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmIndexOperationalReport'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmIndexOperationalReport(
					Id int identity(1,1) NOT NULL
					,LeafInsertCount bigint NULL
					,LeafDeleteCount bigint NULL
					,LeafUpdateCount bigint NULL
					,LeafGhostCount bigint NULL
					,NonleafInsertCount bigint NULL
					,NonleafDeleteCount bigint NULL
					,NonleafUpdateCount bigint NULL
					,LeafAllocationCount bigint NULL
					,NonleafAllocationCount bigint NULL
					,LeafPageMergeCount bigint NULL
					,NonleafPageMergeCount bigint NULL
					,RangeScanCount bigint NULL
					,SingletonLookupCount bigint NULL
					,ForwardedFetchCount bigint NULL
					,LOBFetchInPages bigint NULL
					,LOBFetchInBytes bigint NULL
					,LOBOrphanCreateCount bigint NULL
					,LOBOrphanInsertCount bigint NULL
					,RowOverflowFetchInPages bigint NULL
					,RowOverflowFetchInBytes bigint NULL
					,ColumnValuePushOffRowCount bigint NULL
					,ColumnValuePullInRowCount bigint NULL
					,RowLockCount bigint NULL
					,RowLockWaitCount bigint NULL
					,RowLockWaitInMS bigint NULL
					,PageLockCount bigint NULL
					,PageLockWaitCount bigint NULL
					,PageLockWaitInMS bigint NULL
					,IndexLockPromotionAttemptCount bigint NULL
					,IndexLockPromotionCount bigint NULL
					,PageLatchWaitCount bigint NULL
					,PageLatchWaitInMS bigint NULL
					,PageIOLatchWaitCount bigint NULL
					,PageIOLatchWaitInMS bigint NULL
					,TreePageLatchWaitCount bigint NULL
					,TreePageLatchWaitInMS bigint NULL
					,TreePageIOLatchWaitCount bigint NULL
					,TreePageIOLatchWaitInMS bigint NULL
					,PageCompressionAttemptCount bigint NULL
					,PageCompressionSuccessCount bigint NULL
					,VersionGeneratedInrow bigint NULL
					,VersionGeneratedOffrow bigint NULL
					,GhostVersionInrow bigint NULL
					,GhostVersionOffrow bigint NULL
					,InsertOverGhostVersionInrow bigint NULL
					,InsertOverGhostVersionOffrow bigint NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,IndexName nvarchar(128) NULL
					,Date date NOT NULL
					,TimeKey int NOT NULL
					,DatabaseKey bigint NOT NULL
					,SchemaKey bigint NOT NULL
					,ObjectKey bigint NOT NULL
					,IndexKey bigint NOT NULL
					,CONSTRAINT NCPK_fhsmIndexOperationalReport PRIMARY KEY NONCLUSTERED(Id)'' + @tableCompressionStmt + ''
				);

				CREATE CLUSTERED INDEX CL_fhsmIndexOperationalReport_TimestampUTC ON dbo.fhsmIndexOperationalReport(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmIndexOperationalReport
		--
		BEGIN
			SET @objectName = ''dbo.fhsmIndexOperationalReport'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Index operational]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index operational'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index operational'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index operational'') + ''
				AS
				SELECT
					ior.LeafInsertCount
					,ior.LeafDeleteCount
					,ior.LeafUpdateCount
					,ior.LeafGhostCount
					,ior.NonleafInsertCount
					,ior.NonleafDeleteCount
					,ior.NonleafUpdateCount
					,ior.LeafAllocationCount
					,ior.NonleafAllocationCount
					,ior.LeafPageMergeCount
					,ior.NonleafPageMergeCount
					,ior.RowLockCount
					,ior.RowLockWaitCount
					,ior.RowLockWaitInMS
					,ior.PageLockCount
					,ior.PageLockWaitCount
					,ior.PageLockWaitInMS
					,ior.Date
					,ior.TimeKey
					,ior.DatabaseKey
					,ior.SchemaKey
					,ior.ObjectKey
					,ior.IndexKey
				FROM dbo.fhsmIndexOperationalReport AS ior
				WHERE
					(ior.LeafInsertCount <> 0)
					OR (ior.LeafDeleteCount <> 0)
					OR (ior.LeafUpdateCount <> 0)
					OR (ior.LeafGhostCount <> 0)
					OR (ior.NonleafInsertCount <> 0)
					OR (ior.NonleafDeleteCount <> 0)
					OR (ior.NonleafUpdateCount <> 0)
					OR (ior.LeafAllocationCount <> 0)
					OR (ior.NonleafAllocationCount <> 0)
					OR (ior.LeafPageMergeCount <> 0)
					OR (ior.NonleafPageMergeCount <> 0)
					OR (ior.RowLockCount <> 0)
					OR (ior.RowLockWaitCount <> 0)
					OR (ior.RowLockWaitInMS <> 0)
					OR (ior.PageLockCount <> 0)
					OR (ior.PageLockWaitCount <> 0)
					OR (ior.PageLockWaitInMS <> 0);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Index operational]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index operational'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPIndexOperational
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPIndexOperational'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPIndexOperational AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPIndexOperational (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @ghostVersionInrowStmt nvarchar(max);
					DECLARE @ghostVersionOffrowStmt nvarchar(max);
					DECLARE @insertOverGhostVersionInrowStmt nvarchar(max);
					DECLARE @insertOverGhostVersionOffrowStmt nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);
					DECLARE @versionGeneratedInrowStmt nvarchar(max);
					DECLARE @versionGeneratedOffrowStmt nvarchar(max);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;
					END;

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

			'';
			SET @stmt += ''
					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						--
						-- Test if version_generated_inrow (and thereby all other *version*) exists on dm_db_index_operational_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_db_index_operational_stats'''') AND (sc.name = ''''version_generated_inrow'''')
							)
							BEGIN
								SET @versionGeneratedInrowStmt = ''''SUM(ddios.version_generated_inrow)'''';
								SET @versionGeneratedOffrowStmt = ''''SUM(ddios.version_generated_offrow)'''';
								SET @ghostVersionInrowStmt = ''''SUM(ddios.ghost_version_inrow)'''';
								SET @ghostVersionOffrowStmt = ''''SUM(ddios.ghost_version_offrow)'''';
								SET @insertOverGhostVersionInrowStmt = ''''SUM(ddios.insert_over_ghost_version_inrow)'''';
								SET @insertOverGhostVersionOffrowStmt = ''''SUM(ddios.insert_over_ghost_version_offrow)'''';
							END
							ELSE BEGIN
								SET @versionGeneratedInrowStmt = ''''NULL'''';
								SET @versionGeneratedOffrowStmt = ''''NULL'''';
								SET @ghostVersionInrowStmt = ''''NULL'''';
								SET @ghostVersionOffrowStmt = ''''NULL'''';
								SET @insertOverGhostVersionInrowStmt = ''''NULL'''';
								SET @insertOverGhostVersionOffrowStmt = ''''NULL'''';
							END;
						END;
			'';
			SET @stmt += ''

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + '''';

									SELECT
										DB_NAME() AS DatabaseName
										,sch.name AS SchemaName
										,o.name AS ObjectName
										,i.name AS IndexName
										,SUM(ddios.leaf_insert_count) AS LeafInsertCount
										,SUM(ddios.leaf_delete_count) AS LeafDeleteCount
										,SUM(ddios.leaf_update_count) AS LeafUpdateCount
										,SUM(ddios.leaf_ghost_count) AS LeafGhostCount
										,SUM(ddios.nonleaf_insert_count) AS NonleafInsertCount
										,SUM(ddios.nonleaf_delete_count) AS NonleafDeleteCount
										,SUM(ddios.nonleaf_update_count) AS NonleafUpdateCount
										,SUM(ddios.leaf_allocation_count) AS LeafAllocationCount
										,SUM(ddios.nonleaf_allocation_count) AS NonleafAllocationCount
										,SUM(ddios.leaf_page_merge_count) AS LeafPageMergeCount
										,SUM(ddios.nonleaf_page_merge_count) AS NonleafPageMergeCount
										,SUM(ddios.range_scan_count) AS RangeScanCount
										,SUM(ddios.singleton_lookup_count) AS SingletonLookupCount
										,SUM(ddios.forwarded_fetch_count) AS ForwardedFetchCount
										,SUM(ddios.lob_fetch_in_pages) AS LOBFetchInPages
										,SUM(ddios.lob_fetch_in_bytes) AS LOBFetchInBytes
										,SUM(ddios.lob_orphan_create_count) AS LOBOrphanCreateCount
										,SUM(ddios.lob_orphan_insert_count) AS LOBOrphanInsertCount
										,SUM(ddios.row_overflow_fetch_in_pages) AS RowOverflowFetchInPages
										,SUM(ddios.row_overflow_fetch_in_bytes) AS RowOverflowFetchInBytes
										,SUM(ddios.column_value_push_off_row_count) AS ColumnValuePushOffRowCount
										,SUM(ddios.column_value_pull_in_row_count) AS ColumnValuePullInRowCount
										,SUM(ddios.row_lock_count) AS RowLockCount
										,SUM(ddios.row_lock_wait_count) AS RowLockWaitCount
										,SUM(ddios.row_lock_wait_in_ms) AS RowLockWaitInMS
										,SUM(ddios.page_lock_count) AS PageLockCount
										,SUM(ddios.page_lock_wait_count) AS PageLockWaitCount
										,SUM(ddios.page_lock_wait_in_ms) AS PageLockWaitInMS
										,SUM(ddios.index_lock_promotion_attempt_count) AS IndexLockPromotionAttemptCount
										,SUM(ddios.index_lock_promotion_count) AS IndexLockPromotionCount
										,SUM(ddios.page_latch_wait_count) AS PageLatchWaitCount
										,SUM(ddios.page_latch_wait_in_ms) AS PageLatchWaitInMS
										,SUM(ddios.page_io_latch_wait_count) AS PageIOLatchWaitCount
										,SUM(ddios.page_io_latch_wait_in_ms) AS PageIOLatchWaitInMS
										,SUM(ddios.tree_page_latch_wait_count) AS TreePageLatchWaitCount
										,SUM(ddios.tree_page_latch_wait_in_ms) AS TreePageLatchWaitInMS
										,SUM(ddios.tree_page_io_latch_wait_count) AS TreePageIOLatchWaitCount
										,SUM(ddios.tree_page_io_latch_wait_in_ms) AS TreePageIOLatchWaitInMS
										,SUM(ddios.page_compression_attempt_count) AS PageCompressionAttemptCount
										,SUM(ddios.page_compression_success_count) AS PageCompressionSuccessCount
										,'''' + @versionGeneratedInrowStmt + '''' AS VersionGeneratedInrow
										,'''' + @versionGeneratedOffrowStmt + '''' AS VersionGeneratedOffrow
										,'''' + @ghostVersionInrowStmt + '''' AS GhostVersionInrow
										,'''' + @ghostVersionOffrowStmt + '''' AS GhostVersionOffrow
										,'''' + @insertOverGhostVersionInrowStmt + '''' AS InsertOverGhostVersionInrow
										,'''' + @insertOverGhostVersionOffrowStmt + '''' AS InsertOverGhostVersionOffrow
										,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
										,@nowUTC, @now
									FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ddios
									INNER JOIN sys.objects AS o WITH (NOLOCK) ON (o.object_id = ddios.object_id)
									INNER JOIN sys.schemas AS sch WITH (NOLOCK) ON (sch.schema_id = o.schema_id)
									INNER JOIN sys.indexes AS i ON (i.object_id = ddios.object_id) AND (i.index_id = ddios.index_id)
									WHERE (o.type IN (''''''''U'''''''', ''''''''V''''''''))
									GROUP BY DB_NAME(ddios.database_id), sch.name, o.name, i.name;
								'''';
								BEGIN TRY
									INSERT INTO dbo.fhsmIndexOperational(
										DatabaseName, SchemaName, ObjectName, IndexName
										,LeafInsertCount, LeafDeleteCount, LeafUpdateCount, LeafGhostCount
										,NonleafInsertCount, NonleafDeleteCount, NonleafUpdateCount
										,LeafAllocationCount, NonleafAllocationCount
										,LeafPageMergeCount, NonleafPageMergeCount
										,RangeScanCount, SingletonLookupCount
										,ForwardedFetchCount, LOBFetchInPages, LOBFetchInBytes
										,LOBOrphanCreateCount, LOBOrphanInsertCount
										,RowOverflowFetchInPages, RowOverflowFetchInBytes
										,ColumnValuePushOffRowCount, ColumnValuePullInRowCount
										,RowLockCount, RowLockWaitCount, RowLockWaitInMS
										,PageLockCount, PageLockWaitCount, PageLockWaitInMS
										,IndexLockPromotionAttemptCount, IndexLockPromotionCount
										,PageLatchWaitCount, PageLatchWaitInMS
										,PageIOLatchWaitCount, PageIOLatchWaitInMS
										,TreePageLatchWaitCount, TreePageLatchWaitInMS
										,TreePageIOLatchWaitCount, TreePageIOLatchWaitInMS
										,PageCompressionAttemptCount, PageCompressionSuccessCount
										,VersionGeneratedInrow, VersionGeneratedOffrow
										,GhostVersionInrow, GhostVersionOffrow
										,InsertOverGhostVersionInrow, InsertOverGhostVersionOffrow
										,LastSQLServiceRestart
										,TimestampUTC, Timestamp
									)
									EXEC sp_executesql
										@stmt
										,N''''@now datetime, @nowUTC datetime''''
										,@now = @now, @nowUTC = @nowUTC;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;

						--
						-- Insert records into fhsmIndexOperationalReport
						--
						BEGIN
							--
							-- Delete if already processed
							--
							BEGIN
								DELETE ior
								FROM dbo.fhsmIndexOperationalReport AS ior WHERE (ior.TimestampUTC = @nowUTC);
							END;

							--
							-- Process delta
							--
							INSERT INTO dbo.fhsmIndexOperationalReport(
								LeafInsertCount, LeafDeleteCount, LeafUpdateCount, LeafGhostCount
								,NonleafInsertCount, NonleafDeleteCount, NonleafUpdateCount
								,LeafAllocationCount, NonleafAllocationCount
								,LeafPageMergeCount, NonleafPageMergeCount
								,RangeScanCount, SingletonLookupCount, ForwardedFetchCount
								,LOBFetchInPages, LOBFetchInBytes
								,LOBOrphanCreateCount, LOBOrphanInsertCount
								,RowOverflowFetchInPages, RowOverflowFetchInBytes
								,ColumnValuePushOffRowCount, ColumnValuePullInRowCount
								,RowLockCount, RowLockWaitCount, RowLockWaitInMS
								,PageLockCount, PageLockWaitCount, PageLockWaitInMS
								,IndexLockPromotionAttemptCount, IndexLockPromotionCount
								,PageLatchWaitCount, PageLatchWaitInMS
								,PageIOLatchWaitCount, PageIOLatchWaitInMS
								,TreePageLatchWaitCount, TreePageLatchWaitInMS
								,TreePageIOLatchWaitCount, TreePageIOLatchWaitInMS
								,PageCompressionAttemptCount, PageCompressionSuccessCount
								,VersionGeneratedInrow, VersionGeneratedOffrow
								,GhostVersionInrow, GhostVersionOffrow
								,InsertOverGhostVersionInrow, InsertOverGhostVersionOffrow
								,TimestampUTC, Timestamp
								,DatabaseName, SchemaName, ObjectName, IndexName
								,Date, TimeKey
								,DatabaseKey, SchemaKey, ObjectKey, IndexKey
							)
							SELECT
								b.DeltaLeafInsertCount AS LeafInsertCount
								,b.DeltaLeafDeleteCount AS LeafDeleteCount
								,b.DeltaLeafUpdateCount AS LeafUpdateCount
								,b.DeltaLeafGhostCount AS LeafGhostCount
								,b.DeltaNonleafInsertCount AS NonleafInsertCount
								,b.DeltaNonleafDeleteCount AS NonleafDeleteCount
								,b.DeltaNonleafUpdateCount AS NonleafUpdateCount
								,b.DeltaLeafAllocationCount AS LeafAllocationCount
								,b.DeltaNonleafAllocationCount AS NonleafAllocationCount
								,b.DeltaLeafPageMergeCount AS LeafPageMergeCount
								,b.DeltaNonleafPageMergeCount AS NonleafPageMergeCount
								,b.DeltaRangeScanCount AS RangeScanCount
								,b.DeltaSingletonLookupCount AS SingletonLookupCount
								,b.DeltaForwardedFetchCount AS ForwardedFetchCount
								,b.DeltaLOBFetchInPages AS LOBFetchInPages
								,b.DeltaLOBFetchInBytes AS LOBFetchInBytes
								,b.DeltaLOBOrphanCreateCount AS LOBOrphanCreateCount
								,b.DeltaLOBOrphanInsertCount AS LOBOrphanInsertCount
								,b.DeltaRowOverflowFetchInPages AS RowOverflowFetchInPages
								,b.DeltaRowOverflowFetchInBytes AS RowOverflowFetchInBytes
								,b.DeltaColumnValuePushOffRowCount AS ColumnValuePushOffRowCount
								,b.DeltaColumnValuePullInRowCount AS ColumnValuePullInRowCount
								,b.DeltaRowLockCount AS RowLockCount
								,b.DeltaRowLockWaitCount AS RowLockWaitCount
								,b.DeltaRowLockWaitInMS AS RowLockWaitInMS
								,b.DeltaPageLockCount AS PageLockCount
								,b.DeltaPageLockWaitCount AS PageLockWaitCount
								,b.DeltaPageLockWaitInMS AS PageLockWaitInMS
								,b.DeltaIndexLockPromotionAttemptCount AS IndexLockPromotionAttemptCount
								,b.DeltaIndexLockPromotionCount AS IndexLockPromotionCount
								,b.DeltaPageLatchWaitCount AS PageLatchWaitCount
								,b.DeltaPageLatchWaitInMS AS PageLatchWaitInMS
								,b.DeltaPageIOLatchWaitCount AS PageIOLatchWaitCount
								,b.DeltaPageIOLatchWaitInMS AS PageIOLatchWaitInMS
								,b.DeltaTreePageLatchWaitCount AS TreePageLatchWaitCount
								,b.DeltaTreePageLatchWaitInMS AS TreePageLatchWaitInMS
								,b.DeltaTreePageIOLatchWaitCount AS TreePageIOLatchWaitCount
								,b.DeltaTreePageIOLatchWaitInMS AS TreePageIOLatchWaitInMS
								,b.DeltaPageCompressionAttemptCount AS PageCompressionAttemptCount
								,b.DeltaPageCompressionSuccessCount AS PageCompressionSuccessCount
								,b.DeltaVersionGeneratedInrow AS VersionGeneratedInrow
								,b.DeltaVersionGeneratedOffrow AS VersionGeneratedOffrow
								,b.DeltaGhostVersionInrow AS GhostVersionInrow
								,b.DeltaGhostVersionOffrow AS GhostVersionOffrow
								,b.DeltaInsertOverGhostVersionInrow AS InsertOverGhostVersionInrow
								,b.DeltaInsertOverGhostVersionOffrow AS InsertOverGhostVersionOffrow
								,b.TimestampUTC
								,b.Timestamp
								,b.DatabaseName
								,b.SchemaName
								,b.ObjectName
								,b.IndexName
								,CAST(b.Timestamp AS date) AS Date
								,(DATEPART(HOUR, b.Timestamp) * 60 * 60) + (DATEPART(MINUTE, b.Timestamp) * 60) + (DATEPART(SECOND, b.Timestamp)) AS TimeKey
								,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
								,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
								,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.SchemaName, b.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
								,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.SchemaName, b.ObjectName, COALESCE(b.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
							FROM (
								SELECT
									CASE
										WHEN (a.PreviousLeafInsertCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL													-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
										WHEN (a.PreviousLeafInsertCount > a.LeafInsertCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LeafInsertCount		-- Either has the counters had an overflow or the server har been restarted
										ELSE a.LeafInsertCount - a.PreviousLeafInsertCount																								-- Difference
									END AS DeltaLeafInsertCount
									,CASE
										WHEN (a.PreviousLeafDeleteCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLeafDeleteCount > a.LeafDeleteCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LeafDeleteCount
										ELSE a.LeafDeleteCount - a.PreviousLeafDeleteCount
									END AS DeltaLeafDeleteCount
									,CASE
										WHEN (a.PreviousLeafUpdateCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLeafUpdateCount > a.LeafUpdateCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LeafUpdateCount
										ELSE a.LeafUpdateCount - a.PreviousLeafUpdateCount
									END AS DeltaLeafUpdateCount
									,CASE
										WHEN (a.PreviousLeafGhostCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLeafGhostCount > a.LeafGhostCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LeafGhostCount
										ELSE a.LeafGhostCount - a.PreviousLeafGhostCount
									END AS DeltaLeafGhostCount
									,CASE
										WHEN (a.PreviousNonleafInsertCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousNonleafInsertCount > a.NonleafInsertCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.NonleafInsertCount
										ELSE a.NonleafInsertCount - a.PreviousNonleafInsertCount
									END AS DeltaNonleafInsertCount
									,CASE
										WHEN (a.PreviousNonleafDeleteCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousNonleafDeleteCount > a.NonleafDeleteCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.NonleafDeleteCount
										ELSE a.NonleafDeleteCount - a.PreviousNonleafDeleteCount
									END AS DeltaNonleafDeleteCount
									,CASE
										WHEN (a.PreviousNonleafUpdateCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousNonleafUpdateCount > a.NonleafUpdateCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.NonleafUpdateCount
										ELSE a.NonleafUpdateCount - a.PreviousNonleafUpdateCount
									END AS DeltaNonleafUpdateCount
									,CASE
										WHEN (a.PreviousLeafAllocationCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLeafAllocationCount > a.LeafAllocationCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LeafAllocationCount
										ELSE a.LeafAllocationCount - a.PreviousLeafAllocationCount
									END AS DeltaLeafAllocationCount
									,CASE
										WHEN (a.PreviousNonleafAllocationCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousNonleafAllocationCount > a.NonleafAllocationCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.NonleafAllocationCount
										ELSE a.NonleafAllocationCount - a.PreviousNonleafAllocationCount
									END AS DeltaNonleafAllocationCount
									,CASE
										WHEN (a.PreviousLeafPageMergeCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLeafPageMergeCount > a.LeafPageMergeCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LeafPageMergeCount
										ELSE a.LeafPageMergeCount - a.PreviousLeafPageMergeCount
									END AS DeltaLeafPageMergeCount
									,CASE
										WHEN (a.PreviousNonleafPageMergeCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousNonleafPageMergeCount > a.NonleafPageMergeCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.NonleafPageMergeCount
										ELSE a.NonleafPageMergeCount - a.PreviousNonleafPageMergeCount
									END AS DeltaNonleafPageMergeCount
									,CASE
										WHEN (a.PreviousRangeScanCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousRangeScanCount > a.RangeScanCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.RangeScanCount
										ELSE a.RangeScanCount - a.PreviousRangeScanCount
									END AS DeltaRangeScanCount
									,CASE
										WHEN (a.PreviousSingletonLookupCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousSingletonLookupCount > a.SingletonLookupCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.SingletonLookupCount
										ELSE a.SingletonLookupCount - a.PreviousSingletonLookupCount
									END AS DeltaSingletonLookupCount
									,CASE
										WHEN (a.PreviousForwardedFetchCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousForwardedFetchCount > a.ForwardedFetchCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.ForwardedFetchCount
										ELSE a.ForwardedFetchCount - a.PreviousForwardedFetchCount
									END AS DeltaForwardedFetchCount
									,CASE
										WHEN (a.PreviousLOBFetchInPages IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLOBFetchInPages > a.LOBFetchInPages) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LOBFetchInPages
										ELSE a.LOBFetchInPages - a.PreviousLOBFetchInPages
									END AS DeltaLOBFetchInPages
									,CASE
										WHEN (a.PreviousLOBFetchInBytes IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLOBFetchInBytes > a.LOBFetchInBytes) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LOBFetchInBytes
										ELSE a.LOBFetchInBytes - a.PreviousLOBFetchInBytes
									END AS DeltaLOBFetchInBytes
									,CASE
										WHEN (a.PreviousLOBOrphanCreateCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLOBOrphanCreateCount > a.LOBOrphanCreateCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LOBOrphanCreateCount
										ELSE a.LOBOrphanCreateCount - a.PreviousLOBOrphanCreateCount
									END AS DeltaLOBOrphanCreateCount
									,CASE
										WHEN (a.PreviousLOBOrphanInsertCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousLOBOrphanInsertCount > a.LOBOrphanInsertCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.LOBOrphanInsertCount
										ELSE a.LOBOrphanInsertCount - a.PreviousLOBOrphanInsertCount
									END AS DeltaLOBOrphanInsertCount
									,CASE
										WHEN (a.PreviousRowOverflowFetchInPages IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousRowOverflowFetchInPages > a.RowOverflowFetchInPages) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.RowOverflowFetchInPages
										ELSE a.RowOverflowFetchInPages - a.PreviousRowOverflowFetchInPages
									END AS DeltaRowOverflowFetchInPages
									,CASE
										WHEN (a.PreviousRowOverflowFetchInBytes IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousRowOverflowFetchInBytes > a.RowOverflowFetchInBytes) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.RowOverflowFetchInBytes
										ELSE a.RowOverflowFetchInBytes - a.PreviousRowOverflowFetchInBytes
									END AS DeltaRowOverflowFetchInBytes
									,CASE
										WHEN (a.PreviousColumnValuePushOffRowCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousColumnValuePushOffRowCount > a.ColumnValuePushOffRowCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.ColumnValuePushOffRowCount
										ELSE a.ColumnValuePushOffRowCount - a.PreviousColumnValuePushOffRowCount
									END AS DeltaColumnValuePushOffRowCount
									,CASE
										WHEN (a.PreviousColumnValuePullInRowCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousColumnValuePullInRowCount > a.ColumnValuePullInRowCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.ColumnValuePullInRowCount
										ELSE a.ColumnValuePullInRowCount - a.PreviousColumnValuePullInRowCount
									END AS DeltaColumnValuePullInRowCount
									,CASE
										WHEN (a.PreviousRowLockCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousRowLockCount > a.RowLockCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.RowLockCount
										ELSE a.RowLockCount - a.PreviousRowLockCount
									END AS DeltaRowLockCount
									,CASE
										WHEN (a.PreviousRowLockWaitCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousRowLockWaitCount > a.RowLockWaitCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.RowLockWaitCount
										ELSE a.RowLockWaitCount - a.PreviousRowLockWaitCount
									END AS DeltaRowLockWaitCount
									,CASE
										WHEN (a.PreviousRowLockWaitInMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousRowLockWaitInMS > a.RowLockWaitInMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.RowLockWaitInMS
										ELSE a.RowLockWaitInMS - a.PreviousRowLockWaitInMS
									END AS DeltaRowLockWaitInMS
									,CASE
										WHEN (a.PreviousPageLockCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageLockCount > a.PageLockCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageLockCount
										ELSE a.PageLockCount - a.PreviousPageLockCount
									END AS DeltaPageLockCount
									,CASE
										WHEN (a.PreviousPageLockWaitCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageLockWaitCount > a.PageLockWaitCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageLockWaitCount
										ELSE a.PageLockWaitCount - a.PreviousPageLockWaitCount
									END AS DeltaPageLockWaitCount
									,CASE
										WHEN (a.PreviousPageLockWaitInMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageLockWaitInMS > a.PageLockWaitInMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageLockWaitInMS
										ELSE a.PageLockWaitInMS - a.PreviousPageLockWaitInMS
									END AS DeltaPageLockWaitInMS
									,CASE
										WHEN (a.PreviousIndexLockPromotionAttemptCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousIndexLockPromotionAttemptCount > a.IndexLockPromotionAttemptCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.IndexLockPromotionAttemptCount
										ELSE a.IndexLockPromotionAttemptCount - a.PreviousIndexLockPromotionAttemptCount
									END AS DeltaIndexLockPromotionAttemptCount
									,CASE
										WHEN (a.PreviousIndexLockPromotionCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousIndexLockPromotionCount > a.IndexLockPromotionCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.IndexLockPromotionCount
										ELSE a.IndexLockPromotionCount - a.PreviousIndexLockPromotionCount
									END AS DeltaIndexLockPromotionCount
									,CASE
										WHEN (a.PreviousPageLatchWaitCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageLatchWaitCount > a.PageLatchWaitCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageLatchWaitCount
										ELSE a.PageLatchWaitCount - a.PreviousPageLatchWaitCount
									END AS DeltaPageLatchWaitCount
									,CASE
										WHEN (a.PreviousPageLatchWaitInMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageLatchWaitInMS > a.PageLatchWaitInMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageLatchWaitInMS
										ELSE a.PageLatchWaitInMS - a.PreviousPageLatchWaitInMS
									END AS DeltaPageLatchWaitInMS
									,CASE
										WHEN (a.PreviousPageIOLatchWaitCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageIOLatchWaitCount > a.PageIOLatchWaitCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageIOLatchWaitCount
										ELSE a.PageIOLatchWaitCount - a.PreviousPageIOLatchWaitCount
									END AS DeltaPageIOLatchWaitCount
									,CASE
										WHEN (a.PreviousPageIOLatchWaitInMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageIOLatchWaitInMS > a.PageIOLatchWaitInMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageIOLatchWaitInMS
										ELSE a.PageIOLatchWaitInMS - a.PreviousPageIOLatchWaitInMS
									END AS DeltaPageIOLatchWaitInMS
									,CASE
										WHEN (a.PreviousTreePageLatchWaitCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousTreePageLatchWaitCount > a.TreePageLatchWaitCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.TreePageLatchWaitCount
										ELSE a.TreePageLatchWaitCount - a.PreviousTreePageLatchWaitCount
									END AS DeltaTreePageLatchWaitCount
									,CASE
										WHEN (a.PreviousTreePageLatchWaitInMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousTreePageLatchWaitInMS > a.TreePageLatchWaitInMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.TreePageLatchWaitInMS
										ELSE a.TreePageLatchWaitInMS - a.PreviousTreePageLatchWaitInMS
									END AS DeltaTreePageLatchWaitInMS
									,CASE
										WHEN (a.PreviousTreePageIOLatchWaitCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousTreePageIOLatchWaitCount > a.TreePageIOLatchWaitCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.TreePageIOLatchWaitCount
										ELSE a.TreePageIOLatchWaitCount - a.PreviousTreePageIOLatchWaitCount
									END AS DeltaTreePageIOLatchWaitCount
									,CASE
										WHEN (a.PreviousTreePageIOLatchWaitInMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousTreePageIOLatchWaitInMS > a.TreePageIOLatchWaitInMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.TreePageIOLatchWaitInMS
										ELSE a.TreePageIOLatchWaitInMS - a.PreviousTreePageIOLatchWaitInMS
									END AS DeltaTreePageIOLatchWaitInMS
									,CASE
										WHEN (a.PreviousPageCompressionAttemptCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageCompressionAttemptCount > a.PageCompressionAttemptCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageCompressionAttemptCount
										ELSE a.PageCompressionAttemptCount - a.PreviousPageCompressionAttemptCount
									END AS DeltaPageCompressionAttemptCount
									,CASE
										WHEN (a.PreviousPageCompressionSuccessCount IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousPageCompressionSuccessCount > a.PageCompressionSuccessCount) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.PageCompressionSuccessCount
										ELSE a.PageCompressionSuccessCount - a.PreviousPageCompressionSuccessCount
									END AS DeltaPageCompressionSuccessCount
									,CASE
										WHEN (a.PreviousVersionGeneratedInrow IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousVersionGeneratedInrow > a.VersionGeneratedInrow) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.VersionGeneratedInrow
										ELSE a.VersionGeneratedInrow - a.PreviousVersionGeneratedInrow
									END AS DeltaVersionGeneratedInrow
									,CASE
										WHEN (a.PreviousVersionGeneratedOffrow IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousVersionGeneratedOffrow > a.VersionGeneratedOffrow) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.VersionGeneratedOffrow
										ELSE a.VersionGeneratedOffrow - a.PreviousVersionGeneratedOffrow
									END AS DeltaVersionGeneratedOffrow
									,CASE
										WHEN (a.PreviousGhostVersionInrow IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousGhostVersionInrow > a.GhostVersionInrow) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.GhostVersionInrow
										ELSE a.GhostVersionInrow - a.PreviousGhostVersionInrow
									END AS DeltaGhostVersionInrow
									,CASE
										WHEN (a.PreviousGhostVersionOffrow IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousGhostVersionOffrow > a.GhostVersionOffrow) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.GhostVersionOffrow
										ELSE a.GhostVersionOffrow - a.PreviousGhostVersionOffrow
									END AS DeltaGhostVersionOffrow
									,CASE
										WHEN (a.PreviousInsertOverGhostVersionInrow IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousInsertOverGhostVersionInrow > a.InsertOverGhostVersionInrow) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.InsertOverGhostVersionInrow
										ELSE a.InsertOverGhostVersionInrow - a.PreviousInsertOverGhostVersionInrow
									END AS DeltaInsertOverGhostVersionInrow
									,CASE
										WHEN (a.PreviousInsertOverGhostVersionOffrow IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousInsertOverGhostVersionOffrow > a.InsertOverGhostVersionOffrow) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.InsertOverGhostVersionOffrow
										ELSE a.InsertOverGhostVersionOffrow - a.PreviousInsertOverGhostVersionOffrow
									END AS DeltaInsertOverGhostVersionOffrow
									,a.TimestampUTC
									,a.Timestamp
									,a.DatabaseName
									,a.SchemaName
									,a.ObjectName
									,a.IndexName
								FROM (
									SELECT
										curIO.LeafInsertCount
										,prevIO.LeafInsertCount AS PreviousLeafInsertCount
										,curIO.LeafDeleteCount
										,prevIO.LeafDeleteCount AS PreviousLeafDeleteCount
										,curIO.LeafUpdateCount
										,prevIO.LeafUpdateCount AS PreviousLeafUpdateCount
										,curIO.LeafGhostCount
										,prevIO.LeafGhostCount AS PreviousLeafGhostCount
										,curIO.NonleafInsertCount
										,prevIO.NonleafInsertCount AS PreviousNonleafInsertCount
										,curIO.NonleafDeleteCount
										,prevIO.NonleafDeleteCount AS PreviousNonleafDeleteCount
										,curIO.NonleafUpdateCount
										,prevIO.NonleafUpdateCount AS PreviousNonleafUpdateCount
										,curIO.LeafAllocationCount
										,prevIO.LeafAllocationCount AS PreviousLeafAllocationCount
										,curIO.NonleafAllocationCount
										,prevIO.NonleafAllocationCount AS PreviousNonleafAllocationCount
										,curIO.LeafPageMergeCount
										,prevIO.LeafPageMergeCount AS PreviousLeafPageMergeCount
										,curIO.NonleafPageMergeCount
										,prevIO.NonleafPageMergeCount AS PreviousNonleafPageMergeCount
										,curIO.RangeScanCount
										,prevIO.RangeScanCount AS PreviousRangeScanCount
										,curIO.SingletonLookupCount
										,prevIO.SingletonLookupCount AS PreviousSingletonLookupCount
										,curIO.ForwardedFetchCount
										,prevIO.ForwardedFetchCount AS PreviousForwardedFetchCount
										,curIO.LOBFetchInPages
										,prevIO.LOBFetchInPages AS PreviousLOBFetchInPages
										,curIO.LOBFetchInBytes
										,prevIO.LOBFetchInBytes AS PreviousLOBFetchInBytes
										,curIO.LOBOrphanCreateCount
										,prevIO.LOBOrphanCreateCount AS PreviousLOBOrphanCreateCount
										,curIO.LOBOrphanInsertCount
										,prevIO.LOBOrphanInsertCount AS PreviousLOBOrphanInsertCount
										,curIO.RowOverflowFetchInPages
										,prevIO.RowOverflowFetchInPages AS PreviousRowOverflowFetchInPages
										,curIO.RowOverflowFetchInBytes
										,prevIO.RowOverflowFetchInBytes AS PreviousRowOverflowFetchInBytes
										,curIO.ColumnValuePushOffRowCount
										,prevIO.ColumnValuePushOffRowCount AS PreviousColumnValuePushOffRowCount
										,curIO.ColumnValuePullInRowCount
										,prevIO.ColumnValuePullInRowCount AS PreviousColumnValuePullInRowCount
										,curIO.RowLockCount
										,prevIO.RowLockCount AS PreviousRowLockCount
										,curIO.RowLockWaitCount
										,prevIO.RowLockWaitCount AS PreviousRowLockWaitCount
										,curIO.RowLockWaitInMS
										,prevIO.RowLockWaitInMS AS PreviousRowLockWaitInMS
										,curIO.PageLockCount
										,prevIO.PageLockCount AS PreviousPageLockCount
										,curIO.PageLockWaitCount
										,prevIO.PageLockWaitCount AS PreviousPageLockWaitCount
										,curIO.PageLockWaitInMS
										,prevIO.PageLockWaitInMS AS PreviousPageLockWaitInMS
										,curIO.IndexLockPromotionAttemptCount
										,prevIO.IndexLockPromotionAttemptCount AS PreviousIndexLockPromotionAttemptCount
										,curIO.IndexLockPromotionCount
										,prevIO.IndexLockPromotionCount AS PreviousIndexLockPromotionCount
										,curIO.PageLatchWaitCount
										,prevIO.PageLatchWaitCount AS PreviousPageLatchWaitCount
										,curIO.PageLatchWaitInMS
										,prevIO.PageLatchWaitInMS AS PreviousPageLatchWaitInMS
										,curIO.PageIOLatchWaitCount
										,prevIO.PageIOLatchWaitCount AS PreviousPageIOLatchWaitCount
										,curIO.PageIOLatchWaitInMS
										,prevIO.PageIOLatchWaitInMS AS PreviousPageIOLatchWaitInMS
										,curIO.TreePageLatchWaitCount
										,prevIO.TreePageLatchWaitCount AS PreviousTreePageLatchWaitCount
										,curIO.TreePageLatchWaitInMS
										,prevIO.TreePageLatchWaitInMS AS PreviousTreePageLatchWaitInMS
										,curIO.TreePageIOLatchWaitCount
										,prevIO.TreePageIOLatchWaitCount AS PreviousTreePageIOLatchWaitCount
										,curIO.TreePageIOLatchWaitInMS
										,prevIO.TreePageIOLatchWaitInMS AS PreviousTreePageIOLatchWaitInMS
										,curIO.PageCompressionAttemptCount
										,prevIO.PageCompressionAttemptCount AS PreviousPageCompressionAttemptCount
										,curIO.PageCompressionSuccessCount
										,prevIO.PageCompressionSuccessCount AS PreviousPageCompressionSuccessCount
										,curIO.VersionGeneratedInrow
										,prevIO.VersionGeneratedInrow AS PreviousVersionGeneratedInrow
										,curIO.VersionGeneratedOffrow
										,prevIO.VersionGeneratedOffrow AS PreviousVersionGeneratedOffrow
										,curIO.GhostVersionInrow
										,prevIO.GhostVersionInrow AS PreviousGhostVersionInrow
										,curIO.GhostVersionOffrow
										,prevIO.GhostVersionOffrow AS PreviousGhostVersionOffrow
										,curIO.InsertOverGhostVersionInrow
										,prevIO.InsertOverGhostVersionInrow AS PreviousInsertOverGhostVersionInrow
										,curIO.InsertOverGhostVersionOffrow
										,prevIO.InsertOverGhostVersionOffrow AS PreviousInsertOverGhostVersionOffrow
										,curIO.LastSQLServiceRestart
										,prevIO.LastSQLServiceRestart AS PreviousLastSQLServiceRestart
										,curIO.TimestampUTC
										,curIO.Timestamp
										,curIO.DatabaseName
										,curIO.SchemaName
										,curIO.ObjectName
										,curIO.IndexName
									FROM dbo.fhsmIndexOperational AS curIO
									OUTER APPLY (
										SELECT TOP (1) io.*
										FROM dbo.fhsmIndexOperational AS io
										WHERE
											(io.DatabaseName = curIO.DatabaseName)
											AND (io.SchemaName = curIO.SchemaName)
											AND (io.ObjectName = curIO.ObjectName)
											AND ((io.IndexName = curIO.IndexName) OR ((io.IndexName IS NULL) AND (curIO.IndexName IS NULL)))
											AND (io.TimestampUTC < curIO.TimestampUTC)
										ORDER BY io.TimestampUTC DESC
									) AS prevIO
									WHERE (curIO.TimestampUTC = @nowUTC)
								) AS a
							) AS b;
						END;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPIndexOperational
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPIndexOperational'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmIndexOperational''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmIndexOperationalReport''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableIndexOperational							AS Enabled
				,0												AS DeploymentStatus
				,''Index operational''							AS Name
				,PARSENAME(''dbo.fhsmSPIndexOperational'', 1)		AS Task
				,4 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T06:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb''''''		AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmIndexOperational'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmIndexOperational'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL
				,''Database'', ''Schema'', NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmIndexOperational'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL
				,''Database'', ''Schema'', ''Object'', NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmIndexOperational'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')''
				,''Database'', ''Schema'', ''Object'', ''Index''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmIndexOperational'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:IndexPhysical.sql modified: 2025.08.05 19.10.49
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableIndexPhysical bit;

	SET @enableIndexPhysical = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexPhysical'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmIndexPhysical and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmIndexPhysical'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmIndexPhysical'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmIndexPhysical(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,IndexName nvarchar(128) NULL
					,Mode nvarchar(8) NOT NULL
					,PartitionNumber int NOT NULL
					,IndexTypeDesc nvarchar(60) NOT NULL
					,AllocUnitTypeDesc nvarchar(60) NOT NULL
					,IndexDepth tinyint NOT NULL
					,IndexLevel tinyint NOT NULL
					,ColumnstoreDeleteBufferStateDesc nvarchar(60) NULL
					,AvgFragmentationInPercent float NOT NULL
					,FragmentCount bigint NULL
					,AvgFragmentSizeInPages float NULL
					,PageCount bigint NOT NULL
					,AvgPageSpaceUsedInPercent float NULL
					,RecordCount bigint NULL
					,GhostRecordCount bigint NULL
					,VersionGhostRecordCount bigint NULL
					,MinRecordSizeInBytes int NULL
					,MaxRecordSizeInBytes int NULL
					,AvgRecordSizeInBytes float NULL
					,ForwardedRecordCount bigint NULL
					,CompressedPageCount bigint NULL
					,VersionRecordCount bigint NULL
					,InrowVersionRecordCount bigint NULL
					,InrowDiffVersionRecordCount bigint NULL
					,TotalInrowVersionPayloadSizeInBytes bigint NULL
					,OffrowRegularVersionRecordCount bigint NULL
					,OffrowLongTermVersionRecordCount bigint NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,TimestampUTCDate date NOT NULL
					,TimestampDate date NOT NULL
					,TimeKey int NOT NULL
					,DatabaseKey bigint NOT NULL
					,SchemaKey bigint NOT NULL
					,ObjectKey bigint NOT NULL
					,IndexKey bigint NOT NULL
					,IndexTypeKey bigint NOT NULL
					,IndexAllocTypeKey bigint NOT NULL
					,CONSTRAINT NCPK_fhsmIndexPhysical PRIMARY KEY NONCLUSTERED(Id)'' + @tableCompressionStmt + ''
				);

				CREATE CLUSTERED INDEX CL_fhsmIndexPhysical_TimestampUTC ON dbo.fhsmIndexPhysical(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexPhysical'')) AND (i.name = ''NC_fhsmIndexPhysical_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmIndexPhysical_Timestamp] to table dbo.fhsmIndexPhysical'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmIndexPhysical_Timestamp ON dbo.fhsmIndexPhysical(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexPhysical'')) AND (i.name = ''NC_fhsmIndexPhysical_DatabaseKey_SchemaKey_ObjectKey_TimestampUTCDate_Mode''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmIndexPhysical_DatabaseKey_SchemaKey_ObjectKey_TimestampUTCDate_Mode] to table dbo.fhsmIndexPhysical'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmIndexPhysical_DatabaseKey_SchemaKey_ObjectKey_TimestampUTCDate_Mode ON dbo.fhsmIndexPhysical(DatabaseKey, SchemaKey, ObjectKey, TimestampUTCDate, Mode)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexPhysical'')) AND (i.name = ''NC_fhsmIndexPhysical_Mode''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmIndexPhysical_Mode] to table dbo.fhsmIndexPhysical'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmIndexPhysical_Mode ON dbo.fhsmIndexPhysical(Mode)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmIndexPhysical
		--
		BEGIN
			SET @objectName = ''dbo.fhsmIndexPhysical'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Index physical]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical'') + ''
				AS
				SELECT
					rankedData.Mode
					,rankedData.PartitionNumber
					,rankedData.IndexTypeDesc
					,rankedData.AllocUnitTypeDesc
					,rankedData.IndexDepth
					,rankedData.IndexLevel
					,rankedData.ColumnstoreDeleteBufferStateDesc
					,rankedData.AvgFragmentationInPercent
					,rankedData.FragmentCount
					,rankedData.AvgFragmentSizeInPages
					,rankedData.PageCount
					,rankedData.AvgPageSpaceUsedInPercent
					,rankedData.RecordCount
					,rankedData.GhostRecordCount
					,rankedData.VersionGhostRecordCount
					,rankedData.MinRecordSizeInBytes
					,rankedData.MaxRecordSizeInBytes
					,rankedData.AvgRecordSizeInBytes
					,rankedData.ForwardedRecordCount
					,rankedData.CompressedPageCount
					,rankedData.VersionRecordCount
					,rankedData.InrowVersionRecordCount
					,rankedData.InrowDiffVersionRecordCount
					,rankedData.TotalInrowVersionPayloadSizeInBytes
					,rankedData.OffrowRegularVersionRecordCount
					,rankedData.OffrowLongTermVersionRecordCount
					,rankedData.TimestampDate AS Date
					,rankedData.TimeKey
					,rankedData.DatabaseKey
					,rankedData.SchemaKey
					,rankedData.ObjectKey
					,rankedData.IndexKey
					,rankedData.IndexTypeKey
					,rankedData.IndexAllocTypeKey
				FROM (
					SELECT
						ip.*
						,DENSE_RANK() OVER(PARTITION BY ip.DatabaseKey, ip.SchemaKey, ip.ObjectKey ORDER BY CASE ip.Mode WHEN ''''DETAILED'''' THEN 1 WHEN ''''SAMPLED'''' THEN 2 ELSE 3 END, ip.TimestampUTC DESC) AS _Rnk_
					FROM dbo.fhsmIndexPhysical AS ip
					WHERE (ip.TimestampUTC >= (
						SELECT DATEADD(HOUR, -24, MAX(ip2.TimestampUTC))
						FROM dbo.fhsmIndexPhysical AS ip2
					))
				) AS rankedData
				WHERE (rankedData._Rnk_ = 1);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Index physical]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Index physical detailed]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical detailed'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical detailed'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical detailed'') + ''
				AS
				SELECT
					ip.Mode
					,ip.PartitionNumber
					,ip.IndexTypeDesc
					,ip.AllocUnitTypeDesc
					,ip.IndexDepth
					,ip.IndexLevel
					,ip.ColumnstoreDeleteBufferStateDesc
					,ip.AvgFragmentationInPercent
					,ip.FragmentCount
					,ip.AvgFragmentSizeInPages
					,ip.PageCount
					,ip.AvgPageSpaceUsedInPercent
					,ip.RecordCount
					,ip.GhostRecordCount
					,ip.VersionGhostRecordCount
					,ip.MinRecordSizeInBytes
					,ip.MaxRecordSizeInBytes
					,ip.AvgRecordSizeInBytes
					,ip.ForwardedRecordCount
					,ip.CompressedPageCount
					,ip.VersionRecordCount
					,ip.InrowVersionRecordCount
					,ip.InrowDiffVersionRecordCount
					,ip.TotalInrowVersionPayloadSizeInBytes
					,ip.OffrowRegularVersionRecordCount
					,ip.OffrowLongTermVersionRecordCount
					,ip.Timestamp
					,ip.TimestampDate AS Date
					,ip.TimeKey
					,ip.DatabaseKey
					,ip.SchemaKey
					,ip.ObjectKey
					,ip.IndexKey
					,ip.IndexTypeKey
					,ip.IndexAllocTypeKey
				FROM dbo.fhsmIndexPhysical AS ip
				WHERE (ip.Mode = ''''DETAILED'''')
			'';
			SET @stmt += ''
				UNION ALL

				SELECT
					ip.Mode
					,ip.PartitionNumber
					,ip.IndexTypeDesc
					,ip.AllocUnitTypeDesc
					,ip.IndexDepth
					,ip.IndexLevel
					,ip.ColumnstoreDeleteBufferStateDesc
					,ip.AvgFragmentationInPercent
					,ip.FragmentCount
					,ip.AvgFragmentSizeInPages
					,ip.PageCount
					,ip.AvgPageSpaceUsedInPercent
					,ip.RecordCount
					,ip.GhostRecordCount
					,ip.VersionGhostRecordCount
					,ip.MinRecordSizeInBytes
					,ip.MaxRecordSizeInBytes
					,ip.AvgRecordSizeInBytes
					,ip.ForwardedRecordCount
					,ip.CompressedPageCount
					,ip.VersionRecordCount
					,ip.InrowVersionRecordCount
					,ip.InrowDiffVersionRecordCount
					,ip.TotalInrowVersionPayloadSizeInBytes
					,ip.OffrowRegularVersionRecordCount
					,ip.OffrowLongTermVersionRecordCount
					,ip.Timestamp
					,ip.TimestampDate AS Date
					,ip.TimeKey
					,ip.DatabaseKey
					,ip.SchemaKey
					,ip.ObjectKey
					,ip.IndexKey
					,ip.IndexTypeKey
					,ip.IndexAllocTypeKey
				FROM dbo.fhsmIndexPhysical AS ip
				WHERE (ip.Mode = ''''SAMPLED'''')
					AND NOT EXISTS (
						SELECT *
						FROM dbo.fhsmIndexPhysical AS ip2
						WHERE (ip2.DatabaseKey = ip.DatabaseKey)
							AND (ip2.SchemaKey = ip.SchemaKey)
							AND (ip2.ObjectKey = ip.ObjectKey)
							AND (ip2.TimestampUTCDate = ip.TimestampUTCDate)
							AND (ip2.Mode = ''''DETAILED'''')
					)
			'';
			SET @stmt += ''
				UNION ALL

				SELECT
					ip.Mode
					,ip.PartitionNumber
					,ip.IndexTypeDesc
					,ip.AllocUnitTypeDesc
					,ip.IndexDepth
					,ip.IndexLevel
					,ip.ColumnstoreDeleteBufferStateDesc
					,ip.AvgFragmentationInPercent
					,ip.FragmentCount
					,ip.AvgFragmentSizeInPages
					,ip.PageCount
					,ip.AvgPageSpaceUsedInPercent
					,ip.RecordCount
					,ip.GhostRecordCount
					,ip.VersionGhostRecordCount
					,ip.MinRecordSizeInBytes
					,ip.MaxRecordSizeInBytes
					,ip.AvgRecordSizeInBytes
					,ip.ForwardedRecordCount
					,ip.CompressedPageCount
					,ip.VersionRecordCount
					,ip.InrowVersionRecordCount
					,ip.InrowDiffVersionRecordCount
					,ip.TotalInrowVersionPayloadSizeInBytes
					,ip.OffrowRegularVersionRecordCount
					,ip.OffrowLongTermVersionRecordCount
					,ip.Timestamp
					,ip.TimestampDate AS Date
					,ip.TimeKey
					,ip.DatabaseKey
					,ip.SchemaKey
					,ip.ObjectKey
					,ip.IndexKey
					,ip.IndexTypeKey
					,ip.IndexAllocTypeKey
				FROM dbo.fhsmIndexPhysical AS ip
				WHERE NOT EXISTS (
						SELECT *
						FROM dbo.fhsmIndexPhysical AS ip2
						WHERE (ip2.DatabaseKey = ip.DatabaseKey)
							AND (ip2.SchemaKey = ip.SchemaKey)
							AND (ip2.ObjectKey = ip.ObjectKey)
							AND (ip2.TimestampUTCDate = ip.TimestampUTCDate)
							AND (ip2.Mode IN (''''DETAILED'''', ''''SAMPLED''''))
					);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Index physical detailed]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index physical detailed'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPIndexPhysical
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPIndexPhysical'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPIndexPhysical AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPIndexPhysical (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @columnstoreDeleteBufferStateDescGroupByStmt nvarchar(max);
					DECLARE @columnstoreDeleteBufferStateDescStmt nvarchar(max);
					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @fhsmDatabaseName nvarchar(128);
					DECLARE @inrowDiffVersionRecordCountStmt nvarchar(max);
					DECLARE @inrowVersionRecordCountStmt nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @mode nvarchar(128);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @object nvarchar(128);
					DECLARE @offrowLongTermVersionRecordCountStmt nvarchar(max);
					DECLARE @offrowRegularVersionRecordCountStmt nvarchar(max);
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);
					DECLARE @totalInrowVersionPayloadSizeInBytesStmt nvarchar(max);
					DECLARE @versionRecordCountStmt nvarchar(max);

					SET @fhsmDatabaseName = DB_NAME();
					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));
						SET @object = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Object''''));
						SET @mode = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Mode''''));
		
						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;

						--
						-- Trim @object if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @object = LTRIM(RTRIM(@object));
							WHILE (LEFT(@object, 1) = '''''''''''''''') AND (LEFT(@object, 1) = '''''''''''''''')
							BEGIN
								SET @object = SUBSTRING(@object, 2, LEN(@object) - 2);
							END;
						END;

						--
						-- Trim @mode if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @mode = LTRIM(RTRIM(@mode));
							WHILE (LEFT(@mode, 1) = '''''''''''''''') AND (LEFT(@mode, 1) = '''''''''''''''')
							BEGIN
								SET @mode = SUBSTRING(@mode, 2, LEN(@mode) - 2);
							END;
						END;
					END;
			'';
			SET @stmt += ''
					--
					-- Verify the @mode parameter
					--
					BEGIN
						IF (@mode IS NULL) OR (@mode NOT IN (''''LIMITED'''', ''''SAMPLED'''', ''''DETAILED''''))
						BEGIN
							SET @message = ''''Mode is invalied - '''' + COALESCE(@mode, ''''<NULL>'''');
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Error'''', @message = @message;

							RETURN -1;
						END;
					END;

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						--
						-- Test if columnstore_delete_buffer_state_desc exists on dm_db_index_physical_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_db_index_physical_stats'''') AND (sc.name = ''''columnstore_delete_buffer_state_desc'''')
							)
							BEGIN
								SET @columnstoreDeleteBufferStateDescStmt = ''''ddips.columnstore_delete_buffer_state_desc'''';
								SET @columnstoreDeleteBufferStateDescGroupByStmt = '''',ddips.columnstore_delete_buffer_state_desc'''';
							END
							ELSE BEGIN
								SET @columnstoreDeleteBufferStateDescStmt = ''''NULL'''';
								SET @columnstoreDeleteBufferStateDescGroupByStmt = '''''''';
							END;
						END;

						--
						-- Test if version_record_count (and thereby all other *version*) exists on dm_db_index_physical_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_db_index_physical_stats'''') AND (sc.name = ''''version_record_count'''')
							)
							BEGIN
								SET @versionRecordCountStmt = ''''SUM(ddips.version_record_count)'''';
								SET @inrowVersionRecordCountStmt = ''''SUM(ddips.inrow_version_record_count)'''';
								SET @inrowDiffVersionRecordCountStmt = ''''SUM(ddips.inrow_diff_version_record_count)'''';
								SET @totalInrowVersionPayloadSizeInBytesStmt = ''''SUM(ddips.total_inrow_version_payload_size_in_bytes)'''';
								SET @offrowRegularVersionRecordCountStmt = ''''SUM(ddips.offrow_regular_version_record_count)'''';
								SET @offrowLongTermVersionRecordCountStmt = ''''SUM(ddips.offrow_long_term_version_record_count)'''';
							END
							ELSE BEGIN
								SET @versionRecordCountStmt = ''''NULL'''';
								SET @inrowVersionRecordCountStmt = ''''NULL'''';
								SET @inrowDiffVersionRecordCountStmt = ''''NULL'''';
								SET @totalInrowVersionPayloadSizeInBytesStmt = ''''NULL'''';
								SET @offrowRegularVersionRecordCountStmt = ''''NULL'''';
								SET @offrowLongTermVersionRecordCountStmt = ''''NULL'''';
							END;
						END;

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
			'';
			SET @stmt += ''
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + '''';

									IF
										(@object COLLATE DATABASE_DEFAULT IS NULL)
										OR ((@object COLLATE DATABASE_DEFAULT IS NOT NULL) AND (OBJECT_ID(@object) IS NOT NULL))
									BEGIN
										SELECT
											DB_NAME() AS DatabaseName
											,sch.name AS SchemaName
											,o.name AS ObjectName
											,i.name AS IndexName
											,@mode AS Mode
											,ddips.partition_number AS PartitionNumber
											,ddips.index_type_desc AS IndexTypeDesc
											,ddips.alloc_unit_type_desc AS AllocUnitTypeDesc
											,ddips.index_depth AS IndexDepth
											,ddips.index_level AS IndexLevel
											,'''' + @columnstoreDeleteBufferStateDescStmt + '''' AS ColumnstoreDeleteBufferStateDesc
											,AVG(ddips.avg_fragmentation_in_percent) AS AvgFragmentationInPercent
											,SUM(ddips.fragment_count) AS FragmentCount
											,AVG(ddips.avg_fragment_size_in_pages) AS AvgFragmentSizeInPages
											,SUM(ddips.page_count) AS PageCount
											,AVG(ddips.avg_page_space_used_in_percent) AS AvgPageSpaceUsedInPercent
											,SUM(ddips.record_count) AS RecordCount
											,SUM(ddips.ghost_record_count) AS GhostRecordCount
											,SUM(ddips.version_ghost_record_count) AS VersionGhostRecordCount
											,AVG(ddips.min_record_size_in_bytes) AS MinRecordSizeInBytes
											,AVG(ddips.max_record_size_in_bytes) AS MaxRecordSizeInBytes
											,AVG(ddips.avg_record_size_in_bytes) AS AvgRecordSizeInBytes
											,SUM(ddips.forwarded_record_count) AS ForwardedRecordCount
											,SUM(ddips.compressed_page_count) AS CompressedPageCount
			'';
			SET @stmt += ''
											,'''' + @versionRecordCountStmt + '''' AS VersionRecordCount
											,'''' + @inrowVersionRecordCountStmt + '''' AS InrowVersionRecordCount
											,'''' + @inrowDiffVersionRecordCountStmt + '''' AS InrowDiffVersionRecordCount
											,'''' + @totalInrowVersionPayloadSizeInBytesStmt + '''' AS TotalInrowVersionPayloadSizeInBytes
											,'''' + @offrowRegularVersionRecordCountStmt + '''' AS OffrowRegularVersionRecordCount
											,'''' + @offrowLongTermVersionRecordCountStmt + '''' AS OffrowLongTermVersionRecordCount
											,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
											,@nowUTC, @now
											,CAST(@nowUTC AS date) AS TimestampUTCDate, CAST(@now AS date) AS TimestampDate
											,(DATEPART(HOUR, @now) * 60 * 60) + (DATEPART(MINUTE, @now) * 60) + (DATEPART(SECOND, @now)) AS TimeKey
											,(SELECT k.[Key] FROM '''' + QUOTENAME(@fhsmDatabaseName) + ''''.dbo.fhsmFNGenerateKey(DB_NAME(), DEFAULT,  DEFAULT, DEFAULT,                    DEFAULT,               DEFAULT)                    AS k) AS DatabaseKey
											,(SELECT k.[Key] FROM '''' + QUOTENAME(@fhsmDatabaseName) + ''''.dbo.fhsmFNGenerateKey(DB_NAME(), sch.name, DEFAULT, DEFAULT,                    DEFAULT,               DEFAULT)                    AS k) AS SchemaKey
											,(SELECT k.[Key] FROM '''' + QUOTENAME(@fhsmDatabaseName) + ''''.dbo.fhsmFNGenerateKey(DB_NAME(), sch.name, o.name,  DEFAULT,                    DEFAULT,               DEFAULT)                    AS k) AS ObjectKey
											,(SELECT k.[Key] FROM '''' + QUOTENAME(@fhsmDatabaseName) + ''''.dbo.fhsmFNGenerateKey(DB_NAME(), sch.name, o.name,  COALESCE(i.name, ''''''''N.A.''''''''), DEFAULT,               DEFAULT)                    AS k) AS IndexKey
											,(SELECT k.[Key] FROM '''' + QUOTENAME(@fhsmDatabaseName) + ''''.dbo.fhsmFNGenerateKey(DB_NAME(), sch.name, o.name,  COALESCE(i.name, ''''''''N.A.''''''''), ddips.index_type_desc, DEFAULT)                    AS k) AS IndexTypeKey
											,(SELECT k.[Key] FROM '''' + QUOTENAME(@fhsmDatabaseName) + ''''.dbo.fhsmFNGenerateKey(DB_NAME(), sch.name, o.name,  COALESCE(i.name, ''''''''N.A.''''''''), ddips.index_type_desc, ddips.alloc_unit_type_desc) AS k) AS IndexAllocTypeKey
										FROM sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID(@object), NULL, NULL, @mode) AS ddips
										INNER JOIN sys.objects AS o ON (o.object_id = ddips.object_id)
										INNER JOIN sys.schemas AS sch ON (sch.schema_id = o.schema_id)
										LEFT OUTER JOIN sys.indexes AS i ON (ddips.object_id = i.object_id) AND (ddips.index_id = i.index_id)
										WHERE (o.type IN (''''''''U'''''''', ''''''''V''''''''))
										GROUP BY
											sch.name
											,o.name
											,i.name
											,ddips.partition_number
											,ddips.index_type_desc
											,ddips.alloc_unit_type_desc
											,ddips.index_depth
											,ddips.index_level
											'''' + @columnstoreDeleteBufferStateDescGroupByStmt + '''';
									END;
								'''';
			'';
			SET @stmt += ''
								BEGIN TRY
									INSERT INTO dbo.fhsmIndexPhysical(
										DatabaseName, SchemaName, ObjectName, IndexName, Mode
										,PartitionNumber, IndexTypeDesc, AllocUnitTypeDesc, IndexDepth, IndexLevel, ColumnstoreDeleteBufferStateDesc
										,AvgFragmentationInPercent, FragmentCount, AvgFragmentSizeInPages
										,PageCount, AvgPageSpaceUsedInPercent, RecordCount
										,GhostRecordCount, VersionGhostRecordCount
										,MinRecordSizeInBytes, MaxRecordSizeInBytes, AvgRecordSizeInBytes
										,ForwardedRecordCount
										,CompressedPageCount
										,VersionRecordCount, InrowVersionRecordCount, InrowDiffVersionRecordCount, TotalInrowVersionPayloadSizeInBytes
										,OffrowRegularVersionRecordCount, OffrowLongTermVersionRecordCount
										,LastSQLServiceRestart
										,TimestampUTC, Timestamp
										,TimestampUTCDate, TimestampDate
										,TimeKey
										,DatabaseKey, SchemaKey, ObjectKey
										,IndexKey, IndexTypeKey, IndexAllocTypeKey
									)
									EXEC sp_executesql
										@stmt
										,N''''@mode nvarchar(8), @object nvarchar(128), @now datetime, @nowUTC datetime''''
										,@mode = @mode, @object = @object, @now = @now, @nowUTC = @nowUTC;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPIndexPhysical
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPIndexPhysical'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlIndexPhysical
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlIndexPhysical'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlIndexPhysical AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlIndexPhysical (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlIndexPhysical
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlIndexPhysical'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmIndexPhysical''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableIndexPhysical										AS Enabled
				,0															AS DeploymentStatus
				,''Index physical''											AS Name
				,PARSENAME(''dbo.fhsmSPIndexPhysical'', 1)					AS Task
				,12 * 60 * 60												AS ExecutionDelaySec
				,CAST(''1900-1-1T22:00:00.0000'' AS datetime2(0))				AS FromTime
				,CAST(''1900-1-1T23:00:00.0000'' AS datetime2(0))				AS ToTime
				,1, 1, 1, 1, 1, 1, 1										-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb'''' ; @Mode = LIMITED''	AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5, SrcColumn6
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5, OutputColumn6
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmIndexPhysical'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmIndexPhysical'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL, NULL, NULL
				,''Database'', ''Schema'', NULL, NULL, NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmIndexPhysical'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL, NULL, NULL
				,''Database'', ''Schema'', ''Object'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmIndexPhysical'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', NULL, NULL
				,''Database'', ''Schema'', ''Object'', ''Index'', NULL, NULL

			UNION ALL

			SELECT
				''Index type'' AS DimensionName
				,''IndexTypeKey'' AS DimensionKey
				,''dbo.fhsmIndexPhysical'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', ''src.[IndexTypeDesc]'', NULL
				,''Database'', ''Schema'', ''Object'', ''Index'', ''IndexType'', NULL

			UNION ALL

			SELECT
				''Index alloc type'' AS DimensionName
				,''IndexAllocTypeKey'' AS DimensionKey
				,''dbo.fhsmIndexPhysical'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')'', ''src.[IndexTypeDesc]'', ''src.[AllocUnitTypeDesc]''
				,''Database'', ''Schema'', ''Object'', ''Index'', ''IndexType'', ''IndexAllocType''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.SrcColumn5 = src.SrcColumn5
				,tgt.SrcColumn6 = src.SrcColumn6
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
				,tgt.OutputColumn5 = src.OutputColumn5
				,tgt.OutputColumn6 = src.OutputColumn6
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4, SrcColumn5, SrcColumn6
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4, OutputColumn5, OutputColumn6
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4, src.SrcColumn5, src.SrcColumn6
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4, src.OutputColumn5, src.OutputColumn6
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmIndexPhysical'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:IndexUsage.sql modified: 2025.08.05 19.11.04
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableIndexUsage bit;

	SET @enableIndexUsage = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing IndexUsage'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @cnt int;
	DECLARE @edition nvarchar(128);
	DECLARE @msg nvarchar(max);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmIndexUsage and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmIndexUsage'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmIndexUsage'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmIndexUsage(
						Id int identity(1,1) NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,SchemaName nvarchar(128) NOT NULL
						,ObjectName nvarchar(128) NOT NULL
						,IndexName nvarchar(128) NULL
						,UserSeeks bigint NULL
						,UserScans bigint NULL
						,UserLookups bigint NULL
						,UserUpdates bigint NULL
						,LastUserSeek datetime NULL
						,LastUserScan datetime NULL
						,LastUserLookup datetime NULL
						,LastUserUpdate datetime NULL
						,IndexType tinyint NOT NULL
						,IsUnique bit NOT NULL
						,IsPrimaryKey bit NOT NULL
						,IsUniqueConstraint bit NOT NULL
						,[FillFactor] tinyint NOT NULL
						,IsDisabled bit NOT NULL
						,IsHypothetical bit NOT NULL
						,AllowRowLocks bit NOT NULL
						,AllowPageLocks bit NOT NULL
						,HasFilter bit NOT NULL
						,FilterDefinition nvarchar(max) NULL
						,AutoCreated bit NULL
						,IndexColumns nvarchar(max) NULL
						,IncludedColumns nvarchar(max) NULL
						,LastSQLServiceRestart datetime NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmIndexUsage PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsage'')) AND (i.name = ''NC_fhsmIndexUsage_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmIndexUsage_TimestampUTC] to table dbo.fhsmIndexUsage'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmIndexUsage_TimestampUTC ON dbo.fhsmIndexUsage(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsage'')) AND (i.name = ''NC_fhsmIndexUsage_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmIndexUsage_Timestamp] to table dbo.fhsmIndexUsage'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmIndexUsage_Timestamp ON dbo.fhsmIndexUsage(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsage'')) AND (i.name = ''NC_fhsmIndexUsage_DatabaseName_SchemaName_ObjectName_IndexName''))
			BEGIN
				RAISERROR(''Dropping index [NC_fhsmIndexUsage_DatabaseName_SchemaName_ObjectName_IndexName] on table dbo.fhsmIndexUsage'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					DROP INDEX NC_fhsmIndexUsage_DatabaseName_SchemaName_ObjectName_IndexName ON dbo.fhsmIndexUsage;
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsage'')) AND (i.name = ''NC_fhsmIndexUsage_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmIndexUsage_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC] to table dbo.fhsmIndexUsage'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmIndexUsage_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC ON dbo.fhsmIndexUsage(DatabaseName, SchemaName, ObjectName, IndexName, TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmIndexUsage
			--
			BEGIN
				SET @objectName = ''dbo.fhsmIndexUsage'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmIndexUsageDelta and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmIndexUsageDelta'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmIndexUsageDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmIndexUsageDelta(
						Id int identity(1,1) NOT NULL
						,DatabaseName nvarchar(128) NOT NULL
						,SchemaName nvarchar(128) NOT NULL
						,ObjectName nvarchar(128) NOT NULL
						,IndexName nvarchar(128) NULL
						,UserSeeks bigint NULL
						,UserScans bigint NULL
						,UserLookups bigint NULL
						,UserUpdates bigint NULL
						,LastUserSeek datetime NULL
						,LastUserScan datetime NULL
						,LastUserLookup datetime NULL
						,LastUserUpdate datetime NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmIndexUsageDelta PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			--
			-- Processing data from dbo.fhsmIndexUsage into dbo.fhsmIndexUsageDelta, and before adding indexes
			--
			IF NOT EXISTS(SELECT * FROM dbo.fhsmIndexUsageDelta)
			BEGIN
				SET @cnt = (SELECT COUNT(*) FROM dbo.fhsmIndexUsage);
				RAISERROR(''Processing data from dbo.fhsmIndexUsage into dbo.fhsmIndexUsageDelta'', 0, 1) WITH NOWAIT;
				SET @msg = ''!!! This might take some time if there are lots of data in the table dbo.fhsmIndexUsage. The table contains '' + CAST(@cnt AS nvarchar) + '' rows'';
				RAISERROR(@msg, 0, 1) WITH NOWAIT;

				SET @stmt = '''';

				IF (@productVersion1 <= 10)
				BEGIN
					-- SQL Versions SQL2008R2 or lower

					SET @stmt += ''
					WITH indexUsage AS (
						SELECT
							iu.DatabaseName
							,iu.SchemaName
							,iu.ObjectName
							,iu.IndexName
							,iu.UserSeeks
							,iu.LastUserSeek
							,iu.UserScans
							,iu.LastUserScan
							,iu.UserLookups
							,iu.LastUserLookup
							,iu.UserUpdates
							,iu.LastUserUpdate
							,iu.LastSQLServiceRestart
							,iu.TimestampUTC
							,iu.Timestamp
							,ROW_NUMBER() OVER(PARTITION BY iu.DatabaseName, iu.SchemaName, iu.ObjectName, iu.IndexName ORDER BY iu.TimestampUTC) AS Idx
						FROM dbo.fhsmIndexUsage AS iu
					)
					'';
				END;
				SET @stmt += ''
					INSERT INTO dbo.fhsmIndexUsageDelta(
						DatabaseName, SchemaName, ObjectName, IndexName
						,UserSeeks, UserScans, UserLookups, UserUpdates
						,LastUserSeek, LastUserScan, LastUserLookup, LastUserUpdate
						,TimestampUTC, Timestamp
					)
					SELECT
						b.DatabaseName
						,b.SchemaName
						,b.ObjectName
						,b.IndexName
						,b.DeltaUserSeeks AS UserSeeks
						,b.DeltaUserScans AS UserScans
						,b.DeltaUserLookups AS UserLookups
						,b.DeltaUserUpdates AS UserUpdates
						,b.LastUserSeek
						,b.LastUserScan
						,b.LastUserLookup
						,b.LastUserUpdate
						,b.TimestampUTC
						,b.Timestamp
					FROM (
				'';
				SET @stmt += ''
						SELECT
							CASE
								WHEN (a.PreviousUserSeeks IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL									-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
								WHEN (a.PreviousUserSeeks > a.UserSeeks) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserSeeks	-- Either has the counters had an overflow or the server har been restarted
								ELSE a.UserSeeks - a.PreviousUserSeeks																						-- Difference
							END AS DeltaUserSeeks
							,a.LastUserSeek
							,CASE
								WHEN (a.PreviousUserScans IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
								WHEN (a.PreviousUserScans > a.UserScans) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserScans
								ELSE a.UserScans - a.PreviousUserScans
							END AS DeltaUserScans
							,a.LastUserScan
							,CASE
								WHEN (a.PreviousUserLookups IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
								WHEN (a.PreviousUserLookups > a.UserLookups) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserLookups
								ELSE a.UserLookups - a.PreviousUserLookups
							END AS DeltaUserLookups
							,a.LastUserLookup
							,CASE
								WHEN (a.PreviousUserUpdates IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
								WHEN (a.PreviousUserUpdates > a.UserUpdates) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserUpdates
								ELSE a.UserUpdates - a.PreviousUserUpdates
							END AS DeltaUserUpdates
							,a.LastUserUpdate
							,a.TimestampUTC
							,a.Timestamp
							,a.DatabaseName
							,a.SchemaName
							,a.ObjectName
							,a.IndexName
						FROM (
				'';
				IF (@productVersion1 <= 10)
				BEGIN
					-- SQL Versions SQL2008R2 or lower

					SET @stmt += ''
							SELECT
								iu.UserSeeks
								,prevIU.UserSeeks AS PreviousUserSeeks
								,iu.LastUserSeek
								,iu.UserScans
								,prevIU.UserScans AS PreviousUserScans
								,iu.LastUserScan
								,iu.UserLookups
								,prevIU.UserLookups AS PreviousUserLookups
								,iu.LastUserLookup
								,iu.UserUpdates
								,prevIU.UserUpdates AS PreviousUserUpdates
								,iu.LastUserUpdate
								,iu.LastSQLServiceRestart
								,prevIU.LastSQLServiceRestart AS PreviousLastSQLServiceRestart
								,iu.TimestampUTC
								,iu.Timestamp
								,iu.DatabaseName
								,iu.SchemaName
								,iu.ObjectName
								,iu.IndexName
							FROM indexUsage AS iu
							LEFT OUTER JOIN indexUsage AS prevIU ON
								(prevIU.DatabaseName = iu.DatabaseName)
								AND (prevIU.SchemaName = iu.SchemaName)
								AND (prevIU.ObjectName = iu.ObjectName)
								AND ((prevIU.IndexName = iu.IndexName) OR ((prevIU.IndexName IS NULL) AND (iu.IndexName IS NULL)))
								AND (prevIU.Idx = iu.Idx - 1)
					'';
				END
				ELSE BEGIN
					-- SQL Versions SQL2012 or higher

					SET @stmt += ''
							SELECT
								iu.UserSeeks
								,LAG(iu.UserSeeks) OVER(PARTITION BY iu.DatabaseName, iu.SchemaName, iu.ObjectName, iu.IndexName ORDER BY iu.TimestampUTC) AS PreviousUserSeeks
								,iu.LastUserSeek
								,iu.UserScans
								,LAG(iu.UserScans) OVER(PARTITION BY iu.DatabaseName, iu.SchemaName, iu.ObjectName, iu.IndexName ORDER BY iu.TimestampUTC) AS PreviousUserScans
								,iu.LastUserScan
								,iu.UserLookups
								,LAG(iu.UserLookups) OVER(PARTITION BY iu.DatabaseName, iu.SchemaName, iu.ObjectName, iu.IndexName ORDER BY iu.TimestampUTC) AS PreviousUserLookups
								,iu.LastUserLookup
								,iu.UserUpdates
								,LAG(iu.UserUpdates) OVER(PARTITION BY iu.DatabaseName, iu.SchemaName, iu.ObjectName, iu.IndexName ORDER BY iu.TimestampUTC) AS PreviousUserUpdates
								,iu.LastUserUpdate
								,iu.LastSQLServiceRestart
								,LAG(iu.LastSQLServiceRestart) OVER(PARTITION BY iu.DatabaseName, iu.SchemaName, iu.ObjectName, iu.IndexName ORDER BY iu.TimestampUTC) AS PreviousLastSQLServiceRestart
								,iu.TimestampUTC
								,iu.Timestamp
								,iu.DatabaseName
								,iu.SchemaName
								,iu.ObjectName
								,iu.IndexName
							FROM dbo.fhsmIndexUsage AS iu
					'';
				END;
				SET @stmt += ''
						) AS a
					) AS b
					WHERE
						(b.DeltaUserSeeks <> 0)
						OR (b.DeltaUserScans <> 0)
						OR (b.DeltaUserLookups <> 0)
						OR (b.DeltaUserUpdates <> 0)
					ORDER BY b.TimestampUTC, b.DatabaseName, b.SchemaName, b.ObjectName, b.IndexName;
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsageDelta'')) AND (i.name = ''NC_fhsmIndexUsageDelta_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmIndexUsageDelta_TimestampUTC] to table dbo.fhsmIndexUsageDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmIndexUsageDelta_TimestampUTC ON dbo.fhsmIndexUsageDelta(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsageDelta'')) AND (i.name = ''NC_fhsmIndexUsageDelta_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmIndexUsageDelta_Timestamp] to table dbo.fhsmIndexUsageDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmIndexUsageDelta_Timestamp ON dbo.fhsmIndexUsageDelta(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmIndexUsageDelta'')) AND (i.name = ''NC_fhsmIndexUsageDelta_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmIndexUsageDelta_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC] to table dbo.fhsmIndexUsageDelta'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmIndexUsageDelta_DatabaseName_SchemaName_ObjectName_IndexName_TimestampUTC ON dbo.fhsmIndexUsageDelta(DatabaseName, SchemaName, ObjectName, IndexName, TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmIndexUsageDelta
			--
			BEGIN
				SET @objectName = ''dbo.fhsmIndexUsageDelta'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Index configuration]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index configuration'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index configuration'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index configuration'') + ''
				AS
			'';
			SET @stmt += ''
				SELECT
					CAST(COALESCE((tableIsHeap.IsHeap), 0) AS bit) AS TableIsHeap
					,CASE iu.IndexType
						WHEN 0 THEN ''''HEAP''''
						WHEN 1 THEN ''''CL''''
						WHEN 2 THEN ''''NCL''''
						WHEN 3 THEN ''''XML''''
						WHEN 4 THEN ''''Spatial''''
						WHEN 5 THEN ''''CL-COL''''
						WHEN 6 THEN ''''NCL-COL''''
						WHEN 7 THEN ''''NCL-HASH''''
					END AS IndexTypeDesc
					,iu.IsUnique			+ 0 AS IsUnique
					,iu.IsPrimaryKey		+ 0 AS IsPrimaryKey
					,iu.IsUniqueConstraint	+ 0 AS IsUniqueConstraint
					,iu.[FillFactor]
					,iu.IsDisabled			+ 0 AS IsDisabled
					,iu.IsHypothetical		+ 0 AS IsHypothetical
					,iu.AllowRowLocks		+ 0 AS AllowRowLocks
					,iu.AllowPageLocks		+ 0 AS AllowPageLocks
					,iu.HasFilter			+ 0 AS HasFilter
					,iu.FilterDefinition
					,iu.AutoCreated			+ 0 AS AutoCreated
					,iu.IndexColumns
					,iu.IncludedColumns
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iu.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iu.DatabaseName, iu.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iu.DatabaseName, iu.SchemaName, iu.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iu.DatabaseName, iu.SchemaName, iu.ObjectName, COALESCE(iu.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
				FROM dbo.fhsmIndexUsage AS iu
				OUTER APPLY (
					SELECT 1 AS IsHeap
					FROM dbo.fhsmIndexUsage AS iuIsHeap
					WHERE (iuIsHeap.TimestampUTC = iu.TimestampUTC)
						AND (iuIsHeap.DatabaseName = iu.DatabaseName)
						AND (iuIsHeap.SchemaName = iu.SchemaName)
						AND (iuIsHeap.ObjectName = iu.ObjectName)
						AND (iuIsHeap.IndexType = 0)
				) AS tableIsHeap
				WHERE (iu.TimestampUTC = (
					SELECT MAX(iuLatest.TimestampUTC)
					FROM dbo.fhsmIndexUsage AS iuLatest
				));
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Index configuration]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index configuration'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Index usage]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index usage'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index usage'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index usage'') + ''
				AS
				SELECT
					iud.UserSeeks
					,iud.LastUserSeek
					,iud.UserScans
					,iud.LastUserScan
					,iud.UserLookups
					,iud.LastUserLookup
					,iud.UserUpdates
					,iud.LastUserUpdate
					,iud.Timestamp
					,CAST(iud.Timestamp AS date) AS Date
					,(DATEPART(HOUR, iud.Timestamp) * 60 * 60) + (DATEPART(MINUTE, iud.Timestamp) * 60) + (DATEPART(SECOND, iud.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iud.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iud.DatabaseName, iud.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iud.DatabaseName, iud.SchemaName, iud.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(iud.DatabaseName, iud.SchemaName, iud.ObjectName, COALESCE(iud.IndexName, ''''N.A.''''), DEFAULT, DEFAULT) AS k) AS IndexKey
				FROM (
					SELECT
						iu.DatabaseName
						,iu.SchemaName
						,iu.ObjectName
						,iu.IndexName
					FROM dbo.fhsmIndexUsage AS iu
					WHERE (iu.TimestampUTC = (
						SELECT MAX(iuLatest.TimestampUTC)
						FROM dbo.fhsmIndexUsage AS iuLatest
					))
				) AS iuExists
				INNER JOIN dbo.fhsmIndexUsageDelta AS iud
					ON (iud.DatabaseName = iuExists.DatabaseName)
					AND (iud.SchemaName = iuExists.SchemaName)
					AND (iud.ObjectName = iuExists.ObjectName)
					AND ((iud.IndexName = iuExists.IndexName) OR ((iud.IndexName IS NULL) AND (iuExists.IndexName IS NULL)));
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Index usage]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Index usage'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPIndexUsage
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPIndexUsage'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPIndexUsage AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPIndexUsage (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @autoCreatedStmt nvarchar(max);
					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @prevTimestampUTC datetime;
					DECLARE @processingId int;
					DECLARE @processingTimestamp datetime;
					DECLARE @processingTimestampUTC datetime;
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;
					END;
			'';
			SET @stmt += ''

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						--
						-- Remember latest to be used as previous when loading data into dbo.fhsmIndexUsageDelta
						--
						SET @prevTimestampUTC = (
							SELECT MAX(iu.TimestampUTC)
							FROM dbo.fhsmIndexUsage AS iu
						);

						--
						-- Test if auto_created exists on indexes
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''indexes'''') AND (sc.name = ''''auto_created'''')
							)
							BEGIN
								SET @autoCreatedStmt = ''''i.auto_created'''';
							END
							ELSE BEGIN
								SET @autoCreatedStmt = ''''NULL'''';
							END;
						END;

						SET @message = ''''Before loading data into dbo.fhsmIndexUsage'''';
						EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

						--
						-- Insert Processing record and remember the @id in the variable @processingId
						-- Type: 1: Loading data into dbo.fhsmIndexUsage
						--
						SET @processingId = NULL;
						SELECT
							@processingTimestampUTC = SYSUTCDATETIME()
							,@processingTimestamp = SYSDATETIME();
						EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 1, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;
			'';
			SET @stmt += ''

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + '''';

									SELECT
										DB_NAME() AS DatabaseName
										,sch.name AS SchemaName
										,o.name AS ObjectName
										,i.name AS IndexName
										,s.user_seeks AS UserSeeks
										,s.user_scans AS UserScans
										,s.user_lookups AS UserLookups
										,s.user_updates AS UserUpdates
										,s.last_user_seek AS LastUserSeek
										,s.last_user_scan AS LastUserScan
										,s.last_user_lookup AS LastUserLookup
										,s.last_user_update AS LastUserUpdate
										,i.type AS IndexType
										,i.is_unique AS IsUnique
										,i.is_primary_key AS IsPrimaryKey
										,i.is_unique_constraint AS IsUniqueConstraint
										,i.fill_factor AS [FillFactor]
										,i.is_disabled AS IsDisabled
										,i.is_hypothetical AS IsHypothetical
										,i.allow_row_locks AS AllowRowLocks
										,i.allow_page_locks AS AllowPageLocks
										,i.has_filter AS HasFilter
										,i.filter_definition AS FilterDefinition
										,'''' + @autoCreatedStmt + '''' AS AutoCreated
										,indexColumns.Columns AS IndexColumns
										,includedColumns.Columns AS IncludedColumns
										,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
										,@nowUTC, @now
									FROM sys.indexes AS i WITH (NOLOCK)
									LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK) ON (s.database_id = DB_ID()) AND (s.object_id = i.object_id) AND (s.index_id = i.index_id)
									INNER JOIN sys.objects AS o WITH (NOLOCK) ON (o.object_id = i.object_id)
									INNER JOIN sys.schemas AS sch WITH (NOLOCK) ON (sch.schema_id = o.schema_id)
				'';
				SET @stmt += ''
									OUTER APPLY (
										SELECT STUFF((
											SELECT '''''''','''''''' + QUOTENAME(c.name) AS ColumnName
											FROM sys.index_columns AS ic WITH (NOLOCK)
											INNER JOIN sys.columns AS c WITH (NOLOCK) ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
											WHERE (ic.object_id = i.object_id) AND (ic.index_id = i.index_id)
												AND (ic.is_included_column = 0) AND (ic.key_ordinal <> 0)
											ORDER BY ic.key_ordinal
											FOR XML PATH (''''''''''''''''), type
										).value(''''''''.'''''''', ''''''''nvarchar(max)''''''''), 1, 1, '''''''''''''''') AS Columns
									) AS indexColumns
									OUTER APPLY (
										SELECT STUFF((
											SELECT '''''''','''''''' + QUOTENAME(c.name) AS ColumnName
											FROM sys.index_columns AS ic WITH (NOLOCK)
											INNER JOIN sys.columns AS c WITH (NOLOCK) ON (c.object_id = ic.object_id) AND (c.column_id = ic.column_id)
											WHERE (ic.object_id = i.object_id) AND (ic.index_id = i.index_id)
												AND (ic.is_included_column = 1)
											ORDER BY ic.key_ordinal
											FOR XML PATH (''''''''''''''''), type
										).value(''''''''.'''''''', ''''''''nvarchar(max)''''''''), 1, 1, '''''''''''''''') AS Columns
									) AS includedColumns
									WHERE (o.type IN (''''''''U'''''''', ''''''''V''''''''))
								'''';
								BEGIN TRY
									INSERT INTO dbo.fhsmIndexUsage(
										DatabaseName, SchemaName, ObjectName, IndexName
										,UserSeeks, UserScans, UserLookups, UserUpdates
										,LastUserSeek, LastUserScan, LastUserLookup, LastUserUpdate
										,IndexType, IsUnique, IsPrimaryKey, IsUniqueConstraint
										,[FillFactor]
										,IsDisabled, IsHypothetical
										,AllowRowLocks, AllowPageLocks
										,HasFilter, FilterDefinition
										,AutoCreated
										,IndexColumns, IncludedColumns
										,LastSQLServiceRestart
										,TimestampUTC, Timestamp
									)
									EXEC sp_executesql
										@stmt
										,N''''@now datetime, @nowUTC datetime''''
										,@now = @now, @nowUTC = @nowUTC;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;

						--
						-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
						-- Type: 1: Loading data into dbo.fhsmIndexUsage
						--
						SELECT
							@processingTimestampUTC = SYSUTCDATETIME()
							,@processingTimestamp = SYSDATETIME();
						EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 1, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

						SET @message = ''''After loading data into dbo.fhsmIndexUsage'''';
						EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
	'';
	SET @stmt += ''
						--
						-- Process all new records in dbo.fhsmIndexUsage into dbo.fhsmIndexUsageDelta
						--
						BEGIN
							SET @message = ''''Before loading data into dbo.fhsmIndexUsageDelta'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;

							--
							-- Insert Processing record and remember the @id in the variable @processingId
							-- Type: 2: Loading data into dbo.fhsmIndexUsageDelta
							--
							SET @processingId = NULL;
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = NULL, @type = 2, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							INSERT INTO dbo.fhsmIndexUsageDelta(
								DatabaseName, SchemaName, ObjectName, IndexName
								,UserSeeks, UserScans, UserLookups, UserUpdates
								,LastUserSeek, LastUserScan, LastUserLookup, LastUserUpdate
								,TimestampUTC, Timestamp
							)
							SELECT
								b.DatabaseName
								,b.SchemaName
								,b.ObjectName
								,b.IndexName
								,b.DeltaUserSeeks AS UserSeeks
								,b.DeltaUserScans AS UserScans
								,b.DeltaUserLookups AS UserLookups
								,b.DeltaUserUpdates AS UserUpdates
								,b.LastUserSeek
								,b.LastUserScan
								,b.LastUserLookup
								,b.LastUserUpdate
								,b.TimestampUTC
								,b.Timestamp
							FROM (
	'';
	SET @stmt += ''
								SELECT
									CASE
										WHEN (a.PreviousUserSeeks IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL									-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
										WHEN (a.PreviousUserSeeks > a.UserSeeks) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserSeeks	-- Either has the counters had an overflow or the server har been restarted
										ELSE a.UserSeeks - a.PreviousUserSeeks																						-- Difference
									END AS DeltaUserSeeks
									,a.LastUserSeek
									,CASE
										WHEN (a.PreviousUserScans IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousUserScans > a.UserScans) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserScans
										ELSE a.UserScans - a.PreviousUserScans
									END AS DeltaUserScans
									,a.LastUserScan
									,CASE
										WHEN (a.PreviousUserLookups IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousUserLookups > a.UserLookups) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserLookups
										ELSE a.UserLookups - a.PreviousUserLookups
									END AS DeltaUserLookups
									,a.LastUserLookup
									,CASE
										WHEN (a.PreviousUserUpdates IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
										WHEN (a.PreviousUserUpdates > a.UserUpdates) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserUpdates
										ELSE a.UserUpdates - a.PreviousUserUpdates
									END AS DeltaUserUpdates
									,a.LastUserUpdate
									,a.TimestampUTC
									,a.Timestamp
									,a.DatabaseName
									,a.SchemaName
									,a.ObjectName
									,a.IndexName
	'';
	SET @stmt += ''
								FROM (
									SELECT
										iu.UserSeeks
										,prevIU.UserSeeks AS PreviousUserSeeks
										,iu.LastUserSeek
										,iu.UserScans
										,prevIU.UserScans AS PreviousUserScans
										,iu.LastUserScan
										,iu.UserLookups
										,prevIU.UserLookups AS PreviousUserLookups
										,iu.LastUserLookup
										,iu.UserUpdates
										,prevIU.UserUpdates AS PreviousUserUpdates
										,iu.LastUserUpdate
										,iu.LastSQLServiceRestart
										,prevIU.LastSQLServiceRestart AS PreviousLastSQLServiceRestart
										,iu.TimestampUTC
										,iu.Timestamp
										,iu.DatabaseName
										,iu.SchemaName
										,iu.ObjectName
										,iu.IndexName
									FROM (
										SELECT *
										FROM dbo.fhsmIndexUsage AS iu
										WHERE (iu.TimestampUTC = @nowUTC)
									) AS iu
									INNER JOIN (
										SELECT *
										FROM dbo.fhsmIndexUsage AS iu
										WHERE (iu.TimestampUTC = @prevTimestampUTC)
									) AS prevIU
										ON (prevIU.DatabaseName = iu.DatabaseName)
										AND (prevIU.SchemaName = iu.SchemaName)
										AND (prevIU.ObjectName = iu.ObjectName)
										AND ((prevIU.IndexName = iu.IndexName) OR ((prevIU.IndexName IS NULL) AND (iu.IndexName IS NULL)))
	'';
	SET @stmt += ''
								) AS a
							) AS b
							WHERE
								(b.DeltaUserSeeks <> 0)
								OR (b.DeltaUserScans <> 0)
								OR (b.DeltaUserLookups <> 0)
								OR (b.DeltaUserUpdates <> 0);

							--
							-- Update Processing record from before execution with @version, @processingTimestampUTC and @processingTimestamp
							-- Type: 2: Loading data into dbo.fhsmIndexUsageDelta
							--
							SELECT
								@processingTimestampUTC = SYSUTCDATETIME()
								,@processingTimestamp = SYSDATETIME();
							EXEC dbo.fhsmSPProcessing @name = @name, @task = @thisTask, @version = @version, @type = 2, @timestampUTC = @processingTimestampUTC, @timestamp = @processingTimestamp, @id = @processingId OUTPUT;

							SET @message = ''''After loading data into dbo.fhsmIndexUsageDelta'''';
							EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
						END;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPIndexUsage
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPIndexUsage'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlIndexUsage
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlIndexUsage'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlIndexUsage AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlIndexUsage (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlIndexUsage
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlIndexUsage'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmIndexUsage''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);

		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmIndexUsageDelta''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableIndexUsage								AS Enabled
				,0												AS DeploymentStatus
				,''Index usage''									AS Name
				,PARSENAME(''dbo.fhsmSPIndexUsage'', 1)			AS Task
				,4 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T06:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb''''''		AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmIndexUsage'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmIndexUsage'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL, NULL
				,''Database'', ''Schema'', NULL, NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmIndexUsage'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', NULL
				,''Database'', ''Schema'', ''Object'', NULL

			UNION ALL

			SELECT
				''Index'' AS DimensionName
				,''IndexKey'' AS DimensionKey
				,''dbo.fhsmIndexUsage'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]'', ''COALESCE(src.[IndexName], ''''N.A.'''')''
				,''Database'', ''Schema'', ''Object'', ''Index''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmIndexUsage'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:InstanceState.sql modified: 2025.08.05 19.11.19
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableInstanceState bit;

	SET @enableInstanceState = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing InstanceState'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmAgentAlerts and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmAgentAlerts'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmAgentAlerts'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmAgentAlerts(
						Id int identity(1,1) NOT NULL
						,MessageId int NOT NULL
						,Severity int NOT NULL
						,Description nvarchar(128) NOT NULL
						,CONSTRAINT PK_fhsmAgentAlerts PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmAgentAlerts'')) AND (i.name = ''NC_fhsmAgentAlerts_MessageId_Severity''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmAgentAlerts_MessageId_Severity] to table dbo.fhsmAgentAlerts'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmAgentAlerts_MessageId_Severity ON dbo.fhsmAgentAlerts(MessageId, Severity)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmAgentAlerts
			--
			BEGIN
				SET @objectName = ''dbo.fhsmAgentAlerts'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmDefaultConfigurations and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmDefaultConfigurations'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmDefaultConfigurations'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmDefaultConfigurations(
						Id int identity(1,1) NOT NULL
						,ProductMajorVersion int NOT NULL
						,ProductMinorVersion int NOT NULL
						,ConfigurationId int NOT NULL
						,Value int NOT NULL
						,CONSTRAINT PK_fhsmDefaultConfigurations PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmDefaultConfigurations'')) AND (i.name = ''NC_fhsmDefaultConfigurations_ConfigurationId_ProductMajorVersion_ProductMinorVersion''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmDefaultConfigurations_ConfigurationId_ProductMajorVersion_ProductMinorVersion] to table dbo.fhsmDefaultConfigurations'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmDefaultConfigurations_ConfigurationId_ProductMajorVersion_ProductMinorVersion ON dbo.fhsmDefaultConfigurations(ConfigurationId, ProductMajorVersion, ProductMinorVersion)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmDefaultConfigurations
			--
			BEGIN
				SET @objectName = ''dbo.fhsmDefaultConfigurations'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmInstanceConfigurations and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmInstanceConfigurations'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmInstanceConfigurations'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmInstanceConfigurations(
						Id int identity(1,1) NOT NULL
						,ProductMajorVersion int NOT NULL
						,ProductMinorVersion int NOT NULL
						,ConfigurationId int NOT NULL
						,Minimum int NOT NULL
						,Maximum int NOT NULL
						,CONSTRAINT PK_fhsmInstanceConfigurations PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmInstanceConfigurations'')) AND (i.name = ''NC_fhsmInstanceConfigurations_ConfigurationId_ProductMajorVersion_ProductMinorVersion''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmInstanceConfigurations_ConfigurationId_ProductMajorVersion_ProductMinorVersion] to table dbo.fhsmInstanceConfigurations'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmInstanceConfigurations_ConfigurationId_ProductMajorVersion_ProductMinorVersion ON dbo.fhsmInstanceConfigurations(ConfigurationId, ProductMajorVersion, ProductMinorVersion)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmInstanceConfigurations
			--
			BEGIN
				SET @objectName = ''dbo.fhsmInstanceConfigurations'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmInstanceState and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmInstanceState'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmInstanceState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmInstanceState(
						Id int identity(1,1) NOT NULL
						,Query int NOT NULL
						,Category nvarchar(128) NOT NULL
						,[Key] nvarchar(128) NOT NULL
						,Value nvarchar(max) NOT NULL
						,ValidFrom datetime NOT NULL
						,ValidTo datetime NOT NULL
						,TimestampUTC datetime NOT NULL
						,Timestamp datetime NOT NULL
						,CONSTRAINT PK_fhsmInstanceState PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmInstanceState'')) AND (i.name = ''NC_fhsmInstanceState_TimestampUTC''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmInstanceState_TimestampUTC] to table dbo.fhsmInstanceState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmInstanceState_TimestampUTC ON dbo.fhsmInstanceState(TimestampUTC)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmInstanceState'')) AND (i.name = ''NC_fhsmInstanceState_Timestamp''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmInstanceState_Timestamp] to table dbo.fhsmInstanceState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmInstanceState_Timestamp ON dbo.fhsmInstanceState(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmInstanceState'')) AND (i.name = ''NC_fhsmInstanceState_Query_Category_Key_ValidTo''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmInstanceState_Query_Category_Key_ValidTo] to table dbo.fhsmInstanceState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmInstanceState_Query_Category_Key_ValidTo ON dbo.fhsmInstanceState(Query, Category, [Key], ValidTo) INCLUDE(Value)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmInstanceState'')) AND (i.name = ''NC_fhsmInstanceState_ValidTo_Query_Category_key''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmInstanceState_ValidTo_Query_Category_key] to table dbo.fhsmInstanceState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmInstanceState_ValidTo_Query_Category_key ON dbo.fhsmInstanceState(ValidTo, Query, Category, [Key]) INCLUDE(Value)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmInstanceState'')) AND (i.name = ''NC_fhsmInstanceState_Category''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmInstanceState_Category] to table dbo.fhsmInstanceState'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmInstanceState_Category ON dbo.fhsmInstanceState(Category ASC) INCLUDE(Timestamp)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmInstanceState
			--
			BEGIN
				SET @objectName = ''dbo.fhsmInstanceState'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmLifecycle and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmLifecycle'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmLifecycle'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmLifecycle(
						Id int identity(1,1) NOT NULL
						,ProductMajorVersion int NOT NULL
						,ProductMinorVersion int NOT NULL
						,MainstreamEndDate date NOT NULL
						,ExtendedEndDate date NOT NULL
						,CONSTRAINT PK_fhsmLifecycle PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmLifecycle'')) AND (i.name = ''NC_fhsmLifecycle_ProductMajorVersion_ProductMinorVersion''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmLifecycle_ProductMajorVersion_ProductMinorVersion] to table dbo.fhsmLifecycle'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmLifecycle_ProductMajorVersion_ProductMinorVersion ON dbo.fhsmLifecycle(ProductMajorVersion, ProductMinorVersion)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmLifecycle
			--
			BEGIN
				SET @objectName = ''dbo.fhsmLifecycle'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create table dbo.fhsmTraceFlags and indexes if they not already exists
		--
		BEGIN
			IF OBJECT_ID(''dbo.fhsmTraceFlags'', ''U'') IS NULL
			BEGIN
				RAISERROR(''Creating table dbo.fhsmTraceFlags'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE TABLE dbo.fhsmTraceFlags(
						Id int identity(1,1) NOT NULL
						,ProductMajorVersion int NOT NULL
						,ProductMinorVersion int NOT NULL
						,TraceFlag int NOT NULL
						,Description nvarchar(max) NOT NULL
						,URL nvarchar(max) NULL
						,CONSTRAINT PK_fhsmTraceFlags PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
					);
				'';
				EXEC(@stmt);
			END;

			IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTraceFlags'')) AND (i.name = ''NC_fhsmTraceFlags_TraceFlag_ProductMajorVersion_ProductMinorVersion''))
			BEGIN
				RAISERROR(''Adding index [NC_fhsmTraceFlags_TraceFlag_ProductMajorVersion_ProductMinorVersion] to table dbo.fhsmTraceFlags'', 0, 1) WITH NOWAIT;

				SET @stmt = ''
					CREATE NONCLUSTERED INDEX NC_fhsmTraceFlags_TraceFlag_ProductMajorVersion_ProductMinorVersion ON dbo.fhsmTraceFlags(TraceFlag, ProductMajorVersion, ProductMinorVersion)'' + @tableCompressionStmt + '';
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on the table dbo.fhsmTraceFlags
			--
			BEGIN
				SET @objectName = ''dbo.fhsmTraceFlags'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create default agent alert recommendations
	--
	BEGIN
		MERGE dbo.fhsmAgentAlerts AS tgt
		USING (
			SELECT 823 AS MessageId,  0 AS Severity, ''The operating system returned an error''                                         AS Description UNION ALL
			SELECT 824 AS MessageId,  0 AS Severity, ''Logical consistency-based I/O error''                                            AS Description UNION ALL
			SELECT 825 AS MessageId,  0 AS Severity, ''Read-Retry Required''                                                            AS Description UNION ALL
			SELECT 832 AS MessageId,  0 AS Severity, ''Constant page has changed''                                                      AS Description UNION ALL
			SELECT 855 AS MessageId,  0 AS Severity, ''Uncorrectable hardware memory corruption detected''                              AS Description UNION ALL
			SELECT 856 AS MessageId,  0 AS Severity, ''SQL Server has detected hardware memory corruption, but has recovered the page'' AS Description UNION ALL
			SELECT   0 AS MessageId, 19 AS Severity, ''Fatal Error in Resource''                                                        AS Description UNION ALL
			SELECT   0 AS MessageId, 20 AS Severity, ''Fatal Error in Current Process''                                                 AS Description UNION ALL
			SELECT   0 AS MessageId, 21 AS Severity, ''Fatal Error in Database Processes''                                              AS Description UNION ALL
			SELECT   0 AS MessageId, 22 AS Severity, ''Fatal Error: Table Integrity Suspect''                                           AS Description UNION ALL
			SELECT   0 AS MessageId, 23 AS Severity, ''Fatal Error: Database Integrity Suspect''                                        AS Description UNION ALL
			SELECT   0 AS MessageId, 24 AS Severity, ''Fatal Error: Hardware Error''                                                    AS Description UNION ALL
			SELECT   0 AS MessageId, 25 AS Severity, ''Fatal Error''                                                                    AS Description
		) AS src
		ON (tgt.MessageId = src.MessageId) AND (tgt.Severity = src.Severity)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT (MessageId, Severity, Description)
				VALUES(src.MessageId, src.Severity, src.Description);
	END;

	--
	-- Create default configurations
	--
	BEGIN
		MERGE dbo.fhsmDefaultConfigurations AS tgt
		USING (
			--SQL2022
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         10 AS Value UNION ALL -- remote login timeout (s)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1584 AS ConfigurationId,          0 AS Value UNION ALL -- backup checksum default
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1585 AS ConfigurationId,          0 AS Value UNION ALL -- automatic soft-NUMA disabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1586 AS ConfigurationId,          0 AS Value UNION ALL -- external scripts enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1587 AS ConfigurationId,          1 AS Value UNION ALL -- clr strict security
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1588 AS ConfigurationId,          0 AS Value UNION ALL -- column encryption enclave type
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1589 AS ConfigurationId,          0 AS Value UNION ALL -- tempdb metadata memory-optimized
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1591 AS ConfigurationId,         15 AS Value UNION ALL -- ADR cleaner retry timeout (min)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1592 AS ConfigurationId,          4 AS Value UNION ALL -- ADR Preallocation Factor
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1595 AS ConfigurationId, 2147483647 AS Value UNION ALL -- Data processed daily limit in TB
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1596 AS ConfigurationId, 2147483647 AS Value UNION ALL -- Data processed weekly limit in TB
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1597 AS ConfigurationId, 2147483647 AS Value UNION ALL -- Data processed monthly limit in TB
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1598 AS ConfigurationId,          1 AS Value UNION ALL -- ADR Cleaner Thread Count
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1599 AS ConfigurationId,          0 AS Value UNION ALL -- hardware offload enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1600 AS ConfigurationId,          0 AS Value UNION ALL -- hardware offload config
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1601 AS ConfigurationId,          0 AS Value UNION ALL -- hardware offload mode
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1602 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression algorithm
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16393 AS ConfigurationId,          0 AS Value UNION ALL -- contained database authentication
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16394 AS ConfigurationId,          0 AS Value UNION ALL -- hadoop connectivity
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16395 AS ConfigurationId,          1 AS Value UNION ALL -- polybase network encryption
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16396 AS ConfigurationId,          0 AS Value UNION ALL -- remote data archive
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16397 AS ConfigurationId,          0 AS Value UNION ALL -- allow polybase export
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16398 AS ConfigurationId,          1 AS Value UNION ALL -- allow filesystem enumeration
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16399 AS ConfigurationId,          0 AS Value UNION ALL -- polybase enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16400 AS ConfigurationId,          0 AS Value UNION ALL -- suppress recovery model errors
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16401 AS ConfigurationId,          1 AS Value UNION ALL -- openrowset auto_create_statistics
			--SQL2019
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         10 AS Value UNION ALL -- remote login timeout (s)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1573 AS ConfigurationId,         60 AS Value UNION ALL -- user instance timeout
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1575 AS ConfigurationId,          1 AS Value UNION ALL -- user instances enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1584 AS ConfigurationId,          0 AS Value UNION ALL -- backup checksum default
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1585 AS ConfigurationId,          0 AS Value UNION ALL -- automatic soft-NUMA disabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1586 AS ConfigurationId,          0 AS Value UNION ALL -- external scripts enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1587 AS ConfigurationId,          1 AS Value UNION ALL -- clr strict security
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1588 AS ConfigurationId,          0 AS Value UNION ALL -- column encryption enclave type
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1589 AS ConfigurationId,          0 AS Value UNION ALL -- tempdb metadata memory-optimized
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1591 AS ConfigurationId,          0 AS Value UNION ALL -- ADR cleaner retry timeout (min)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1592 AS ConfigurationId,          0 AS Value UNION ALL -- ADR Preallocation Factor
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16393 AS ConfigurationId,          0 AS Value UNION ALL -- contained database authentication
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16394 AS ConfigurationId,          0 AS Value UNION ALL -- hadoop connectivity
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16395 AS ConfigurationId,          1 AS Value UNION ALL -- polybase network encryption
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16396 AS ConfigurationId,          0 AS Value UNION ALL -- remote data archive
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16397 AS ConfigurationId,          0 AS Value UNION ALL -- allow polybase export
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16398 AS ConfigurationId,          1 AS Value UNION ALL -- allow filesystem enumeration
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16399 AS ConfigurationId,          0 AS Value UNION ALL -- polybase enabled
			--SQL2017
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         10 AS Value UNION ALL -- remote login timeout (s)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1584 AS ConfigurationId,          0 AS Value UNION ALL -- backup checksum default
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1585 AS ConfigurationId,          0 AS Value UNION ALL -- automatic soft-NUMA disabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1586 AS ConfigurationId,          0 AS Value UNION ALL -- external scripts enabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1587 AS ConfigurationId,          1 AS Value UNION ALL -- clr strict security
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          1 AS Value UNION ALL -- Database Mail XPs
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16393 AS ConfigurationId,          0 AS Value UNION ALL -- contained database authentication
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16394 AS ConfigurationId,          0 AS Value UNION ALL -- hadoop connectivity
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16395 AS ConfigurationId,          1 AS Value UNION ALL -- polybase network encryption
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16396 AS ConfigurationId,          0 AS Value UNION ALL -- remote data archive
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16397 AS ConfigurationId,          0 AS Value UNION ALL -- allow polybase export
			--SQL2016
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         10 AS Value UNION ALL -- remote login timeout (s)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1584 AS ConfigurationId,          0 AS Value UNION ALL -- backup checksum default
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1585 AS ConfigurationId,          0 AS Value UNION ALL -- automatic soft-NUMA disabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1586 AS ConfigurationId,          0 AS Value UNION ALL -- external scripts enabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16393 AS ConfigurationId,          0 AS Value UNION ALL -- contained database authentication
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16394 AS ConfigurationId,          0 AS Value UNION ALL -- hadoop connectivity
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16395 AS ConfigurationId,          1 AS Value UNION ALL -- polybase network encryption
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16396 AS ConfigurationId,          0 AS Value UNION ALL -- remote data archive
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16397 AS ConfigurationId,          0 AS Value UNION ALL -- allow polybase export
			--SQL2014
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         10 AS Value UNION ALL -- remote login timeout (s)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1584 AS ConfigurationId,          0 AS Value UNION ALL -- backup checksum default
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16393 AS ConfigurationId,          0 AS Value UNION ALL -- contained database authentication
			--SQL2012
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         10 AS Value UNION ALL -- remote login timeout (s)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16393 AS ConfigurationId,          0 AS Value UNION ALL -- contained database authentication
			--SQL2008R2
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1519 AS ConfigurationId,         20 AS Value UNION ALL -- remote login timeout (s)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1548 AS ConfigurationId,          0 AS Value UNION ALL -- awe enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1573 AS ConfigurationId,         60 AS Value UNION ALL -- user instance timeout
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1575 AS ConfigurationId,          1 AS Value UNION ALL -- user instances enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16385 AS ConfigurationId,          0 AS Value UNION ALL -- SQL Mail XPs
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			--SQL2008
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         20 AS Value UNION ALL -- remote login timeout (s)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1548 AS ConfigurationId,          0 AS Value UNION ALL -- awe enabled
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold (s)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1578 AS ConfigurationId,          0 AS Value UNION ALL -- EKM provider enabled
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1579 AS ConfigurationId,          0 AS Value UNION ALL -- backup compression default
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1580 AS ConfigurationId,          0 AS Value UNION ALL -- filestream access level
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1581 AS ConfigurationId,          0 AS Value UNION ALL -- optimize for ad hoc workloads
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1582 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache bucket count
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1583 AS ConfigurationId,          0 AS Value UNION ALL -- access check cache quota
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16385 AS ConfigurationId,          0 AS Value UNION ALL -- SQL Mail XPs
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value UNION ALL -- Replication XPs
			--SQL2005
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   101 AS ConfigurationId,          0 AS Value UNION ALL -- recovery interval (min)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   102 AS ConfigurationId,          0 AS Value UNION ALL -- allow updates
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   103 AS ConfigurationId,          0 AS Value UNION ALL -- user connections
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   106 AS ConfigurationId,          0 AS Value UNION ALL -- locks
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   107 AS ConfigurationId,          0 AS Value UNION ALL -- open objects
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   109 AS ConfigurationId,          0 AS Value UNION ALL -- fill factor (%)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   114 AS ConfigurationId,          0 AS Value UNION ALL -- disallow results from triggers
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   115 AS ConfigurationId,          1 AS Value UNION ALL -- nested triggers
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   116 AS ConfigurationId,          1 AS Value UNION ALL -- server trigger recursion
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   117 AS ConfigurationId,          1 AS Value UNION ALL -- remote access
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   124 AS ConfigurationId,          0 AS Value UNION ALL -- default language
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   400 AS ConfigurationId,          0 AS Value UNION ALL -- cross db ownership chaining
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   503 AS ConfigurationId,          0 AS Value UNION ALL -- max worker threads
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   505 AS ConfigurationId,       4096 AS Value UNION ALL -- network packet size (B)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   542 AS ConfigurationId,          0 AS Value UNION ALL -- remote proc trans
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,   544 AS ConfigurationId,          0 AS Value UNION ALL -- c2 audit mode
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1127 AS ConfigurationId,       2049 AS Value UNION ALL -- two digit year cutoff
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1505 AS ConfigurationId,          0 AS Value UNION ALL -- index create memory (KB)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1517 AS ConfigurationId,          0 AS Value UNION ALL -- priority boost
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1519 AS ConfigurationId,         20 AS Value UNION ALL -- remote login timeout (s)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1520 AS ConfigurationId,        600 AS Value UNION ALL -- remote query timeout (s)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1531 AS ConfigurationId,         -1 AS Value UNION ALL -- cursor threshold
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1532 AS ConfigurationId,          0 AS Value UNION ALL -- set working set size
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1534 AS ConfigurationId,          0 AS Value UNION ALL -- user options
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1535 AS ConfigurationId,          0 AS Value UNION ALL -- affinity mask
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1536 AS ConfigurationId,      65536 AS Value UNION ALL -- max text repl size (B)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1537 AS ConfigurationId,          0 AS Value UNION ALL -- media retention
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1538 AS ConfigurationId,          5 AS Value UNION ALL -- cost threshold for parallelism
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1539 AS ConfigurationId,          0 AS Value UNION ALL -- max degree of parallelism
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1540 AS ConfigurationId,       1024 AS Value UNION ALL -- min memory per query (KB)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1541 AS ConfigurationId,         -1 AS Value UNION ALL -- query wait (s)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1543 AS ConfigurationId,          0 AS Value UNION ALL -- min server memory (MB)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1544 AS ConfigurationId, 2147483647 AS Value UNION ALL -- max server memory (MB)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1545 AS ConfigurationId,          0 AS Value UNION ALL -- query governor cost limit
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1546 AS ConfigurationId,          0 AS Value UNION ALL -- lightweight pooling
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1547 AS ConfigurationId,          0 AS Value UNION ALL -- scan for startup procs
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1548 AS ConfigurationId,          0 AS Value UNION ALL -- awe enabled
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1549 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 mask
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1550 AS ConfigurationId,          0 AS Value UNION ALL -- affinity I/O mask
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1551 AS ConfigurationId,          0 AS Value UNION ALL -- affinity64 I/O mask
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1555 AS ConfigurationId,          0 AS Value UNION ALL -- transform noise words
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1556 AS ConfigurationId,          0 AS Value UNION ALL -- precompute rank
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1557 AS ConfigurationId,         60 AS Value UNION ALL -- PH timeout (s)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1562 AS ConfigurationId,          0 AS Value UNION ALL -- clr enabled
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1563 AS ConfigurationId,          4 AS Value UNION ALL -- max full-text crawl range
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1564 AS ConfigurationId,          0 AS Value UNION ALL -- ft notify bandwidth (min)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1565 AS ConfigurationId,        100 AS Value UNION ALL -- ft notify bandwidth (max)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1566 AS ConfigurationId,          0 AS Value UNION ALL -- ft crawl bandwidth (min)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1567 AS ConfigurationId,        100 AS Value UNION ALL -- ft crawl bandwidth (max)
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1568 AS ConfigurationId,          1 AS Value UNION ALL -- default trace enabled
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1569 AS ConfigurationId,          0 AS Value UNION ALL -- blocked process threshold
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1570 AS ConfigurationId,          0 AS Value UNION ALL -- in-doubt xact resolution
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1576 AS ConfigurationId,          0 AS Value UNION ALL -- remote admin connections
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion,  1577 AS ConfigurationId,          0 AS Value UNION ALL -- common criteria compliance enabled
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16385 AS ConfigurationId,          0 AS Value UNION ALL -- SQL Mail XPs
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16386 AS ConfigurationId,          0 AS Value UNION ALL -- Database Mail XPs
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16387 AS ConfigurationId,          1 AS Value UNION ALL -- SMO and DMO XPs
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16388 AS ConfigurationId,          0 AS Value UNION ALL -- Ole Automation Procedures
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16389 AS ConfigurationId,          0 AS Value UNION ALL -- Web Assistant Procedures
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16390 AS ConfigurationId,          0 AS Value UNION ALL -- xp_cmdshell
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16391 AS ConfigurationId,          0 AS Value UNION ALL -- Ad Hoc Distributed Queries
			SELECT  9 AS ProductMajorVersion,  0 AS ProductMinorVersion, 16392 AS ConfigurationId,          0 AS Value -- Replication XPs
		) AS src
		ON (tgt.ProductMajorVersion = src.ProductMajorVersion) AND
			(tgt.ProductMinorVersion = src.ProductMinorVersion) AND
			(tgt.ConfigurationId = src.ConfigurationId)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT (ProductMajorVersion, ProductMinorVersion, ConfigurationId, Value)
				VALUES(src.ProductMajorVersion, src.ProductMinorVersion, src.ConfigurationId, src.Value);
	END;

	--
	-- Create default configuration recommendations
	--
	BEGIN
		MERGE dbo.fhsmInstanceConfigurations AS tgt
		USING (
			--SQL2022
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1585 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--automatic soft-NUMA disabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1584 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup checksum default
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1589 AS ConfigurationId,    0 AS Minimum,      1 AS Maximum UNION ALL	--tempdb metadata memory-optimized
			--SQL2019
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1585 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--automatic soft-NUMA disabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1584 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup checksum default
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1589 AS ConfigurationId,    0 AS Minimum,      1 AS Maximum UNION ALL	--tempdb metadata memory-optimized
			--SQL2017
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1585 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--automatic soft-NUMA disabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1584 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup checksum default
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			--SQL2016
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1585 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--automatic soft-NUMA disabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1584 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup checksum default
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			--SQL2014
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1584 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup checksum default
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			--SQL2012
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			--SQL2008R2
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--remote admin connections
			--SQL2008
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1579 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--backup compression default
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1562 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--clr enabled
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1538 AS ConfigurationId,    6 AS Minimum,  32767 AS Maximum UNION ALL	--cost threshold for parallelism
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1546 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--lightweight pooling
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1539 AS ConfigurationId,    0 AS Minimum,  32767 AS Maximum UNION ALL	--max degree of parallelism
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1544 AS ConfigurationId, 2048 AS Minimum, 524288 AS Maximum UNION ALL	--max server memory (MB)
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1581 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum UNION ALL	--optimize for ad hoc workloads
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1517 AS ConfigurationId,    0 AS Minimum,      0 AS Maximum UNION ALL	--priority boost
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1576 AS ConfigurationId,    1 AS Minimum,      1 AS Maximum				--remote admin connections
		) AS src
		ON (tgt.ProductMajorVersion = src.ProductMajorVersion) AND
			(tgt.ProductMinorVersion = src.ProductMinorVersion) AND
			(tgt.ConfigurationId = src.ConfigurationId)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT (ProductMajorVersion, ProductMinorVersion, ConfigurationId, Minimum, Maximum)
				VALUES(src.ProductMajorVersion, src.ProductMinorVersion, src.ConfigurationId, src.Minimum, src.Maximum);
	END;

	--
	-- Create lifecycle records
	--
	BEGIN
		MERGE dbo.fhsmLifecycle AS tgt
		USING (
			--SQL2022
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2028-jan-11'' AS MainstreamEndDate, ''2033-jan-11'' AS ExtendedEndDate UNION ALL
			--SQL2019
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2025-feb-28'' AS MainstreamEndDate, ''2030-jan-08'' AS ExtendedEndDate UNION ALL
			--SQL2017
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2022-oct-11'' AS MainstreamEndDate, ''2027-oct-12'' AS ExtendedEndDate UNION ALL
			--SQL2016
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2021-jul-13'' AS MainstreamEndDate, ''2026-jul-14'' AS ExtendedEndDate UNION ALL
			--SQL2014
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2019-jul-09'' AS MainstreamEndDate, ''2024-jul-09'' AS ExtendedEndDate UNION ALL
			--SQL2012
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2017-jul-11'' AS MainstreamEndDate, ''2022-jul-12'' AS ExtendedEndDate UNION ALL
			--SQL2008R2
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, ''2014-jul-08'' AS MainstreamEndDate, ''2019-jul-09'' AS ExtendedEndDate UNION ALL
			--SQL2008
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, ''2014-jul-08'' AS MainstreamEndDate, ''2019-jul-09'' AS ExtendedEndDate
		) AS src
		ON (tgt.ProductMajorVersion = src.ProductMajorVersion) AND
			(tgt.ProductMinorVersion = src.ProductMinorVersion)
		WHEN MATCHED AND ((src.MainstreamEndDate <> tgt.MainstreamEndDate) OR (src.ExtendedEndDate <> tgt.ExtendedEndDate))
			THEN UPDATE SET
				tgt.MainstreamEndDate = src.MainstreamEndDate,
				tgt.ExtendedEndDate = src.ExtendedEndDate
		WHEN NOT MATCHED BY TARGET
			THEN INSERT (ProductMajorVersion, ProductMinorVersion, MainstreamEndDate, ExtendedEndDate)
				VALUES(src.ProductMajorVersion, src.ProductMinorVersion, src.MainstreamEndDate, src.ExtendedEndDate);
	END;

	--
	-- Create default trace flag recommendations
	--
	BEGIN
		MERGE dbo.fhsmTraceFlags AS tgt
		USING (
			--SQL2022
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			SELECT 16 AS ProductMajorVersion,  0 AS ProductMinorVersion, 7745 AS TraceFlag, ''Prevents Query Store data from being written to disk in case of a failover or shutdown command'' AS Description
				,''https://bit.ly/2GU69Km'' AS URL UNION ALL
			--SQL2019
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			SELECT 15 AS ProductMajorVersion,  0 AS ProductMinorVersion, 7745 AS TraceFlag, ''Prevents Query Store data from being written to disk in case of a failover or shutdown command'' AS Description
				,''https://bit.ly/2GU69Km'' AS URL UNION ALL
			--SQL2017
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion,  460 AS TraceFlag, ''Improvement: Optional replacement for "String or binary data would be truncated" message with extended information (added in CU12)'' AS Description
				,''https://bit.ly/2sboMli'' AS URL UNION ALL
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 7745 AS TraceFlag, ''Prevents Query Store data from being written to disk in case of a failover or shutdown command'' AS Description
				,''https://bit.ly/2GU69Km'' AS URL UNION ALL
			SELECT 14 AS ProductMajorVersion,  0 AS ProductMinorVersion, 7752 AS TraceFlag, ''Enables asynchronous load of Query Store'' AS Description
				,''https://bit.ly/2GU69Km'' AS URL UNION ALL
			--SQL2016
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion,  460 AS TraceFlag, ''Improvement: Optional replacement for "String or binary data would be truncated" message with extended information (added in SP2 CU6)'' AS Description
				,''https://bit.ly/2sboMli'' AS URL UNION ALL
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 7745 AS TraceFlag, ''Prevents Query Store data from being written to disk in case of a failover or shutdown command'' AS Description
				,''https://bit.ly/2GU69Km'' AS URL UNION ALL
			SELECT 13 AS ProductMajorVersion,  0 AS ProductMinorVersion, 7752 AS TraceFlag, ''Enables asynchronous load of Query Store'' AS Description
				,''https://bit.ly/2GU69Km'' AS URL UNION ALL
			--SQL2014
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1117 AS TraceFlag, ''When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points'' AS Description
				,NULL AS URL UNION ALL
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1118 AS TraceFlag, ''Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, thereby eliminating the contention on SGAM pages'' AS Description
				,NULL AS URL UNION ALL
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 2371 AS TraceFlag, ''Lowers auto update statistics threshold for large tables (on tables with more than 25,000 rows)'' AS Description
				,''https://bit.ly/30KO4Hh'' AS URL UNION ALL
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3449 AS TraceFlag, ''Enables use of dirty page manager (SQL Server 2014 SP1 CU7 and later)'' AS Description
				,''https://bit.ly/2uj0h5M'' AS URL UNION ALL
			SELECT 12 AS ProductMajorVersion,  0 AS ProductMinorVersion, 8079 AS TraceFlag, ''Enables automatic soft-NUMA on systems with eight or more physical cores per NUMA node (with SQL Server 2014 SP2)'' AS Description
				,''https://bit.ly/29B7oR8'' AS URL UNION ALL
			--SQL2012
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1117 AS TraceFlag, ''When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points'' AS Description
				,NULL AS URL UNION ALL
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1118 AS TraceFlag, ''Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, thereby eliminating the contention on SGAM pages'' AS Description
				,NULL AS URL UNION ALL
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 2371 AS TraceFlag, ''Lowers auto update statistics threshold for large tables (on tables with more than 25,000 rows)'' AS Description
				,''https://bit.ly/30KO4Hh'' AS URL UNION ALL
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3023 AS TraceFlag, ''Enables backup checksum default'' AS Description
				,''https://bit.ly/2vtjqqc'' AS URL UNION ALL
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3449 AS TraceFlag, ''Enables use of dirty page manager (SQL Server 2012 SP3 CU3 and later)'' AS Description
				,''https://bit.ly/2uj0h5M'' AS URL UNION ALL
			SELECT 11 AS ProductMajorVersion,  0 AS ProductMinorVersion, 8079 AS TraceFlag, ''Enables automatic soft-NUMA on systems with eight or more physical cores per NUMA node (with SQL Server 2012 SP4)'' AS Description
				,''https://bit.ly/2qN8kr3'' AS URL UNION ALL
			--SQL2008R2
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1117 AS TraceFlag, ''When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points'' AS Description
				,NULL AS URL UNION ALL
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 1118 AS TraceFlag, ''Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, thereby eliminating the contention on SGAM pages'' AS Description
				,NULL AS URL UNION ALL
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 2371 AS TraceFlag, ''Lowers auto update statistics threshold for large tables (on tables with more than 25,000 rows)'' AS Description
				,''https://bit.ly/30KO4Hh'' AS URL UNION ALL
			SELECT 10 AS ProductMajorVersion, 50 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL UNION ALL
			--SQL2008
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1117 AS TraceFlag, ''When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points'' AS Description
				,NULL AS URL UNION ALL
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 1118 AS TraceFlag, ''Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, thereby eliminating the contention on SGAM pages'' AS Description
				,NULL AS URL UNION ALL
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 2371 AS TraceFlag, ''Lowers auto update statistics threshold for large tables (on tables with more than 25,000 rows)'' AS Description
				,''https://bit.ly/30KO4Hh'' AS URL UNION ALL
			SELECT 10 AS ProductMajorVersion,  0 AS ProductMinorVersion, 3226 AS TraceFlag, ''Supresses logging of successful database backup messages to the SQL Server Error Log'' AS Description
				,''https://bit.ly/38zDNAK'' AS URL
		) AS src
		ON (tgt.ProductMajorVersion = src.ProductMajorVersion) AND
			(tgt.ProductMinorVersion = src.ProductMinorVersion) AND
			(tgt.TraceFlag = src.TraceFlag)
		WHEN MATCHED AND (tgt.Description <> src.Description) OR ((tgt.URL <> src.URL) OR (tgt.URL IS NULL AND src.URL IS NOT NULL) OR (tgt.URL IS NOT NULL AND src.URL IS NULL))
			THEN UPDATE SET tgt.Description = src.Description, tgt.URL = src.URL
		WHEN NOT MATCHED BY TARGET
			THEN INSERT (ProductMajorVersion, ProductMinorVersion, TraceFlag, Description, URL)
				VALUES(src.ProductMajorVersion, src.ProductMinorVersion, src.TraceFlag, src.Description, src.URL);
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Agent alerts]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent alerts'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent alerts'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent alerts'') + ''
					AS
						SELECT
							aa.Description
							,aa.MessageId
							,aa.Severity
							,alertsDetected.AlertName
							,CASE WHEN alertsDetected.MessageId IS NULL THEN 0 ELSE 1 END AS AlertExists	-- 0: Warning; 1: OK
							,ROW_NUMBER() OVER(
								ORDER BY
									CASE
										WHEN (alertsDetected.MessageId IS NULL) THEN 1
										ELSE 2
									END
									,aa.Description
							) AS DescriptionSortOrder
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = alertsDetected.AlertName)) AS Timestamp
						FROM dbo.fhsmAgentAlerts AS aa
						LEFT OUTER JOIN (
							SELECT
								pvt.Category AS AlertName
								,CAST(pvt.message_id AS int) AS MessageId
								,CAST(pvt.severity AS int) AS Severity
							FROM (
								SELECT iState.Category, iState.[Key], iState.Value AS _Value_
								FROM (
									SELECT DISTINCT iState.Category
									FROM dbo.fhsmInstanceState AS iState
									WHERE
										(iState.Query = 10)
										AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
								) AS toCheck
								INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
								WHERE (iState.Query = 10) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS p
							PIVOT (
								MAX(_Value_)
								FOR [Key] IN ([message_id], [severity])
							) AS pvt
						) AS alertsDetected ON (alertsDetected.MessageId = aa.MessageId) AND (alertsDetected.Severity = aa.Severity);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Agent alerts]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent alerts'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Agent jobs]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs'') + ''
					AS
						SELECT
							pvt.Category AS JobName
							,CAST(pvt.job_enabled AS bit) AS JobEnabled
							,CAST(pvt.number_of_enabled_schedules AS int) AS NumberOfEnabledSchedules
							,pvt.job_owner AS JobOwner
							,CAST(pvt.notify_email_operator_id AS int) AS NotifyEmailOperatorId
							,CAST(pvt.notify_level_email AS int) AS NotifyLevelEmail
							,ROW_NUMBER() OVER(
								ORDER BY
									CASE
										WHEN (CAST(pvt.job_enabled AS bit) = 1) AND (CAST(pvt.notify_email_operator_id AS int) = 0) THEN 1
										WHEN (CAST(pvt.job_enabled AS bit) = 0) AND (CAST(pvt.notify_email_operator_id AS int) = 0) THEN 2
										ELSE 3
									END
									,pvt.Category
							) AS JobNameSortOrder
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 9)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 9) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([job_enabled], [number_of_enabled_schedules], [job_owner], [notify_email_operator_id], [notify_level_email])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Agent jobs]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Agent jobs'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance configurations]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = '''';
				SET @stmt += ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations'') + ''
					AS
						SELECT
							ic.ConfigurationId
							,ic.Name
							,ic.Value
							,ic.State	-- 0: Warning; 1: OK
							,ic.DefaultValue
							,ic.DefaultState	-- 0: Changed; 1: Default
							,ROW_NUMBER() OVER(
								ORDER BY
									CASE
										WHEN (ic.State = 0) THEN 1
										WHEN (ic.DefaultState = 0) THEN 2
										ELSE 3
									END
									,ic.Name
							) AS NameSortOrder
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = ic.ConfigurationId) AND (iState.[Key] = ''''value'''')) AS Timestamp
						FROM (
							SELECT
								c.ConfigurationId
								,configurationsDetected.name AS Name
								,configurationsDetected.value_in_use AS Value
								,CASE WHEN (configurationsDetected.value_in_use < c.Minimum) OR (configurationsDetected.value_in_use > c.Maximum) THEN 0 ELSE 1 END AS State	-- 0: Warning; 1: OK
								,dc.Value AS DefaultValue
								,CASE WHEN (configurationsDetected.value_in_use <> dc.Value) THEN 0 ELSE 1 END AS DefaultState	-- 0: Changed; 1: Default
							FROM dbo.fhsmInstanceConfigurations AS c
							CROSS APPLY (
								SELECT CAST(iState.Value AS int) AS Value
								FROM dbo.fhsmInstanceState AS iState
								WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS productMajorVersion
							CROSS APPLY (
								SELECT CAST(iState.Value AS int) AS Value
								FROM dbo.fhsmInstanceState AS iState
								WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS productMinorVersion
							INNER JOIN (
								SELECT pvt.Category, pvt.name, CAST(pvt.value AS int) AS value, CAST(pvt.minimum AS int) AS minimum, CAST(pvt.maximum AS int) AS maximum, CAST(pvt.value_in_use AS int) AS value_in_use, pvt.description, pvt.is_dynamic, pvt.is_advanced
								FROM (
									SELECT iState.Category, iState.[Key], iState.Value AS _Value_
									FROM (
										SELECT DISTINCT iState.Category
										FROM dbo.fhsmInstanceState AS iState
										WHERE
											(iState.Query = 4)
											AND (iState.Category IN (1517, 1538, 1539, 1544, 1546, 1562, 1576, 1579, 1581, 1584, 1585, 1589))
											AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
									) AS toCheck
									INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
									WHERE (iState.Query = 4) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
								) AS p
								PIVOT (
									MAX(_Value_)
									FOR [Key] IN ([name], [value], [minimum], [maximum], [value_in_use], [description], [is_dynamic], [is_advanced])
								) AS pvt
							) AS configurationsDetected ON (configurationsDetected.Category = c.ConfigurationId)
							LEFT OUTER JOIN dbo.fhsmDefaultConfigurations AS dc ON (dc.ConfigurationId = configurationsDetected.Category) AND (dc.ProductMajorVersion = productMajorVersion.Value) AND (dc.ProductMinorVersion = productMinorVersion.Value)
							WHERE (c.ProductMajorVersion = productMajorVersion.Value) AND (c.ProductMinorVersion = productMinorVersion.Value)

							UNION
					'';
					SET @stmt += ''
							SELECT
								configurationsDetected.ConfigurationId
								,configurationsDetected.name AS Name
								,configurationsDetected.value_in_use AS Value
								,CASE WHEN (configurationsDetected.value_in_use < rc.Minimum) OR (configurationsDetected.value_in_use > rc.Maximum) THEN 0 ELSE 1 END AS State	-- 0: Warning; 1: OK
								,dc.Value AS DefaultValue
								,CASE WHEN ((configurationsDetected.ConfigurationId = 1543) AND (configurationsDetected.value_in_use <= 16)) THEN 1 ELSE 0 END AS DefaultState	-- 0: Changed; 1: Default
							FROM (
								SELECT pvt.Category AS ConfigurationId, pvt.name, CAST(pvt.value AS int) AS value, CAST(pvt.minimum AS int) AS minimum, CAST(pvt.maximum AS int) AS maximum, CAST(pvt.value_in_use AS int) AS value_in_use, pvt.description, pvt.is_dynamic, pvt.is_advanced
								FROM (
									SELECT iState.Category, iState.[Key], iState.Value AS _Value_
									FROM dbo.fhsmInstanceState AS iState
									WHERE (iState.Query = 4) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
								) AS p
								PIVOT (
									MAX(_Value_)
									FOR [Key] IN ([name], [value], [minimum], [maximum], [value_in_use], [description], [is_dynamic], [is_advanced])
								) AS pvt
							) AS configurationsDetected
							CROSS APPLY (
								SELECT CAST(iState.Value AS int) AS Value
								FROM dbo.fhsmInstanceState AS iState
								WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS productMajorVersion
							CROSS APPLY (
								SELECT CAST(iState.Value AS int) AS Value
								FROM dbo.fhsmInstanceState AS iState
								WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS productMinorVersion
							INNER JOIN dbo.fhsmDefaultConfigurations AS dc ON (dc.ConfigurationId = configurationsDetected.ConfigurationId) AND (dc.ProductMajorVersion = productMajorVersion.Value) AND (dc.ProductMinorVersion = productMinorVersion.Value)
							LEFT OUTER JOIN dbo.fhsmInstanceConfigurations AS rc ON (rc.ConfigurationId = configurationsDetected.ConfigurationId) AND (rc.ProductMajorVersion = productMajorVersion.Value) AND (rc.ProductMinorVersion = productMinorVersion.Value)
							WHERE (dc.Value <> configurationsDetected.value_in_use)
						) AS ic
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance configurations]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance configurations history]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations history'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations history'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = '''';
				SET @stmt += ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations history'') + ''
					AS
						SELECT
							c.ConfigurationId
							,configurationsDetected.ValidFrom
							,configurationsDetected.ValidTo
							,latestName.Value AS Name
							,configurationsDetected.value_in_use AS Value
						FROM dbo.fhsmInstanceConfigurations AS c
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMajorVersion
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMinorVersion
						INNER JOIN (
							SELECT pvt.ValidFrom, pvt.ValidTo, pvt.Category, CAST(pvt.value AS int) AS value, CAST(pvt.value_in_use AS int) AS value_in_use
							FROM (
								SELECT iState.ValidFrom, NULLIF(iState.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo, iState.Category, iState.[Key], iState.Value AS _Value_
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 4)
									AND (iState.Category IN (1517, 1538, 1539, 1544, 1546, 1562, 1576, 1579, 1581, 1584, 1585, 1589))
									AND (iState.[Key] IN (''''value'''', ''''value_in_use''''))
							) AS p
							PIVOT (
								MAX(_Value_)
								FOR [Key] IN ([value], [value_in_use])
							) AS pvt
						) AS configurationsDetected ON (configurationsDetected.Category = c.ConfigurationId)
						INNER JOIN (
							SELECT iState.Category, iState.Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE
								(iState.Query = 4)
								AND (iState.[Key] = ''''name'''')
								AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS latestName ON (latestName.Category = c.ConfigurationId)
						WHERE (c.ProductMajorVersion = productMajorVersion.Value) AND (c.ProductMinorVersion = productMinorVersion.Value)

						UNION
					'';
					SET @stmt += ''
						SELECT
							iState.Category AS ConfigurationId
							,iState.ValidFrom
							,NULLIF(iState.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
							,latestName.Value AS Name
							,iState.Value
						FROM (
							SELECT configurationsDetected.ConfigurationId
							FROM (
								SELECT pvt.Category AS ConfigurationId, pvt.name, CAST(pvt.value AS int) AS value, CAST(pvt.minimum AS int) AS minimum, CAST(pvt.maximum AS int) AS maximum, CAST(pvt.value_in_use AS int) AS value_in_use, pvt.description, pvt.is_dynamic, pvt.is_advanced
								FROM (
									SELECT iState.Category, iState.[Key], iState.Value AS _Value_
									FROM dbo.fhsmInstanceState AS iState
									WHERE (iState.Query = 4) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
								) AS p
								PIVOT (
									MAX(_Value_)
									FOR [Key] IN ([name], [value], [minimum], [maximum], [value_in_use], [description], [is_dynamic], [is_advanced])
								) AS pvt
							) AS configurationsDetected
							CROSS APPLY (
								SELECT CAST(iState.Value AS int) AS Value
								FROM dbo.fhsmInstanceState AS iState
								WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS productMajorVersion
							CROSS APPLY (
								SELECT CAST(iState.Value AS int) AS Value
								FROM dbo.fhsmInstanceState AS iState
								WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS productMinorVersion
							INNER JOIN dbo.fhsmDefaultConfigurations AS dc ON (dc.ConfigurationId = configurationsDetected.ConfigurationId) AND (dc.ProductMajorVersion = productMajorVersion.Value) AND (dc.ProductMinorVersion = productMinorVersion.Value)
							LEFT OUTER JOIN dbo.fhsmInstanceConfigurations AS rc ON (rc.ConfigurationId = configurationsDetected.ConfigurationId) AND (rc.ProductMajorVersion = productMajorVersion.Value) AND (rc.ProductMinorVersion = productMinorVersion.Value)
							WHERE (dc.Value <> configurationsDetected.value_in_use)
						) AS notDefault
						INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = notDefault.ConfigurationId)
						INNER JOIN (
							SELECT iState.Category, iState.Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE
								(iState.Query = 4)
								AND (iState.[Key] = ''''name'''')
								AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS latestName ON (latestName.Category = iState.Category)
						WHERE (iState.[Key] = ''''value_in_use'''')
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance configurations history]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance configurations history'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance dump files]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance dump files'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance dump files'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance dump files'') + ''
					AS
						SELECT
							pvt.Category AS Sequence
							,CAST(CAST(pvt.creation_time AS datetime2(0)) AS datetime) AS CreationTime
							,pvt.filename AS Filename
							,CAST(pvt.size_in_bytes AS int) AS SizeInBytes
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 21) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([creation_time], [filename], [size_in_bytes])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance dump files]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance dump files'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance hardware]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware'') + ''
					AS
						SELECT
							CASE iState.[Key]
								WHEN ''''cores_per_socket'''' THEN ''''Cores per socket''''
								WHEN ''''cpu_count'''' THEN ''''CPU count''''
								WHEN ''''max_workers_count'''' THEN ''''Max workers count''''
								WHEN ''''numa_node_count'''' THEN ''''NUMA node count''''
								WHEN ''''physical_memory_kb'''' THEN ''''Physical memory MB''''
								WHEN ''''ProcessorNameString'''' THEN ''''Processor''''
								WHEN ''''scheduler_count'''' THEN ''''Scheduler count''''
								WHEN ''''socket_count'''' THEN ''''Socket count''''
								WHEN ''''sql_memory_model'''' THEN ''''SQL memory model''''
								WHEN ''''SQL Server and OS Version Info'''' THEN ''''SQL Server and OS Version Info''''
								WHEN ''''sqlserver_start_time'''' THEN ''''SQL server start time''''
								WHEN ''''virtual_machine_type'''' THEN ''''Virtual machine type''''
								ELSE ''''?:'''' + iState.[Key]
							END AS [Key]
							,CASE iState.[Key]
								WHEN ''''physical_memory_kb'''' THEN CAST((CAST(iState.Value AS int) / 1024) AS nvarchar(max))
								WHEN ''''sql_memory_model'''' THEN
									CASE iState.Value
										WHEN 1 THEN ''''CONVENTIONAL''''
										WHEN 2 THEN ''''LOCK_PAGES''''
										WHEN 3 THEN ''''LARGE_PAGES''''
										ELSE ''''?:'''' + CAST(iState.Value AS nvarchar)
									END
								WHEN ''''sqlserver_start_time'''' THEN CONVERT(nvarchar(max), CAST(iState.Value AS datetime), 126)
								WHEN ''''virtual_machine_type'''' THEN
									CASE iState.Value
										WHEN 0 THEN ''''NONE''''
										WHEN 1 THEN ''''HYPERVISOR''''
										WHEN 2 THEN ''''OTHER''''
										ELSE ''''?:'''' + CAST(iState.Value AS nvarchar)
									END
								ELSE iState.Value
							END AS Value
							,iState.Timestamp
						FROM (
							SELECT iState.[Key], iState.Value, iState.Timestamp
							FROM dbo.fhsmInstanceState AS iState
							WHERE
								(
									(
										(iState.Query = 1)
										AND (iState.[Key] = ''''SQL Server and OS Version Info'''')
									)
									OR (
										(iState.Query = 17)
										AND (iState.[Key] IN (
											''''cores_per_socket''''
											,''''cpu_count''''
											,''''max_workers_count''''
											,''''numa_node_count''''
											,''''physical_memory_kb''''
											,''''scheduler_count''''
											,''''socket_count''''
											,''''sql_memory_model''''
											,''''sqlserver_start_time''''
											,''''virtual_machine_type''''
										))
									)
									OR (
										(iState.Query = 20)
									)
								)
								AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS iState;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance hardware]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance hardware history]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware history'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware history'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware history'') + ''
					AS
						SELECT
							CASE iState.[Key]
								WHEN ''''cores_per_socket'''' THEN ''''Cores per socket''''
								WHEN ''''cpu_count'''' THEN ''''CPU count''''
								WHEN ''''max_workers_count'''' THEN ''''Max workers count''''
								WHEN ''''numa_node_count'''' THEN ''''NUMA node count''''
								WHEN ''''physical_memory_kb'''' THEN ''''Physical memory MB''''
								WHEN ''''ProcessorNameString'''' THEN ''''Processor''''
								WHEN ''''scheduler_count'''' THEN ''''Scheduler count''''
								WHEN ''''socket_count'''' THEN ''''Socket count''''
								WHEN ''''sql_memory_model'''' THEN ''''SQL memory model''''
								WHEN ''''SQL Server and OS Version Info'''' THEN ''''SQL Server and OS Version Info''''
								WHEN ''''sqlserver_start_time'''' THEN ''''SQL server start time''''
								WHEN ''''virtual_machine_type'''' THEN ''''Virtual machine type''''
								ELSE ''''?:'''' + iState.[Key]
							END AS [Key]
							,iState.ValidFrom
							,NULLIF(iState.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
							,CASE iState.[Key]
								WHEN ''''physical_memory_kb'''' THEN CAST((CAST(iState.Value AS int) / 1024) AS nvarchar(max))
								WHEN ''''sql_memory_model'''' THEN
									CASE iState.Value
										WHEN 1 THEN ''''CONVENTIONAL''''
										WHEN 2 THEN ''''LOCK_PAGES''''
										WHEN 3 THEN ''''LARGE_PAGES''''
										ELSE ''''?:'''' + CAST(iState.Value AS nvarchar)
									END
								WHEN ''''sqlserver_start_time'''' THEN CONVERT(nvarchar(max), CAST(iState.Value AS datetime), 126)
								WHEN ''''virtual_machine_type'''' THEN
									CASE iState.Value
										WHEN 0 THEN ''''NONE''''
										WHEN 1 THEN ''''HYPERVISOR''''
										WHEN 2 THEN ''''OTHER''''
										ELSE ''''?:'''' + CAST(iState.Value AS nvarchar)
									END
								ELSE iState.Value
							END AS Value
						FROM (
							SELECT iState.ValidFrom, iState.ValidTo, iState.[Key], iState.Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE
								(
									(
										(iState.Query = 1)
										AND (iState.[Key] IN (
											''''SQL Server and OS Version Info''''
										))
									)
									OR (
										(iState.Query = 17)
										AND (iState.[Key] IN (
											''''cores_per_socket''''
											,''''cpu_count''''
											,''''max_workers_count''''
											,''''numa_node_count''''
											,''''physical_memory_kb''''
											,''''scheduler_count''''
											,''''socket_count''''
											,''''sql_memory_model''''
											,''''sqlserver_start_time''''
											,''''virtual_machine_type''''
										))
									)
									OR (
										(iState.Query = 20)
									)
								)
						) AS iState;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance hardware history]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance hardware history'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance services]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance services'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance services'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance services'') + ''
					AS
						SELECT
							pvt.Category AS Name
							,CASE pvt.startup_type
								WHEN 0 THEN ''''Other''''
								WHEN 1 THEN ''''Other''''
								WHEN 2 THEN ''''Automatic''''
								WHEN 3 THEN ''''Manual''''
								WHEN 4 THEN ''''Disabled''''
								ELSE ''''?:'''' + CAST(pvt.startup_type AS nvarchar)
							END AS StartupType
							,CASE pvt.status
								WHEN 1 THEN ''''Stopped''''
								WHEN 2 THEN ''''Other (start pending)''''
								WHEN 3 THEN ''''Other (stop pending)''''
								WHEN 4 THEN ''''Running''''
								WHEN 5 THEN ''''Other (continue pending)''''
								WHEN 6 THEN ''''Other (pause pending)''''
								WHEN 7 THEN ''''Paused''''
								ELSE ''''?:'''' + CAST(pvt.status AS nvarchar)
							END AS Status
							,pvt.service_account AS ServiceAccount
							,CASE pvt.instant_file_initialization_enabled WHEN ''''Y'''' THEN 1 WHEN ''''N'''' THEN 0 ELSE -1 END AS InstantFileInitializationEnabled
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.[Key] NOT IN (''''filename'''', ''''is_clustered'''', ''''last_startup_time'''', ''''process_id''''))) AS Timestamp

						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 7)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 7) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([startup_type], [status], [service_account], [instant_file_initialization_enabled])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance services]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance services'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance suspect pages]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance suspect pages'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance suspect pages'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance suspect pages'') + ''
					AS
						SELECT
							SUBSTRING(pvt.Category, 1, CHARINDEX('''':'''', pvt.Category) - 1) AS DatabaseName
							,CAST(SUBSTRING(pvt.Category, CHARINDEX('''':'''', pvt.Category) + 1, LEN(pvt.Category) - CHARINDEX('''':'''', REVERSE(pvt.Category)) - (CHARINDEX('''':'''', pvt.Category))) AS int) AS FileId
							,CAST(SUBSTRING(pvt.Category, LEN(pvt.Category) - CHARINDEX('''':'''', REVERSE(pvt.Category)) + 2, LEN(pvt.Category)) AS bigint) AS PageId
							,CASE pvt.event_type
								WHEN 1 THEN ''''An 823 error that causes a suspect page (such as a disk error) or an 824 error other than a bad checksum or a torn page (such as a bad page ID)''''
								WHEN 2 THEN ''''Bad checksum''''
								WHEN 3 THEN ''''Torn page''''
								WHEN 4 THEN ''''Restored (page was restored after it was marked bad)''''
								WHEN 5 THEN ''''Repaired (DBCC repaired the page)''''
								WHEN 7 THEN ''''Deallocated by DBCC''''
								ELSE ''''?:'''' + CAST(pvt.event_type AS nvarchar)
							END AS EventType
							,CAST(pvt.error_count AS int) AS ErrorCount
							,CAST(pvt.last_update_date AS datetime) AS LastUpdateDate
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 22) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([event_type], [error_count], [last_update_date])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance suspect pages]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance suspect pages'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance SQL agent properties]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties'') + ''
					AS
						SELECT
							CASE iState.[Key]
								WHEN ''''idle_cpu_duration'''' THEN ''''Idle CPU duration''''
								WHEN ''''idle_cpu_percent'''' THEN ''''Idle CPU percent''''
								WHEN ''''jobhistory_max_rows'''' THEN ''''Job history max rows''''
								WHEN ''''jobhistory_max_rows_per_job'''' THEN ''''Job history max rows per job''''
								WHEN ''''job_shutdown_timeout'''' THEN ''''Job shutdown timeout''''
							END AS [Key]
							,iState.Value
							,iState.Timestamp
						FROM (
							SELECT iState.[Key], iState.Value, iState.Timestamp
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 29) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
								AND (iState.[Key] IN (
									''''idle_cpu_duration''''
									,''''idle_cpu_percent''''
									,''''jobhistory_max_rows''''
									,''''jobhistory_max_rows_per_job''''
									,''''job_shutdown_timeout''''
								))
						) AS iState;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance SQL agent properties]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Instance SQL agent properties history]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties history'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties history'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties history'') + ''
					AS
						SELECT
							CASE iState.[Key]
								WHEN ''''idle_cpu_duration'''' THEN ''''Idle CPU duration''''
								WHEN ''''idle_cpu_percent'''' THEN ''''Idle CPU percent''''
								WHEN ''''jobhistory_max_rows'''' THEN ''''Job history max rows''''
								WHEN ''''jobhistory_max_rows_per_job'''' THEN ''''Job history max rows per job''''
								WHEN ''''job_shutdown_timeout'''' THEN ''''Job shutdown timeout''''
							END AS [Key]
							,iState.ValidFrom
							,NULLIF(iState.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
							,iState.Value
						FROM (
							SELECT iState.ValidFrom, iState.ValidTo, iState.[Key], iState.Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 29)
								AND (iState.[Key] IN (
									''''idle_cpu_duration''''
									,''''idle_cpu_percent''''
									,''''jobhistory_max_rows''''
									,''''jobhistory_max_rows_per_job''''
									,''''job_shutdown_timeout''''
								))
						) AS iState;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Instance SQL agent properties history]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Instance SQL agent properties history'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Lifecycle]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Lifecycle'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Lifecycle'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Lifecycle'') + ''
					AS
						SELECT
							l.MainstreamEndDate
							,l.ExtendedEndDate
							,CASE
								WHEN (CAST(GETDATE() AS date) <= l.MainstreamEndDate) THEN 0
								WHEN (CAST(GETDATE() AS date) > l.MainstreamEndDate) AND (CAST(GETDATE() AS date) <= l.ExtendedEndDate) THEN 1
								ELSE 2
							END AS State	-- 0: Until mainstream end date
											-- 1: After mainstream end date and until extended end date
											-- 2: After extended end date
						FROM dbo.fhsmLifecycle AS l
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMajorVersion
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMinorVersion
						WHERE (l.ProductMajorVersion = productMajorVersion.Value) AND (l.ProductMinorVersion = productMinorVersion.Value);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Lifecycle]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Lifecycle'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Trace flags]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags'') + ''
					AS
						SELECT
							tf.TraceFlag
							,tf.Description
							,tf.URL
							,CASE WHEN traceFlagsDetected.TraceFlag IS NULL THEN 0 ELSE 1 END AS TraceFlagExists	-- 0: Warning; 1: OK
							,traceFlagsDetected.Timestamp
						FROM dbo.fhsmTraceFlags AS tf
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMajorVersion
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMinorVersion
						LEFT OUTER JOIN (
							SELECT CAST(iState.Category AS int) AS TraceFlag, iState.Timestamp
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 5) AND (iState.[Key] = ''''Global'''') AND (dbo.fhsmFNTryParseAsInt(iState.Value) = 1) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS traceFlagsDetected ON (traceFlagsDetected.TraceFlag = tf.TraceFlag)
						WHERE (tf.ProductMajorVersion = productMajorVersion.Value) AND (tf.ProductMinorVersion = productMinorVersion.Value);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Trace flags]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Trace flags history]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags history'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags history'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags history'') + ''
					AS
						SELECT
							tf.TraceFlag
							,CAST(tf.TraceFlag AS nvarchar) AS TraceFlagTxt
							,tf.Description
							,traceFlags.ValidFrom
							,NULLIF(traceFlags.ValidTo, ''''9999-12-31 23:59:59.000'''') AS ValidTo
						FROM dbo.fhsmTraceFlags AS tf
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMajorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMajorVersion
						CROSS APPLY (
							SELECT CAST(iState.Value AS int) AS Value
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 3) AND (iState.[Key] = ''''ProductMinorVersion'''') AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS productMinorVersion
						INNER JOIN (
							SELECT iState.ValidFrom, iState.ValidTo, CAST(iState.Category AS int) AS TraceFlag
							FROM dbo.fhsmInstanceState AS iState
							WHERE (iState.Query = 5) AND (iState.[Key] = ''''Global'''') AND (dbo.fhsmFNTryParseAsInt(iState.Value) = 1)
						) AS traceFlags ON (traceFlags.TraceFlag = tf.TraceFlag)
						WHERE (tf.ProductMajorVersion = productMajorVersion.Value) AND (tf.ProductMinorVersion = productMinorVersion.Value);
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Trace flags history]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Trace flags history'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Resource governor configuration]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor configuration'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor configuration'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor configuration'') + ''
					AS
						SELECT
							pvt.is_enabled AS IsEnabled
							,pvt.max_outstanding_io_per_volume AS MaxOutstandingIOperVolume
							,pvt.ClassifierFunction
							,pvt.ClassifierFunctionDefinition
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.Query = 23)) AS Timestamp
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 23)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 23) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([is_enabled], [max_outstanding_io_per_volume], [ClassifierFunction], [ClassifierFunctionDefinition])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Resource governor configuration]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor configuration'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Resource governor resource pool affinity]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pool affinity'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pool affinity'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pool affinity'') + ''
					AS
						SELECT
							pvt.Category AS PoolName
							,pvt.processor_group AS ProcessorGroup
							,pvt.scheduler_mask AS SchedulerMask
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.Query = 24)) AS Timestamp
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 24)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 24) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([processor_group], [scheduler_mask])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Resource governor resource pool affinity]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pool affinity'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Resource governor resource pools]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pools'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pools'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pools'') + ''
					AS
						SELECT
							pvt.Category AS PoolName
							,pvt.min_cpu_percent AS MinCPUpercent
							,pvt.max_cpu_percent AS MaxCPUpercent
							,pvt.min_memory_percent AS MinMemoryPercent
							,pvt.max_memory_percent AS MaxMemoryPercent
							,pvt.cap_cpu_percent AS CapCPUpercent
							,pvt.min_iops_per_volume AS MinIOPSperVolume
							,pvt.max_iops_per_volume AS MaxIOPSperVolume
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.Query = 25)) AS Timestamp
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 25)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 25) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([min_cpu_percent], [max_cpu_percent], [min_memory_percent], [max_memory_percent], [cap_cpu_percent], [min_iops_per_volume], [max_iops_per_volume])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Resource governor resource pools]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor resource pools'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Resource governor workload groups]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor workload groups'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor workload groups'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor workload groups'') + ''
					AS
						SELECT
							PARSENAME(pvt.Category, 2) AS PoolName
							,PARSENAME(pvt.Category, 1) AS WorkloadGroupName
							,pvt.importance AS Importance
							,pvt.request_max_memory_grant_percent AS RequestMaxMemoryGrantPercent
							,pvt.request_max_cpu_time_sec AS RequestMaxCPUtimeSec
							,pvt.request_memory_grant_timeout_sec AS RequestMemoryGrantTimeoutSec
							,pvt.max_dop AS MaxDOP
							,pvt.group_max_requests AS GroupMaxRequests
							,pvt.request_max_memory_grant_percent_numeric AS RequestMaxMemoryGrantPercentNumeric
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.Query = 26)) AS Timestamp
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 26)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 26) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([importance], [request_max_memory_grant_percent], [request_max_cpu_time_sec], [request_memory_grant_timeout_sec], [max_dop], [group_max_requests], [request_max_memory_grant_percent_numeric])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Resource governor workload groups]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor workload groups'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Resource governor external resource pool affinity]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pool affinity'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pool affinity'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pool affinity'') + ''
					AS
						SELECT
							pvt.Category AS PoolName
							,pvt.processor_group AS ProcessorGroup
							,pvt.cpu_mask AS CPUmask
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.Query = 27)) AS Timestamp
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 27)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 27) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([processor_group], [cpu_mask])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Resource governor external resource pool affinity]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pool affinity'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create fact view @pbiSchema.[Resource governor external resource pools]
		--
		BEGIN
			BEGIN
				SET @stmt = ''
					IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pools'') + '''''', ''''V'''') IS NULL
					BEGIN
						EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pools'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
					END;
				'';
				EXEC(@stmt);

				SET @stmt = ''
					ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pools'') + ''
					AS
						SELECT
							pvt.Category AS PoolName
							,pvt.max_cpu_percent AS MaxCPUpercent
							,pvt.max_memory_percent AS MaxMemoryPercent
							,pvt.max_processes AS MaxProcesses
							,pvt.version AS Version
							,(SELECT MAX(iState.Timestamp) FROM dbo.fhsmInstanceState AS iState WHERE (iState.Category = pvt.Category) AND (iState.Query = 28)) AS Timestamp
						FROM (
							SELECT iState.Category, iState.[Key], iState.Value AS _Value_
							FROM (
								SELECT DISTINCT iState.Category
								FROM dbo.fhsmInstanceState AS iState
								WHERE
									(iState.Query = 28)
									AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
							) AS toCheck
							INNER JOIN dbo.fhsmInstanceState AS iState ON (iState.Category = toCheck.Category)
							WHERE (iState.Query = 28) AND (iState.ValidTo = ''''9999-12-31 23:59:59.000'''')
						) AS p
						PIVOT (
							MAX(_Value_)
							FOR [Key] IN ([max_cpu_percent], [max_memory_percent], [max_processes], [version])
						) AS pvt;
				'';
				EXEC(@stmt);
			END;

			--
			-- Register extended properties on fact view @pbiSchema.[Resource governor external resource pools]
			--
			BEGIN
				SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Resource governor external resource pools'');
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPInstanceState
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPInstanceState'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPInstanceState AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPInstanceState (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--******************************************************************************
					--*   Copyright (C) 2020 Glenn Berry
					--*   All rights reserved. 
					--*
					--*
					--*   You may alter this code for your own *non-commercial* purposes. You may
					--*   republish altered code as long as you include this copyright and give due credit. 
					--*
					--*
					--*   THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
					--*   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
					--*   TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
					--*   PARTICULAR PURPOSE. 
					--*
					--******************************************************************************

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						IF (OBJECT_ID(''''tempdb..#inventory'''') IS NOT NULL) DROP TABLE #inventory;

						CREATE TABLE #inventory(
							Query int NOT NULL
							,Category nvarchar(128) NOT NULL
							,[Key] nvarchar(128) NOT NULL
							,Value nvarchar(max) NULL
							,PRIMARY KEY(Query, Category, [Key])
						);

						DECLARE @xpReadErrorLog TABLE(LogDate datetime, ProcessorInfo nvarchar(128), Text nvarchar(max));
						DECLARE @xpReadReg TABLE(Value nvarchar(128), Data nvarchar(max));

						--
						-- SQL and OS Version information for current instance  (Query 1) (Version Info)
						--
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 1 AS Query, '''''''' AS Category, ''''Server Name''''                    AS K, @@SERVERNAME AS V UNION ALL
							SELECT 1 AS Query, '''''''' AS Category, ''''SQL Server and OS Version Info'''' AS K, @@VERSION    AS V;
						END;

						--
						-- Get socket, physical core and logical core count from the SQL Server Error log. (Query 2) (Core Counts)
						--
						BEGIN
							DELETE @xpReadErrorLog;
							INSERT INTO @xpReadErrorLog
							EXEC sys.xp_readerrorlog 0, 1, N''''detected'''', N''''socket'''';
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 2 AS Query, '''''''' AS Category, ''''LogDate''''       AS K, CONVERT(nvarchar(max), q.LogDate, 126) AS V FROM @xpReadErrorLog AS q UNION ALL
							SELECT 2 AS Query, '''''''' AS Category, ''''ProcessorInfo'''' AS K, q.ProcessorInfo                        AS V FROM @xpReadErrorLog AS q UNION ALL
							SELECT 2 AS Query, '''''''' AS Category, ''''Text''''          AS K, q.Text                                 AS V FROM @xpReadErrorLog AS q;
						END;

						--
						-- Get selected server properties (Query 3) (Server Properties)
						--
						BEGIN
                            WITH
							productVersion AS (SELECT CAST(SERVERPROPERTY(''''ProductVersion'''') AS nvarchar(max)) AS Str),
							productVersionP1 AS (SELECT t.Txt AS Str FROM dbo.fhsmFNSplitString((SELECT a.Str FROM productVersion AS a), ''''.'''') AS t WHERE (t.Part = 1)),
							productVersionP2 AS (SELECT t.Txt AS Str FROM dbo.fhsmFNSplitString((SELECT a.Str FROM productVersion AS a), ''''.'''') AS t WHERE (t.Part = 2)),
							productVersionP3 AS (SELECT t.Txt AS Str FROM dbo.fhsmFNSplitString((SELECT a.Str FROM productVersion AS a), ''''.'''') AS t WHERE (t.Part = 3))
							INSERT INTO #inventory(Query, Category, [Key], Value)
                            SELECT 3 AS Query, '''''''' AS Category, ''''MachineName''''                     AS K, CAST(SERVERPROPERTY(''''MachineName'''') AS nvarchar(max))                     AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ServerName''''                      AS K, CAST(SERVERPROPERTY(''''ServerName'''') AS nvarchar(max))                      AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''InstanceName''''                    AS K, CAST(SERVERPROPERTY(''''InstanceName'''') AS nvarchar(max))                    AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsClustered''''                     AS K, CAST(SERVERPROPERTY(''''IsClustered'''') AS nvarchar(max))                     AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ComputerNamePhysicalNetBIOS''''     AS K, CAST(SERVERPROPERTY(''''ComputerNamePhysicalNetBIOS'''') AS nvarchar(max))     AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''Edition''''                         AS K, CAST(SERVERPROPERTY(''''Edition'''') AS nvarchar(max))                         AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductLevel''''                    AS K, CAST(SERVERPROPERTY(''''ProductLevel'''') AS nvarchar(max))                    AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductUpdateLevel''''              AS K, CAST(SERVERPROPERTY(''''ProductUpdateLevel'''') AS nvarchar(max))              AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductVersion''''                  AS K, (SELECT t.Str FROM productVersion   AS t)                                  AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductMajorVersion''''             AS K, (SELECT t.Str FROM productVersionP1 AS t)                                  AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductMinorVersion''''             AS K, (SELECT t.Str FROM productVersionP2 AS t)                                  AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductBuild''''                    AS K, (SELECT t.Str FROM productVersionP3 AS t)                                  AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductBuildType''''                AS K, CAST(SERVERPROPERTY(''''ProductBuildType'''') AS nvarchar(max))                AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProductUpdateReference''''          AS K, CAST(SERVERPROPERTY(''''ProductUpdateReference'''') AS nvarchar(max))          AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''ProcessID''''                       AS K, CAST(SERVERPROPERTY(''''ProcessID'''') AS nvarchar(max))                       AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''Collation''''                       AS K, CAST(SERVERPROPERTY(''''Collation'''') AS nvarchar(max))                       AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsFullTextInstalled''''             AS K, CAST(SERVERPROPERTY(''''IsFullTextInstalled'''') AS nvarchar(max))             AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsIntegratedSecurityOnly''''        AS K, CAST(SERVERPROPERTY(''''IsIntegratedSecurityOnly'''') AS nvarchar(max))        AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''FilestreamConfiguredLevel''''       AS K, CAST(SERVERPROPERTY(''''FilestreamConfiguredLevel'''') AS nvarchar(max))       AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsHadrEnabled''''                   AS K, CAST(SERVERPROPERTY(''''IsHadrEnabled'''') AS nvarchar(max))                   AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''HadrManagerStatus''''               AS K, CAST(SERVERPROPERTY(''''HadrManagerStatus'''') AS nvarchar(max))               AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''InstanceDefaultDataPath''''         AS K, CAST(SERVERPROPERTY(''''InstanceDefaultDataPath'''') AS nvarchar(max))         AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''InstanceDefaultLogPath''''          AS K, CAST(SERVERPROPERTY(''''InstanceDefaultLogPath'''') AS nvarchar(max))          AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''BuildClrVersion''''                 AS K, CAST(SERVERPROPERTY(''''BuildClrVersion'''') AS nvarchar(max))                 AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsXTPSupported''''                  AS K, CAST(SERVERPROPERTY(''''IsXTPSupported'''') AS nvarchar(max))                  AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsPolybaseInstalled''''             AS K, CAST(SERVERPROPERTY(''''IsPolybaseInstalled'''') AS nvarchar(max))             AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsAdvancedAnalyticsInstalled''''    AS K, CAST(SERVERPROPERTY(''''IsAdvancedAnalyticsInstalled'''') AS nvarchar(max))    AS V UNION ALL
                            SELECT 3 AS Query, '''''''' AS Category, ''''IsTempdbMetadataMemoryOptimized'''' AS K, CAST(SERVERPROPERTY(''''IsTempdbMetadataMemoryOptimized'''') AS nvarchar(max)) AS V;
						END;

						--
						-- Get instance-level configuration values for instance  (Query 4) (Configuration Values)
						--
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 4 AS Query, unpvt.configuration_id AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									configuration_id
									,CAST(c.name COLLATE DATABASE_DEFAULT                               AS nvarchar(max)) AS name
									,CAST(c.value                                                       AS nvarchar(max)) AS value
									,CAST(c.value_in_use                                                AS nvarchar(max)) AS value_in_use
									,CAST(c.minimum                                                     AS nvarchar(max)) AS minimum
									,CAST(c.maximum                                                     AS nvarchar(max)) AS maximum
									,CAST(CAST(c.description AS nvarchar(max)) COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS description
									,CAST(c.is_dynamic                                                  AS nvarchar(max)) AS is_dynamic
									,CAST(c.is_advanced                                                 AS nvarchar(max)) AS is_advanced
								FROM sys.configurations AS c WITH (NOLOCK)
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.name
									,p.value
									,p.value_in_use
									,p.minimum
									,p.maximum
									,p.description
									,p.is_dynamic
									,p.is_advanced
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Returns a list of all global trace flags that are enabled (Query 5) (Global Trace Flags)
						--
						BEGIN
							DECLARE @tracestatus TABLE(TraceFlag nvarchar(40), Status tinyint, Global tinyint, Session tinyint);
							INSERT INTO @tracestatus 
							EXEC(''''dbcc tracestatus'''');
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 5 AS Query, unpvt.TraceFlag AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									t.TraceFlag
									,t.Status
									,t.Global
									,t.Session
								FROM @tracestatus AS t
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.Status
									,p.Global
									,p.Session
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- SQL Server Services information (Query 7) (SQL Server Services Info)
						--
						IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''''dm_server_services''''))
						BEGIN
							--
							-- Test if instant_file_initialization_enabled exists on dm_server_services
							--
							BEGIN
								DECLARE @instantFileInitializationEnabledStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_server_services'''') AND (sc.name = ''''instant_file_initialization_enabled'''')
								)
								BEGIN
									SET @instantFileInitializationEnabledStmt = ''''dss.instant_file_initialization_enabled'''';
								END
								ELSE BEGIN
									SET @instantFileInitializationEnabledStmt = ''''CAST(NULL AS nvarchar(1))'''';
								END;
							END;

							SET @stmt = ''''
								INSERT INTO #inventory(Query, Category, [Key], Value)
								SELECT 7 AS Query, unpvt.servicename AS Category, unpvt.K, unpvt.V
								FROM (
									SELECT
										dss.servicename
										,CAST(dss.startup_type                                                 AS nvarchar(max)) AS startup_type
										,CAST(dss.status                                                       AS nvarchar(max)) AS status
										,CAST(dss.process_id                                                   AS nvarchar(max)) AS process_id
										,CONVERT(nvarchar(max), dss.last_startup_time, 126)                                      AS last_startup_time
										,CAST(dss.service_account                     COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS service_account
										,CAST(dss.filename                            COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS filename
										,CAST(dss.is_clustered                        COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS is_clustered
										,CAST(dss.cluster_nodename                    COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS cluster_nodename
										,CAST('''' + @instantFileInitializationEnabledStmt + '''' COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS instant_file_initialization_enabled
									FROM sys.dm_server_services AS dss WITH (NOLOCK)
								) AS p
								UNPIVOT(
									V FOR K IN (
										p.startup_type
										,p.status
										,p.process_id
										,p.last_startup_time
										,p.service_account
										,p.filename
										,p.is_clustered
										,p.cluster_nodename
										,p.instant_file_initialization_enabled
									)
								) AS unpvt OPTION (RECOMPILE);
							'''';
							EXEC(@stmt);
						END;

						--
						-- Get SQL Server Agent jobs and Category information (Query 9) (SQL Server Agent Jobs)
						--
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 9 AS Query, unpvt.job_name AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									sj.name AS job_name
									,CAST(sj.enabled                              AS nvarchar(max)) AS job_enabled
									,CAST(sj.description COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS description
									,CAST(SUSER_SNAME(sj.owner_sid)               AS nvarchar(max)) AS job_owner
									,CAST(sj.notify_level_email                   AS nvarchar(max)) AS notify_level_email
									,CAST(sj.notify_email_operator_id             AS nvarchar(max)) AS notify_email_operator_id
									,CONVERT(nvarchar(max), sj.date_created, 126)                   AS date_created
									,CAST(sc.name COLLATE DATABASE_DEFAULT        AS nvarchar(max)) AS category_name
									,(
										SELECT CAST(SUM(enabledSchedules.Cnt) AS nvarchar(max)) FROM (
											SELECT 1 AS Cnt
											FROM msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
											INNER JOIN msdb.dbo.sysschedules AS s WITH (NOLOCK) ON (js.schedule_id = s.schedule_id)
											WHERE (js.job_id = sj.job_id) AND (s.enabled = 1)
										) AS enabledSchedules
									) AS number_of_enabled_schedules
								FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
								INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK) ON (sj.category_id = sc.category_id)
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.job_enabled
									,p.description
									,p.job_owner
									,p.notify_level_email
									,p.notify_email_operator_id
									,p.date_created
									,p.category_name
									,p.number_of_enabled_schedules
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Get SQL Server Agent Alert Information (Query 10) (SQL Server Agent Alerts)
						--
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 10 AS Query, unpvt.name AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									 CAST(sa.name                                  AS nvarchar(max)) AS name
									,CAST(sa.message_id                            AS nvarchar(max)) AS message_id
									,CAST(sa.event_source COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS event_source
									,CAST(sa.severity                              AS nvarchar(max)) AS severity
									,CAST(sa.enabled                               AS nvarchar(max)) AS enabled
									,CAST(sa.delay_between_responses               AS nvarchar(max)) AS delay_between_responses
									,CAST(sa.last_occurrence_date                  AS nvarchar(max)) AS last_occurrence_date
									,CAST(sa.last_occurrence_time                  AS nvarchar(max)) AS last_occurrence_time
									,CAST(sa.occurrence_count                      AS nvarchar(max)) AS occurrence_count
									,CAST(sa.has_notification                      AS nvarchar(max)) AS has_notification
								FROM msdb.dbo.sysalerts AS sa WITH (NOLOCK)
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.message_id
									,p.event_source
									,p.severity
									,p.enabled
									,p.delay_between_responses
									,p.last_occurrence_date
									,p.last_occurrence_time
									,p.occurrence_count
									,p.has_notification
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Host information (Query 11) (Host Info)
						--
						BEGIN
							--
							-- Test if object dm_os_host_info exists
							--
							IF EXISTS(
								SELECT *
								FROM master.sys.system_objects AS so
								WHERE (so.name = ''''dm_os_host_info'''')
							)
							BEGIN
								SET @stmt = ''''
									INSERT INTO #inventory(Query, Category, [Key], Value)
									SELECT 11 AS Query, '''''''''''''''' AS Category, unpvt.K, unpvt.V
									FROM (
										SELECT
											 CAST(dohi.host_platform           COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS host_platform
											,CAST(dohi.host_distribution       COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS host_distribution
											,CAST(dohi.host_release            COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS host_release
											,CAST(dohi.host_service_pack_level COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS host_service_pack_level
											,CAST(dohi.host_sku                                         AS nvarchar(max)) AS host_sku
											,CAST(dohi.os_language_version                              AS nvarchar(max)) AS os_language_version
										FROM sys.dm_os_host_info AS dohi WITH (NOLOCK)
									) AS p
									UNPIVOT(
										V FOR K IN (
											p.host_platform
											,p.host_distribution
											,p.host_release
											,p.host_service_pack_level
											,p.host_sku
											,p.os_language_version
										)
									) AS unpvt OPTION (RECOMPILE);
								'''';
								EXEC(@stmt);
							END
						END;

						--
						-- SQL Server NUMA Node information  (Query 12) (SQL Server NUMA Info)
						--
						BEGIN
							--
							-- Test if online_scheduler_mask exists on dm_os_nodes
							--
							BEGIN
								DECLARE @onlineSchedulerMaskStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_nodes'''') AND (sc.name = ''''online_scheduler_mask'''')
								)
								BEGIN
									SET @onlineSchedulerMaskStmt = ''''don.online_scheduler_mask'''';
								END
								ELSE BEGIN
									SET @onlineSchedulerMaskStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if processor_group exists on dm_os_nodes
							--
							BEGIN
								DECLARE @processorGroupStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_nodes'''') AND (sc.name = ''''processor_group'''')
								)
								BEGIN
									SET @processorGroupStmt = ''''don.processor_group'''';
								END
								ELSE BEGIN
									SET @processorGroupStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if cpu_count exists on dm_os_nodes
							--
							BEGIN
								DECLARE @cpuCountStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_nodes'''') AND (sc.name = ''''cpu_count'''')
								)
								BEGIN
									SET @cpuCountStmt = ''''don.cpu_count'''';
								END
								ELSE BEGIN
									SET @cpuCountStmt = ''''NULL'''';
								END;
							END;

							SET @stmt = ''''
								INSERT INTO #inventory(Query, Category, [Key], Value)
								SELECT 12 AS Query, unpvt.node_id AS Category, unpvt.K, unpvt.V
								FROM (
									SELECT
										CAST(don.node_id                       AS nvarchar(max)) AS node_id
										,CAST(don.memory_node_id               AS nvarchar(max)) AS memory_node_id
										,CAST(don.cpu_affinity_mask            AS nvarchar(max)) AS cpu_affinity_mask
										,CAST(don.online_scheduler_count       AS nvarchar(max)) AS online_scheduler_count
										,CAST(don.timer_task_affinity_mask     AS nvarchar(max)) AS timer_task_affinity_mask
										,CAST(don.permanent_task_affinity_mask AS nvarchar(max)) AS permanent_task_affinity_mask
										,CAST(don.resource_monitor_state       AS nvarchar(max)) AS resource_monitor_state
										,CAST('''' + @onlineSchedulerMaskStmt + '''' AS nvarchar(max)) AS online_scheduler_mask
										,CAST('''' + @processorGroupStmt + '''' AS nvarchar(max)) AS processor_group
										,CAST('''' + @cpuCountStmt + '''' AS nvarchar(max)) AS cpu_count
									FROM sys.dm_os_nodes AS don WITH (NOLOCK) 
									WHERE (don.node_state_desc <> N''''''''ONLINE DAC'''''''')
								) AS p
								UNPIVOT(
									V FOR K IN (
										p.memory_node_id
										,p.cpu_affinity_mask
										,p.online_scheduler_count
										,p.timer_task_affinity_mask
										,p.permanent_task_affinity_mask
										,p.resource_monitor_state
										,p.online_scheduler_mask
										,p.processor_group
										,p.cpu_count
									)
								) AS unpvt OPTION (RECOMPILE);
							'''';
							EXEC(@stmt);
						END;

						--
						-- Hardware information from SQL Server 2019  (Query 17) (Hardware Info)
						--
						BEGIN
							--
							-- Test if physical_memory_kb exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @physicalMemoryKBStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''physical_memory_kb'''')
								)
								BEGIN
									SET @physicalMemoryKBStmt = ''''dosi.physical_memory_kb'''';
								END
								ELSE BEGIN
									SET @physicalMemoryKBStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if affinity_type exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @affinityTypeStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''affinity_type'''')
								)
								BEGIN
									SET @affinityTypeStmt = ''''dosi.affinity_type'''';
								END
								ELSE BEGIN
									SET @affinityTypeStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if virtual_machine_type exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @virtualMachineTypeStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''virtual_machine_type'''')
								)
								BEGIN
									SET @virtualMachineTypeStmt = ''''dosi.virtual_machine_type'''';
								END
								ELSE BEGIN
									SET @virtualMachineTypeStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if softnuma_configuration exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @softnumaConfigurationStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''softnuma_configuration'''')
								)
								BEGIN
									SET @softnumaConfigurationStmt = ''''dosi.softnuma_configuration'''';
								END
								ELSE BEGIN
									SET @softnumaConfigurationStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if sql_memory_model exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @sqlMemoryModelStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''sql_memory_model'''')
								)
								BEGIN
									SET @sqlMemoryModelStmt = ''''dosi.sql_memory_model'''';
								END
								ELSE BEGIN
									SET @sqlMemoryModelStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if socket_count exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @socketCountStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''socket_count'''')
								)
								BEGIN
									SET @socketCountStmt = ''''dosi.socket_count'''';
								END
								ELSE BEGIN
									SET @socketCountStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if cores_per_socket exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @coresPerSocketStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''cores_per_socket'''')
								)
								BEGIN
									SET @coresPerSocketStmt = ''''dosi.cores_per_socket'''';
								END
								ELSE BEGIN
									SET @coresPerSocketStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if numa_node_count exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @numaNodeCountStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''numa_node_count'''')
								)
								BEGIN
									SET @numaNodeCountStmt = ''''dosi.numa_node_count'''';
								END
								ELSE BEGIN
									SET @numaNodeCountStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if container_type exists on dm_os_sys_info
							--
							BEGIN
								DECLARE @containerTypeStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''dm_os_sys_info'''') AND (sc.name = ''''container_type'''')
								)
								BEGIN
									SET @containerTypeStmt = ''''dosi.container_type'''';
								END
								ELSE BEGIN
									SET @containerTypeStmt = ''''NULL'''';
								END;
							END;

							SET @stmt = ''''
								INSERT INTO #inventory(Query, Category, [Key], Value)
								SELECT 17 AS Query, '''''''''''''''' AS Category, unpvt.K, unpvt.V
								FROM (
									SELECT
										CAST(dosi.cpu_count AS nvarchar(max)) AS cpu_count
										,CAST(dosi.hyperthread_ratio AS nvarchar(max)) AS hyperthread_ratio
										,CAST('''' + @physicalMemoryKBStmt + '''' AS nvarchar(max)) AS physical_memory_kb
										,CAST(dosi.max_workers_count AS nvarchar(max)) AS max_workers_count
										,CAST(dosi.scheduler_count AS nvarchar(max)) AS scheduler_count
										,CAST(dosi.sqlserver_start_time AS nvarchar(max)) AS sqlserver_start_time
										,CAST('''' + @affinityTypeStmt + '''' AS nvarchar(max)) AS affinity_type
										,CAST('''' + @virtualMachineTypeStmt + '''' AS nvarchar(max)) AS virtual_machine_type
										,CAST('''' + @softnumaConfigurationStmt + '''' AS nvarchar(max)) AS softnuma_configuration
										,CAST('''' + @sqlMemoryModelStmt + '''' AS nvarchar(max)) AS sql_memory_model
										,CAST('''' + @socketCountStmt + '''' AS nvarchar(max)) AS socket_count
										,CAST('''' + @coresPerSocketStmt + '''' AS nvarchar(max)) AS cores_per_socket
										,CAST('''' + @numaNodeCountStmt + '''' AS nvarchar(max)) AS numa_node_count
										,CAST('''' + @containerTypeStmt + '''' AS nvarchar(max)) AS container_type
									FROM sys.dm_os_sys_info AS dosi WITH (NOLOCK)
								) AS p
								UNPIVOT(
									V FOR K IN (
										p.cpu_count
										,p.hyperthread_ratio
										,p.physical_memory_kb
										,p.max_workers_count
										,p.scheduler_count
										,p.sqlserver_start_time
										,p.affinity_type
										,p.virtual_machine_type
										,p.softnuma_configuration
										,p.sql_memory_model
										,p.socket_count
										,p.cores_per_socket
										,p.numa_node_count
										,p.container_type
									)
								) AS unpvt OPTION (RECOMPILE);
							'''';
							EXEC(@stmt);
						END;

						--
						-- Get System Manufacturer and model number from SQL Server Error log (Query 18) (System Manufacturer)
						--
						BEGIN
							DELETE @xpReadErrorLog;
							INSERT INTO @xpReadErrorLog
							EXEC sys.xp_readerrorlog 0, 1, N''''Manufacturer'''';
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 18 AS Query, '''''''' AS Category, ''''LogDate''''       AS K, CONVERT(nvarchar(max), q.LogDate, 126) AS V FROM @xpReadErrorLog AS q UNION ALL
							SELECT 18 AS Query, '''''''' AS Category, ''''ProcessorInfo'''' AS K, q.ProcessorInfo                        AS V FROM @xpReadErrorLog AS q UNION ALL
							SELECT 18 AS Query, '''''''' AS Category, ''''Text''''          AS K, q.Text                                 AS V FROM @xpReadErrorLog AS q;
						END;

						--
						-- Get BIOS date from Windows Registry (Query 19) (BIOS Date)
						--
						BEGIN
							DELETE @xpReadReg;
							INSERT INTO @xpReadReg
							EXEC sys.xp_instance_regread N''''HKEY_LOCAL_MACHINE'''', N''''HARDWARE\DESCRIPTION\System\BIOS'''', N''''BiosReleaseDate'''';
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 19 AS Query, '''''''' AS Category, ''''BiosReleaseDate'''' AS K, q.Data AS V FROM @xpReadReg AS q;
						END;

						--
						-- Get processor description from Windows Registry  (Query 20) (Processor Description)
						--
						BEGIN
							DELETE @xpReadReg;
							INSERT INTO @xpReadReg
							EXEC sys.xp_instance_regread N''''HKEY_LOCAL_MACHINE'''', N''''HARDWARE\DESCRIPTION\System\CentralProcessor\0'''', N''''ProcessorNameString'''';
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 20 AS Query, '''''''' AS Category, ''''ProcessorNameString'''' AS K, q.Data AS V FROM @xpReadReg AS q;
						END;

						--
						-- Get information on location, time and size of any memory dumps from SQL Server  (Query 21) (Memory Dump Info)
						--
						IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''''dm_server_memory_dumps''''))
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 21 AS Query, unpvt.Rnk AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									 CAST(dsmd.filename COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS filename
									,CONVERT(nvarchar(max), dsmd.creation_time, 126)               AS creation_time
									,CAST(dsmd.size_in_bytes                     AS nvarchar(max)) AS size_in_bytes
									,ROW_NUMBER() OVER(ORDER BY dsmd.creation_time)                AS Rnk
								FROM sys.dm_server_memory_dumps AS dsmd WITH (NOLOCK) 
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.filename
									,p.creation_time
									,p.size_in_bytes
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Look at Suspect Pages table (Query 22) (Suspect Pages)
						--
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 22 AS Query, unpvt.database_file_page AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									CAST(DB_NAME(sp.database_id) AS nvarchar(max)) + '''':'''' +  CAST(sp.file_id AS nvarchar(max)) + '''':'''' + CAST(sp.page_id AS nvarchar(max)) AS database_file_page
									,CAST(sp.event_type AS nvarchar(max)) AS event_type
									,CAST(sp.error_count AS nvarchar(max)) AS error_count
									,CONVERT(nvarchar(max), sp.last_update_date, 126) AS last_update_date
								FROM msdb.dbo.suspect_pages AS sp WITH (NOLOCK)
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.event_type
									,p.error_count
									,p.last_update_date
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Look at Resource Governor configuration
						--
						BEGIN
							--
							-- Test if max_outstanding_io_per_volume exists on resource_governor_configuration
							--
							BEGIN
								DECLARE @maxOutstandingIOperVolumeStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''resource_governor_configuration'''') AND (sc.name = ''''max_outstanding_io_per_volume'''')
								)
								BEGIN
									SET @maxOutstandingIOperVolumeStmt = ''''rgc.max_outstanding_io_per_volume'''';
								END
								ELSE BEGIN
									SET @maxOutstandingIOperVolumeStmt = ''''NULL'''';
								END;
							END;

							SET @stmt = ''''
								INSERT INTO #inventory(Query, Category, [Key], Value)
								SELECT 23 AS Query, '''''''''''''''' AS Category, unpvt.K, unpvt.V
								FROM (
									SELECT
										CAST(rgc.is_enabled AS nvarchar(max)) AS is_enabled
										,CAST('''' + @maxOutstandingIOperVolumeStmt + '''' AS nvarchar(max)) AS max_outstanding_io_per_volume
										,CAST(QUOTENAME(sch.name) + ''''''''.'''''''' + QUOTENAME(o.name) COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS ClassifierFunction
										,sm.definition COLLATE DATABASE_DEFAULT AS ClassifierFunctionDefinition
									FROM master.sys.resource_governor_configuration AS rgc
									LEFT OUTER JOIN master.sys.objects AS o ON (o.object_id = rgc.classifier_function_id)
									LEFT OUTER JOIN master.sys.schemas AS sch ON (sch.schema_id = o.schema_id)
									LEFT OUTER JOIN master.sys.sql_modules AS sm ON (sm.object_id = rgc.classifier_function_id)
								) AS p
								UNPIVOT(
									V FOR K IN (
										p.is_enabled
										,p.max_outstanding_io_per_volume
										,p.ClassifierFunction
										,p.ClassifierFunctionDefinition
									)
								) AS unpvt OPTION (RECOMPILE);
							'''';
							EXEC(@stmt);
						END;

						--
						-- Look at Resource Governor resource pool affinity
						--
						IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''''resource_governor_resource_pool_affinity''''))
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 24 AS Query, unpvt.PoolName AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									CAST(rgrp.name AS nvarchar(max)) AS PoolName
									,CAST(rgrpa.processor_group AS nvarchar(max)) AS processor_group
									,CAST(rgrpa.scheduler_mask AS nvarchar(max)) AS scheduler_mask
								FROM sys.resource_governor_resource_pool_affinity AS rgrpa
								LEFT OUTER JOIN sys.resource_governor_resource_pools AS rgrp ON (rgrp.pool_id = rgrpa.pool_id)
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.processor_group
									,p.scheduler_mask
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Look at Resource Governor resource pools
						--
						BEGIN
							--
							-- Test if cap_cpu_percent exists on resource_governor_resource_pools
							--
							BEGIN
								DECLARE @capCPUpercentStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''resource_governor_resource_pools'''') AND (sc.name = ''''cap_cpu_percent'''')
								)
								BEGIN
									SET @capCPUpercentStmt = ''''rgrp.cap_cpu_percent'''';
								END
								ELSE BEGIN
									SET @capCPUpercentStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if min_iops_per_volume exists on resource_governor_resource_pools
							--
							BEGIN
								DECLARE @minIOPSperVolumeStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''resource_governor_resource_pools'''') AND (sc.name = ''''min_iops_per_volume'''')
								)
								BEGIN
									SET @minIOPSperVolumeStmt = ''''rgrp.min_iops_per_volume'''';
								END
								ELSE BEGIN
									SET @minIOPSperVolumeStmt = ''''NULL'''';
								END;
							END;

							--
							-- Test if max_iops_per_volume exists on resource_governor_resource_pools
							--
							BEGIN
								DECLARE @maxIOPSperVolumeStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''resource_governor_resource_pools'''') AND (sc.name = ''''max_iops_per_volume'''')
								)
								BEGIN
									SET @maxIOPSperVolumeStmt = ''''rgrp.max_iops_per_volume'''';
								END
								ELSE BEGIN
									SET @maxIOPSperVolumeStmt = ''''NULL'''';
								END;
							END;

							SET @stmt = ''''
								INSERT INTO #inventory(Query, Category, [Key], Value)
								SELECT 25 AS Query, unpvt.PoolName AS Category, unpvt.K, unpvt.V
								FROM (
									SELECT
										rgrp.name AS PoolName
										,CAST(rgrp.min_cpu_percent AS nvarchar(max)) AS min_cpu_percent
										,CAST(rgrp.max_cpu_percent AS nvarchar(max)) AS max_cpu_percent
										,CAST(rgrp.min_memory_percent AS nvarchar(max)) AS min_memory_percent
										,CAST(rgrp.max_memory_percent AS nvarchar(max)) AS max_memory_percent
										,CAST('''' + @capCPUpercentStmt + '''' AS nvarchar(max)) AS cap_cpu_percent
										,CAST('''' + @minIOPSperVolumeStmt + '''' AS nvarchar(max)) AS min_iops_per_volume
										,CAST('''' + @maxIOPSperVolumeStmt + '''' AS nvarchar(max)) AS max_iops_per_volume
									FROM sys.resource_governor_resource_pools AS rgrp
								) AS p
								UNPIVOT(
									V FOR K IN (
										p.min_cpu_percent
										,p.max_cpu_percent
										,p.min_memory_percent
										,p.max_memory_percent
										,p.cap_cpu_percent
										,p.min_iops_per_volume
										,p.max_iops_per_volume
									)
								) AS unpvt OPTION (RECOMPILE);
							'''';
							EXEC(@stmt);
						END;

						--
						-- Look at Resource Governor workload groups
						--
						BEGIN
							--
							-- Test if request_max_memory_grant_percent_numeric exists on resource_governor_workload_groups
							--
							BEGIN
								DECLARE @requestMaxMemoryGrantPercentNumericStmt nvarchar(max);

								IF EXISTS(
									SELECT *
									FROM master.sys.system_columns AS sc
									INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
									WHERE (so.name = ''''resource_governor_workload_groups'''') AND (sc.name = ''''request_max_memory_grant_percent_numeric'''')
								)
								BEGIN
									SET @requestMaxMemoryGrantPercentNumericStmt = ''''rgwg.request_max_memory_grant_percent_numeric'''';
								END
								ELSE BEGIN
									SET @requestMaxMemoryGrantPercentNumericStmt = ''''NULL'''';
								END;
							END;

							SET @stmt = ''''
								INSERT INTO #inventory(Query, Category, [Key], Value)
								SELECT 26 AS Query, QUOTENAME(unpvt.PoolName) + ''''''''.'''''''' + QUOTENAME(unpvt.WorkloadGroupName) AS Category, unpvt.K, unpvt.V
								FROM (
									SELECT
										CAST(rgrp.name AS nvarchar(max)) AS PoolName
										,CAST(rgwg.name AS nvarchar(max)) AS WorkloadGroupName
										,CAST(rgwg.importance AS nvarchar(max)) COLLATE DATABASE_DEFAULT AS importance
										,CAST(rgwg.request_max_memory_grant_percent AS nvarchar(max)) AS request_max_memory_grant_percent
										,CAST(rgwg.request_max_cpu_time_sec AS nvarchar(max)) AS request_max_cpu_time_sec
										,CAST(rgwg.request_memory_grant_timeout_sec AS nvarchar(max)) AS request_memory_grant_timeout_sec
										,CAST(rgwg.max_dop AS nvarchar(max)) AS max_dop
										,CAST(rgwg.group_max_requests AS nvarchar(max)) AS group_max_requests
										,CAST('''' + @requestMaxMemoryGrantPercentNumericStmt + '''' AS nvarchar(max)) AS request_max_memory_grant_percent_numeric
									FROM sys.resource_governor_workload_groups AS rgwg
									LEFT OUTER JOIN sys.resource_governor_resource_pools AS rgrp ON (rgrp.pool_id = rgwg.pool_id)
								) AS p
								UNPIVOT(
									V FOR K IN (
										p.importance
										,p.request_max_memory_grant_percent
										,p.request_max_cpu_time_sec
										,p.request_memory_grant_timeout_sec
										,p.max_dop
										,p.group_max_requests
										,p.request_max_memory_grant_percent_numeric
									)
								) AS unpvt OPTION (RECOMPILE);
							'''';
							EXEC(@stmt);
						END;

						--
						-- Look at Resource Governor external resource pool affinity
						--
						IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''''resource_governor_external_resource_pool_affinity''''))
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 27 AS Query, unpvt.PoolName AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									CAST(rgerp.name AS nvarchar(max)) AS PoolName
									,CAST(rgerpa.processor_group AS nvarchar(max)) AS processor_group
									,CAST(rgerpa.cpu_mask AS nvarchar(max)) AS cpu_mask
								FROM sys.resource_governor_external_resource_pool_affinity AS rgerpa
								LEFT OUTER JOIN sys.resource_governor_external_resource_pools AS rgerp ON (rgerp.external_pool_id = rgerpa.external_pool_id)
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.processor_group
									,p.cpu_mask
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Look at Resource Governor external resource pool affinity
						--
						IF EXISTS(SELECT * FROM master.sys.system_objects AS so WHERE (so.name = ''''resource_governor_external_resource_pools''''))
						BEGIN
							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 28 AS Query, unpvt.PoolName AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									CAST(rgerp.name AS nvarchar(max)) AS PoolName
									,CAST(rgerp.max_cpu_percent AS nvarchar(max)) AS max_cpu_percent
									,CAST(rgerp.max_memory_percent AS nvarchar(max)) AS max_memory_percent
									,CAST(rgerp.max_processes AS nvarchar(max)) AS max_processes
									,CAST(rgerp.version AS nvarchar(max)) AS version
								FROM sys.resource_governor_external_resource_pools AS rgerp
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.max_cpu_percent
									,p.max_memory_percent
									,p.max_processes
									,p.version
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Get SQL Server Agent configuration
						--
						BEGIN
							IF (OBJECT_ID(''''tempdb..#sqlagent_properties'''') IS NOT NULL) DROP TABLE #sqlagent_properties;

							CREATE TABLE #sqlagent_properties(
								auto_start int,
								msx_server_name nvarchar(128) NULL,
								sqlagent_type int,
								startup_account nvarchar(100) NULL,
								sqlserver_restart int,
								jobhistory_max_rows int,
								jobhistory_max_rows_per_job int,
								errorlog_file nvarchar(255) NULL,
								errorlogging_level int,
								errorlog_recipient nvarchar(255) NULL,
								monitor_autostart int,
								local_host_server nvarchar(128) NULL,
								job_shutdown_timeout int,
								cmdexec_account varbinary(64) NULL,
								regular_connections int,
								host_login_name nvarchar(128) NULL,
								host_login_password varbinary(512) NULL,
								login_timeout int,
								idle_cpu_percent int,
								idle_cpu_duration int,
								oem_errorlog int,
								sysadmin_only nvarchar(64) NULL,
								email_profile nvarchar(64) NULL,
								email_save_in_sent_folder int,
								cpu_poller_enabled int,
								alert_replace_runtime_tokens int
							);

							INSERT INTO #sqlagent_properties
							EXEC msdb.dbo.sp_get_sqlagent_properties;

							INSERT INTO #inventory(Query, Category, [Key], Value)
							SELECT 29 AS Query, '''''''' AS Category, unpvt.K, unpvt.V
							FROM (
								SELECT
									CAST(sp.auto_start AS nvarchar(max)) AS auto_start
									,CAST(sp.msx_server_name COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS msx_server_name
									,CAST(sp.sqlagent_type AS nvarchar(max)) AS sqlagent_type
									,CAST(sp.startup_account COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS startup_account
									,CAST(sp.sqlserver_restart AS nvarchar(max)) AS sqlserver_restart
									,CAST(sp.jobhistory_max_rows AS nvarchar(max)) AS jobhistory_max_rows
									,CAST(sp.jobhistory_max_rows_per_job AS nvarchar(max)) AS jobhistory_max_rows_per_job
									,CAST(sp.errorlog_file COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS errorlog_file
									,CAST(sp.errorlogging_level AS nvarchar(max)) AS errorlogging_level
									,CAST(sp.errorlog_recipient COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS errorlog_recipient
									,CAST(sp.monitor_autostart AS nvarchar(max)) AS monitor_autostart
									,CAST(sp.local_host_server COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS local_host_server
									,CAST(sp.job_shutdown_timeout AS nvarchar(max)) AS job_shutdown_timeout
									,CAST(sp.cmdexec_account AS nvarchar(max)) AS cmdexec_account
									,CAST(sp.regular_connections AS nvarchar(max)) AS regular_connections
									,CAST(sp.host_login_name COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS host_login_name
									,CAST(sp.host_login_password AS nvarchar(max)) AS host_login_password
									,CAST(sp.login_timeout AS nvarchar(max)) AS login_timeout
									,CAST(sp.idle_cpu_percent AS nvarchar(max)) AS idle_cpu_percent
									,CAST(sp.idle_cpu_duration AS nvarchar(max)) AS idle_cpu_duration
									,CAST(sp.oem_errorlog AS nvarchar(max)) AS oem_errorlog
									,CAST(sp.sysadmin_only COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS sysadmin_only
									,CAST(sp.email_profile COLLATE DATABASE_DEFAULT AS nvarchar(max)) AS email_profile
									,CAST(sp.email_save_in_sent_folder AS nvarchar(max)) AS email_save_in_sent_folder
									,CAST(sp.cpu_poller_enabled AS nvarchar(max)) AS cpu_poller_enabled
									,CAST(sp.alert_replace_runtime_tokens AS nvarchar(max)) AS alert_replace_runtime_tokens
								FROM #sqlagent_properties AS sp
							) AS p
							UNPIVOT(
								V FOR K IN (
									p.auto_start
									,p.msx_server_name
									,p.sqlagent_type
									,p.startup_account
									,p.sqlserver_restart
									,p.jobhistory_max_rows
									,p.jobhistory_max_rows_per_job
									,p.errorlog_file
									,p.errorlogging_level
									,p.errorlog_recipient
									,p.monitor_autostart
									,p.local_host_server
									,p.job_shutdown_timeout
									,p.cmdexec_account
									,p.regular_connections
									,p.host_login_name
									,p.host_login_password
									,p.login_timeout
									,p.idle_cpu_percent
									,p.idle_cpu_duration
									,p.oem_errorlog
									,p.sysadmin_only
									,p.email_profile
									,p.email_save_in_sent_folder
									,p.cpu_poller_enabled
									,p.alert_replace_runtime_tokens
								)
							) AS unpvt OPTION (RECOMPILE);
						END;

						--
						-- Remove records where Value is NULL
						--
						BEGIN
							DELETE tgt
							FROM #inventory AS tgt
							WHERE (tgt.Value IS NULL);
						END;

						--
						-- Update current record ValidTo as it is no longer valid
						--
						BEGIN
							UPDATE tgt
							SET tgt.ValidTo = @nowUTC
							FROM dbo.fhsmInstanceState AS tgt
							LEFT OUTER JOIN #inventory AS src ON (src.Query = tgt.Query) AND (src.Category COLLATE DATABASE_DEFAULT = tgt.Category) AND (src.[Key] COLLATE DATABASE_DEFAULT = tgt.[Key])
							WHERE
								(
									(src.Query IS NULL)
									OR ((src.Value COLLATE DATABASE_DEFAULT <> tgt.Value) OR (src.Value IS NULL AND tgt.Value IS NOT NULL) OR (src.Value IS NOT NULL AND tgt.Value IS NULL))
								) AND (tgt.ValidTo = ''''9999-dec-31 23:59:59'''');
						END;

						--
						-- Insert new records
						--
						BEGIN
							INSERT INTO dbo.fhsmInstanceState(Query, Category, [Key], Value, ValidFrom, ValidTo, TimestampUTC, Timestamp)
							SELECT src.Query, src.Category, src.[Key], src.Value, @nowUTC AS ValidFrom, ''''9999-dec-31 23:59:59'''' AS ValidTo, @nowUTC, @now
							FROM #inventory AS src
							WHERE NOT EXISTS (
								SELECT *
								FROM dbo.fhsmInstanceState AS tgt
								WHERE
									(tgt.Query = src.Query)
									AND (tgt.Category COLLATE DATABASE_DEFAULT = src.Category)
									AND (tgt.[Key] COLLATE DATABASE_DEFAULT = src.[Key])
									AND ((tgt.Value COLLATE DATABASE_DEFAULT = src.Value) OR (tgt.Value IS NULL AND src.Value IS NULL)) AND (tgt.ValidTo = ''''9999-dec-31 23:59:59'''')
							);
						END;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPInstanceState
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPInstanceState'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmInstanceState''
				,1
				,''TimestampUTC''
				,1
				,1825	-- 5 years
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableInstanceState							AS Enabled
				,0												AS DeploymentStatus
				,''Instance state''								AS Name
				,PARSENAME(''dbo.fhsmSPInstanceState'', 1)		AS Task
				,1 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--

	--
	-- Update dimensions based upon the fact tables
	--
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:MissingIndexes.sql modified: 2025.08.05 19.11.36
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableMissingIndexes bit;

	SET @enableMissingIndexes = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing MissingIndexes'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Variables used in view to control the statement output
	--
	BEGIN
		DECLARE @maxStatementLength int;

		SET @maxStatementLength = 1024;
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmMissingIndexes and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmMissingIndexes'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmMissingIndexes'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmMissingIndexes(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,QueryHash binary(8) NULL
					,EqualityColumns nvarchar(4000) NULL
					,InequalityColumns nvarchar(4000) NULL
					,IncludedColumns nvarchar(4000) NULL
					,UniqueCompiles bigint NULL
					,UserSeeks bigint NOT NULL
					,UserScans bigint NOT NULL
					,LastUserSeek datetime NULL
					,LastUserScan datetime NULL
					,AvgTotalUserCost float NOT NULL
					,AvgUserImpact float NOT NULL
					,SystemSeeks bigint NOT NULL
					,SystemScans bigint NOT NULL
					,LastSystemSeek datetime NULL
					,LastSystemScan datetime NULL
					,AvgTotalSystemCost float NOT NULL
					,AvgSystemImpact float NOT NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmMissingIndexes PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		--
		-- Adding column QueryHash to table dbo.fhsmMissingIndexes if it not already exists
		--
		IF NOT EXISTS (SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmMissingIndexes'')) AND (c.name = ''QueryHash''))
		BEGIN
			RAISERROR(''Adding column [QueryHash] to table dbo.fhsmMissingIndexes'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				ALTER TABLE dbo.fhsmMissingIndexes
					ADD QueryHash binary(8) NULL;
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexes'')) AND (i.name = ''NC_fhsmMissingIndexes_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexes_TimestampUTC] to table dbo.fhsmMissingIndexes'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexes_TimestampUTC ON dbo.fhsmMissingIndexes(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexes'')) AND (i.name = ''NC_fhsmMissingIndexes_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexes_Timestamp] to table dbo.fhsmMissingIndexes'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexes_Timestamp ON dbo.fhsmMissingIndexes(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexes'')) AND (i.name = ''NC_fhsmMissingIndexes_DatabaseName_SchemaName_ObjectName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexes_DatabaseName_SchemaName_ObjectName] to table dbo.fhsmMissingIndexes'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexes_DatabaseName_SchemaName_ObjectName ON dbo.fhsmMissingIndexes(DatabaseName, SchemaName, ObjectName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexes'')) AND (i.name = ''NC_fhsmMissingIndexes_DatabaseName_QueryHash''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexes_DatabaseName_QueryHash] to table dbo.fhsmMissingIndexes'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexes_DatabaseName_QueryHash ON dbo.fhsmMissingIndexes(DatabaseName, QueryHash)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmMissingIndexes
		--
		BEGIN
			SET @objectName = ''dbo.fhsmMissingIndexes'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmMissingIndexesTemp and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmMissingIndexesTemp'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmMissingIndexesTemp'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmMissingIndexesTemp(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,SchemaName nvarchar(128) NOT NULL
					,ObjectName nvarchar(128) NOT NULL
					,QueryHash binary(8) NULL
					,Statement nvarchar(max) NULL
					,EqualityColumns nvarchar(4000) NULL
					,InequalityColumns nvarchar(4000) NULL
					,IncludedColumns nvarchar(4000) NULL
					,UniqueCompiles bigint NULL
					,UserSeeks bigint NOT NULL
					,UserScans bigint NOT NULL
					,LastUserSeek datetime NULL
					,LastUserScan datetime NULL
					,AvgTotalUserCost float NOT NULL
					,AvgUserImpact float NOT NULL
					,SystemSeeks bigint NOT NULL
					,SystemScans bigint NOT NULL
					,LastSystemSeek datetime NULL
					,LastSystemScan datetime NULL
					,AvgTotalSystemCost float NOT NULL
					,AvgSystemImpact float NOT NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmMissingIndexesTemp PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexesTemp'')) AND (i.name = ''NC_fhsmMissingIndexesTemp_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexesTemp_TimestampUTC] to table dbo.fhsmMissingIndexesTemp'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexesTemp_TimestampUTC ON dbo.fhsmMissingIndexesTemp(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexesTemp'')) AND (i.name = ''NC_fhsmMissingIndexesTemp_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexesTemp_Timestamp] to table dbo.fhsmMissingIndexesTemp'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexesTemp_Timestamp ON dbo.fhsmMissingIndexesTemp(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexesTemp'')) AND (i.name = ''NC_fhsmMissingIndexesTemp_DatabaseName_SchemaName_ObjectName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexesTemp_DatabaseName_SchemaName_ObjectName] to table dbo.fhsmMissingIndexesTemp'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexesTemp_DatabaseName_SchemaName_ObjectName ON dbo.fhsmMissingIndexesTemp(DatabaseName, SchemaName, ObjectName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmMissingIndexesTemp
		--
		BEGIN
			SET @objectName = ''dbo.fhsmMissingIndexesTemp'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmMissingIndexStatement and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmMissingIndexStatement'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmMissingIndexStatement'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmMissingIndexStatement(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,QueryHash binary(8) NOT NULL
					,Statement nvarchar(max) NOT NULL
					,PrevStatement nvarchar(max) NULL
					,UpdateCount int NOT NULL
					,CONSTRAINT PK_fhsmMissingIndexStatement PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmMissingIndexStatement'')) AND (i.name = ''NC_fhsmMissingIndexStatement_DatabaseName_QueryHash''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmMissingIndexStatement_DatabaseName_QueryHash] to table dbo.fhsmMissingIndexStatement'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmMissingIndexStatement_DatabaseName_QueryHash ON dbo.fhsmMissingIndexStatement(DatabaseName, QueryHash)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmMissingIndexStatement
		--
		BEGIN
			SET @objectName = ''dbo.fhsmMissingIndexStatement'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Missing indexes]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing indexes'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing indexes'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing indexes'') + ''
				AS
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
				WITH missingIndexes AS (
					SELECT
						mi.DatabaseName
						,mi.SchemaName
						,mi.ObjectName
						,mi.QueryHash
						,mi.EqualityColumns
						,mi.InequalityColumns
						,mi.IncludedColumns
						,mi.UniqueCompiles
						,mi.UserSeeks
						,mi.LastUserSeek
						,mi.UserScans
						,mi.LastUserScan
						,mi.AvgTotalUserCost
						,mi.AvgUserImpact
						,mi.SystemSeeks
						,mi.LastSystemSeek
						,mi.SystemScans
						,mi.LastSystemScan
						,mi.AvgTotalSystemCost
						,mi.AvgSystemImpact
						,mi.LastSQLServiceRestart
						,CAST(mi.LastUserSeek AS date) AS LastUserSeekDate
						,mi.Timestamp
						,ROW_NUMBER() OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS Idx
					FROM dbo.fhsmMissingIndexes AS mi
					WHERE (
							(mi.DatabaseName <> ''''<HeartBeat>'''')
							OR (mi.SchemaName <> ''''<HeartBeat>'''')
							OR (mi.ObjectName <> ''''<HeartBeat>'''')
					)
				)
				'';
			END;
			SET @stmt += ''
				SELECT
					b.EqualityColumns
					,b.InequalityColumns
					,b.IncludedColumns
					,b.DeltaUniqueCompiles AS UniqueCompiles
					,b.DeltaUserSeeks AS UserSeeks
					,b.LastUserSeek
					,b.DeltaUserScans AS UserScans
					,b.LastUserScan
					,CASE WHEN (b.DeltaUserSeeks <> 0) OR (b.DeltaUserScans <> 0) THEN b.AvgTotalUserCost ELSE 0 END AS AvgTotalUserCost
					,CASE WHEN (b.DeltaUserSeeks <> 0) OR (b.DeltaUserScans <> 0) THEN b.AvgUserImpact ELSE 0 END AS AvgUserImpact
					,b.DeltaSystemSeeks AS SystemSeeks
					,b.LastSystemSeek
					,b.DeltaSystemScans AS SystemScans
					,b.LastSystemScan
					,CASE WHEN (b.DeltaSystemSeeks <> 0) OR (b.DeltaSystemScans <> 0) THEN b.AvgTotalSystemCost ELSE 0 END AS AvgTotalSystemCost
					,CASE WHEN (b.DeltaSystemSeeks <> 0) OR (b.DeltaSystemScans <> 0) THEN b.AvgSystemImpact ELSE 0 END AS AvgSystemImpact

					,CAST(b.LastUserSeek AS date) AS LastUserSeekDate
					,(DATEPART(HOUR, b.LastUserSeek) * 60 * 60) + (DATEPART(MINUTE, b.LastUserSeek) * 60) + (DATEPART(SECOND, b.LastUserSeek)) AS LastUserSeekTimeKey
					,CAST(b.Timestamp AS date) AS Date
					,(DATEPART(HOUR, b.Timestamp) * 60 * 60) + (DATEPART(MINUTE, b.Timestamp) * 60) + (DATEPART(SECOND, b.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.SchemaName, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS SchemaKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.DatabaseName, b.SchemaName, b.ObjectName, DEFAULT, DEFAULT, DEFAULT) AS k) AS ObjectKey
					,(SELECT k.[Key] FROM FHSQLMonitor.dbo.fhsmFNGenerateKey(b.DatabaseName, CONVERT(nvarchar(18), b.QueryHash, 1), DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS MissingIndexStatementKey
				FROM (
			'';
			SET @stmt += ''
					SELECT
						a.EqualityColumns
						,a.InequalityColumns
						,a.IncludedColumns
						,CASE
							WHEN (a.PreviousUniqueCompiles IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL												-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
							WHEN (a.PreviousUniqueCompiles > a.UniqueCompiles) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UniqueCompiles	-- Either has the counters had an overflow or the server har been restarted
							ELSE a.UniqueCompiles - a.PreviousUniqueCompiles																							-- Difference
						END AS DeltaUniqueCompiles
						,CASE
							WHEN (a.PreviousUserSeeks IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
							WHEN (a.PreviousUserSeeks > a.UserSeeks) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserSeeks
							ELSE a.UserSeeks - a.PreviousUserSeeks
						END AS DeltaUserSeeks
						,a.LastUserSeek
						,CASE
							WHEN (a.PreviousUserScans IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
							WHEN (a.PreviousUserScans > a.UserScans) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.UserScans
							ELSE a.UserScans - a.PreviousUserScans
						END AS DeltaUserScans
						,a.LastUserScan
						,a.AvgTotalUserCost
						,a.AvgUserImpact
						,CASE
							WHEN (a.PreviousSystemSeeks IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
							WHEN (a.PreviousSystemSeeks > a.SystemSeeks) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.SystemSeeks
							ELSE a.SystemSeeks - a.PreviousSystemSeeks
						END AS DeltaSystemSeeks
						,a.LastSystemSeek
						,CASE
							WHEN (a.PreviousSystemScans IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
							WHEN (a.PreviousSystemScans > a.SystemScans) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.SystemScans
							ELSE a.SystemScans - a.PreviousSystemScans
						END AS DeltaSystemScans
						,a.LastSystemScan
						,a.AvgTotalSystemCost
						,a.AvgSystemImpact

						,a.Timestamp
						,a.DatabaseName
						,a.SchemaName
						,a.ObjectName
						,a.QueryHash
					FROM (
			'';
			SET @stmt += ''

			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
						SELECT
							mi.EqualityColumns
							,mi.InequalityColumns
							,mi.IncludedColumns
							,mi.UniqueCompiles
							,prevMi.UniqueCompiles AS PreviousUniqueCompiles
							,mi.UserSeeks
							,prevMi.UserSeeks AS PreviousUserSeeks
							,mi.LastUserSeek
							,mi.UserScans
							,prevMi.UserScans AS PreviousUserScans
							,mi.LastUserScan
							,mi.AvgTotalUserCost
							,mi.AvgUserImpact
							,mi.SystemSeeks
							,prevMi.SystemSeeks AS PreviousSystemSeeks
							,mi.LastSystemSeek
							,mi.SystemScans
							,prevMi.SystemScans AS PreviousSystemScans
							,mi.LastSystemScan
							,mi.AvgTotalSystemCost
							,mi.AvgSystemImpact
							,mi.LastSQLServiceRestart
							,prevMi.LastSQLServiceRestart AS PreviousLastSQLServiceRestart

							,mi.Timestamp
							,mi.DatabaseName
							,mi.SchemaName
							,mi.ObjectName
							,mi.QueryHash
						FROM missingIndexes AS mi
						LEFT OUTER JOIN missingIndexes AS prevMi ON
							(prevMi.DatabaseName = mi.DatabaseName)
							AND (prevMi.SchemaName = mi.SchemaName)
							AND (prevMi.ObjectName = mi.ObjectName)
							AND ((prevMi.QueryHash = mi.QueryHash) OR ((prevMi.QueryHash IS NULL) AND (mi.QueryHash IS NULL)))
							AND ((prevMi.EqualityColumns = mi.EqualityColumns) OR ((prevMi.EqualityColumns IS NULL) AND (mi.EqualityColumns IS NULL)))
							AND ((prevMi.InequalityColumns = mi.InequalityColumns) OR ((prevMi.InequalityColumns IS NULL) AND (mi.InequalityColumns IS NULL)))
							AND ((prevMi.IncludedColumns = mi.IncludedColumns) OR ((prevMi.IncludedColumns IS NULL) AND (mi.IncludedColumns IS NULL)))
							AND (prevMi.Idx = mi.Idx - 1)
				'';
			END
			ELSE BEGIN
				-- SQL Versions SQL2012 or higher

				SET @stmt += ''
						SELECT
							mi.EqualityColumns
							,mi.InequalityColumns
							,mi.IncludedColumns
							,mi.UniqueCompiles
							,LAG(mi.UniqueCompiles) OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS PreviousUniqueCompiles
							,mi.UserSeeks
							,LAG(mi.UserSeeks) OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS PreviousUserSeeks
							,mi.LastUserSeek
							,mi.UserScans
							,LAG(mi.UserScans) OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS PreviousUserScans
							,mi.LastUserScan
							,mi.AvgTotalUserCost
							,mi.AvgUserImpact
							,mi.SystemSeeks
							,LAG(mi.SystemSeeks) OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS PreviousSystemSeeks
							,mi.LastSystemSeek
							,mi.SystemScans
							,LAG(mi.SystemScans) OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS PreviousSystemScans
							,mi.LastSystemScan
							,mi.AvgTotalSystemCost
							,mi.AvgSystemImpact
							,mi.LastSQLServiceRestart
							,LAG(mi.LastSQLServiceRestart) OVER(PARTITION BY mi.DatabaseName, mi.SchemaName, mi.ObjectName, mi.QueryHash, mi.EqualityColumns, mi.InequalityColumns, mi.IncludedColumns ORDER BY mi.TimestampUTC) AS PreviousLastSQLServiceRestart

							,mi.Timestamp
							,mi.DatabaseName
							,mi.SchemaName
							,mi.ObjectName
							,mi.QueryHash
						FROM dbo.fhsmMissingIndexes AS mi
						WHERE (
								(mi.DatabaseName <> ''''<HeartBeat>'''')
								OR (mi.SchemaName <> ''''<HeartBeat>'''')
								OR (mi.ObjectName <> ''''<HeartBeat>'''')
							)
				'';
			END;
			SET @stmt += ''
					) AS a
				) AS b
				WHERE
					(b.DeltaUniqueCompiles <> 0)
					OR (b.DeltaUserSeeks <> 0)
					OR (b.DeltaUserScans <> 0)
					OR (b.DeltaSystemSeeks <> 0)
					OR (b.DeltaSystemScans <> 0)
			
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Missing indexes]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing indexes'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Missing index statement]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing index statement'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing index statement'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing index statement'') + ''
				AS
			'';
			SET @stmt += ''
				SELECT
					CASE
						WHEN LEN(mis.Statement) > '' + CAST(@maxStatementLength AS nvarchar) + '' THEN LEFT(mis.Statement, '' + CAST(@maxStatementLength AS nvarchar) + '') + CHAR(10) + ''''...Statement truncated''''
						ELSE mis.Statement
					END AS Statement
					,(SELECT k.[Key] FROM FHSQLMonitor.dbo.fhsmFNGenerateKey(mis.DatabaseName, CONVERT(nvarchar(18), mis.QueryHash, 1), DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS MissingIndexStatementKey
				FROM dbo.fhsmMissingIndexStatement AS mis;
				'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Missing index statement]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Missing index statement'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPMissingIndexes
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPMissingIndexes'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPMissingIndexes AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPMissingIndexes (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();
			'';
			IF (@productVersion1 <= 14)
			BEGIN
				-- SQL Versions SQL2017 or lower

				SET @stmt += ''
						SET @stmt = ''''
							SELECT
								PARSENAME(mid.statement, 3) AS DatabaseName
								,PARSENAME(mid.statement, 2) AS SchemaName
								,PARSENAME(mid.statement, 1) AS ObjectName
								,CAST(NULL AS binary(8)) AS QueryHash
								,CAST(NULL AS nvarchar(max)) AS Statement
								,mid.equality_columns AS EqualityColumns
								,mid.inequality_columns AS InequalityColumns
								,mid.included_columns AS IncludedColumns
								,SUM(migs.unique_compiles) AS UniqueCompiles
								,SUM(migs.user_seeks) AS UserSeeks
								,SUM(migs.user_scans) AS UserScans
								,MAX(migs.last_user_seek) AS LastUserSeek
								,MAX(migs.last_user_scan) AS LastUserScan
								,AVG(migs.avg_total_user_cost) AS AvgTotalUserCost
								,AVG(migs.avg_user_impact) AS AvgUserImpact
								,SUM(migs.system_seeks) AS SystemSeeks
								,SUM(migs.system_scans) AS SystemScans
								,MAX(migs.last_system_seek) AS LastSystemSeek
								,MAX(migs.last_system_scan) AS LastSystemScan
								,AVG(migs.avg_total_system_cost) AS AvgTotalSystemCost
								,AVG(migs.avg_system_impact) AS AvgSystemImpact
								,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
								,@nowUTC, @now
							FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
							INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK) ON (mig.index_group_handle = migs.group_handle)
							INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK) ON (mid.index_handle = mig.index_handle)
							GROUP BY
								mid.statement
								,mid.equality_columns
								,mid.inequality_columns
								,mid.included_columns
				'';
			END
			ELSE BEGIN
				SET @stmt += ''
						SET @stmt = ''''
							SELECT
								PARSENAME(mid.statement, 3) AS DatabaseName
								,PARSENAME(mid.statement, 2) AS SchemaName
								,PARSENAME(mid.statement, 1) AS ObjectName
								,migsq.query_hash AS QueryHash
								,MAX(SUBSTRING(
									dest.text,
									migsq.last_statement_start_offset / 2 + 1,
									(CASE migsq.last_statement_start_offset
										WHEN -1 THEN DATALENGTH(dest.text)
										ELSE migsq.last_statement_end_offset
									END - migsq.last_statement_start_offset) / 2 + 1
								)) AS Statement
								,mid.equality_columns AS EqualityColumns
								,mid.inequality_columns AS InequalityColumns
								,mid.included_columns AS IncludedColumns
								,NULL AS UniqueCompiles
								,SUM(migsq.user_seeks) AS UserSeeks
								,SUM(migsq.user_scans) AS UserScans
								,MAX(migsq.last_user_seek) AS LastUserSeek
								,MAX(migsq.last_user_scan) AS LastUserScan
								,AVG(migsq.avg_total_user_cost) AS AvgTotalUserCost
								,AVG(migsq.avg_user_impact) AS AvgUserImpact
								,SUM(migsq.system_seeks) AS SystemSeeks
								,SUM(migsq.system_scans) AS SystemScans
								,MAX(migsq.last_system_seek) AS LastSystemSeek
								,MAX(migsq.last_system_scan) AS LastSystemScan
								,AVG(migsq.avg_total_system_cost) AS AvgTotalSystemCost
								,AVG(migsq.avg_system_impact) AS AvgSystemImpact
								,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
								,@nowUTC, @now
							FROM sys.dm_db_missing_index_group_stats_query AS migsq WITH (NOLOCK)
							INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK) ON (mig.index_group_handle = migsq.group_handle)
							INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK) ON (mid.index_handle = mig.index_handle)
							OUTER APPLY sys.dm_exec_sql_text(migsq.last_sql_handle) AS dest
							GROUP BY
								mid.statement
								,migsq.query_hash
								,mid.equality_columns
								,mid.inequality_columns
								,mid.included_columns
				'';
			END

			SET @stmt += ''
							UNION ALL

							SELECT
								''''''''<HeartBeat>'''''''' AS DatabaseName
								,''''''''<HeartBeat>'''''''' AS SchemaName
								,''''''''<HeartBeat>'''''''' AS ObjectName
								,NULL AS QueryHash
								,NULL AS Statement
								,NULL AS EqualityColumns
								,NULL AS InequalityColumns
								,NULL AS IncludedColumns
								,NULL AS UniqueCompiles
								,-1 AS UserSeeks
								,-1 AS UserScans
								,NULL AS LastUserSeek
								,NULL AS LastUserScan
								,-1 AS AvgTotalUserCost
								,-1 AS AvgUserImpact
								,-1 AS SystemSeeks
								,-1 AS SystemScans
								,NULL AS LastSystemSeek
								,NULL AS LastSystemScan
								,-1 AS AvgTotalSystemCost
								,-1 AS AvgSystemImpact
								,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
								,@nowUTC, @now
						'''';
				'';
				SET @stmt += ''
						TRUNCATE TABLE dbo.fhsmMissingIndexesTemp;

						INSERT INTO dbo.fhsmMissingIndexesTemp(
							DatabaseName, SchemaName, ObjectName
							,QueryHash, Statement
							,EqualityColumns, InequalityColumns, IncludedColumns
							,UniqueCompiles
							,UserSeeks, UserScans
							,LastUserSeek, LastUserScan
							,AvgTotalUserCost, AvgUserImpact
							,SystemSeeks, SystemScans
							,LastSystemSeek, LastSystemScan
							,AvgTotalSystemCost, AvgSystemImpact
							,LastSQLServiceRestart
							,TimestampUTC, Timestamp
						)
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now, @nowUTC = @nowUTC;
				'';
				SET @stmt += ''
						INSERT INTO dbo.fhsmMissingIndexes(
							DatabaseName, SchemaName, ObjectName
							,QueryHash
							,EqualityColumns, InequalityColumns, IncludedColumns
							,UniqueCompiles
							,UserSeeks, UserScans
							,LastUserSeek, LastUserScan
							,AvgTotalUserCost, AvgUserImpact
							,SystemSeeks, SystemScans
							,LastSystemSeek, LastSystemScan
							,AvgTotalSystemCost, AvgSystemImpact
							,LastSQLServiceRestart
							,TimestampUTC, Timestamp
						)
						SELECT
							DatabaseName, SchemaName, ObjectName
							,QueryHash
							,EqualityColumns, InequalityColumns, IncludedColumns
							,UniqueCompiles
							,UserSeeks, UserScans
							,LastUserSeek, LastUserScan
							,AvgTotalUserCost, AvgUserImpact
							,SystemSeeks, SystemScans
							,LastSystemSeek, LastSystemScan
							,AvgTotalSystemCost, AvgSystemImpact
							,LastSQLServiceRestart
							,TimestampUTC, Timestamp
						FROM dbo.fhsmMissingIndexesTemp;
				'';
				SET @stmt += ''
						--
						-- Insert records into fhsmMissingIndexStatement
						--
						BEGIN
							MERGE dbo.fhsmMissingIndexStatement AS tgt
							USING (
								SELECT
									t.DatabaseName
									,t.QueryHash
									,MAX(t.Statement) AS Statement
								FROM dbo.fhsmMissingIndexesTemp AS t
								WHERE (t.QueryHash IS NOT NULL) AND (t.Statement IS NOT NULL)
								GROUP BY
									t.DatabaseName
									,t.QueryHash
							) AS src
							ON (src.DatabaseName = tgt.DatabaseName) AND (src.QueryHash = tgt.QueryHash)
							WHEN MATCHED AND (src.Statement <> tgt.Statement)
								THEN UPDATE SET
									tgt.UpdateCount = tgt.UpdateCount + 1
									,tgt.PrevStatement = tgt.Statement
									,tgt.Statement = src.Statement
							WHEN NOT MATCHED BY TARGET
								THEN INSERT(DatabaseName, QueryHash, Statement, UpdateCount)
								VALUES(src.DatabaseName, src.QueryHash, src.Statement, 0)
							;
						END;
				'';
				SET @stmt += ''
						--
						-- Delete records from fhsmMissingIndexStatement where no owner in fhsmMissingIndexes exists
						--
						BEGIN
							DELETE miStmt
							FROM dbo.fhsmMissingIndexStatement AS miStmt
							WHERE NOT EXISTS (
								SELECT *
								FROM dbo.fhsmMissingIndexes AS mi
								WHERE (mi.DatabaseName = miStmt.DatabaseName) AND (mi.QueryHash = miStmt.QueryHash)
							);
						END;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPMissingIndexes
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPMissingIndexes'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmMissingIndexes''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableMissingIndexes							AS Enabled
				,0												AS DeploymentStatus
				,''Missing indexes''								AS Name
				,PARSENAME(''dbo.fhsmSPMissingIndexes'', 1)		AS Task
				,1 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3
			,OutputColumn1, OutputColumn2, OutputColumn3
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmMissingIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE ((src.DatabaseName <> ''''<HeartBeat>'''') OR (src.SchemaName <> ''''<HeartBeat>'''') OR (src.ObjectName <> ''''<HeartBeat>''''))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL
				,''Database'', NULL, NULL

			UNION ALL

			SELECT
				''Schema'' AS DimensionName
				,''SchemaKey'' AS DimensionKey
				,''dbo.fhsmMissingIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE ((src.DatabaseName <> ''''<HeartBeat>'''') OR (src.SchemaName <> ''''<HeartBeat>'''') OR (src.ObjectName <> ''''<HeartBeat>''''))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', NULL
				,''Database'', ''Schema'', NULL

			UNION ALL

			SELECT
				''Object'' AS DimensionName
				,''ObjectKey'' AS DimensionKey
				,''dbo.fhsmMissingIndexes'' AS SrcTable
				,''src'' AS SrcAlias
				,''WHERE ((src.DatabaseName <> ''''<HeartBeat>'''') OR (src.SchemaName <> ''''<HeartBeat>'''') OR (src.ObjectName <> ''''<HeartBeat>''''))'' AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''src.[SchemaName]'', ''src.[ObjectName]''
				,''Database'', ''Schema'', ''Object''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3
				,OutputColumn1, OutputColumn2, OutputColumn3
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmMissingIndexes'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:PerformanceStatistics.sql modified: 2025.08.05 19.12.06
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enablePerformanceStatistics bit;

	SET @enablePerformanceStatistics = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing PerformanceStatistics'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @fhsmPerfmonCounters TABLE(
		ObjectName nvarchar(128) NOT NULL
		,CounterName nvarchar(128) NOT NULL
		,InstanceName nvarchar(128) NULL
	);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @serviceName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmPerfmonCounters and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmPerfmonCounters'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmPerfmonCounters'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmPerfmonCounters(
					Id int identity(1,1)
					,ObjectName nvarchar(128) NOT NULL
					,CounterName nvarchar(128) NOT NULL
					,InstanceName nvarchar(128) NULL
					,CONSTRAINT PK_fhsmPerfmonCounters PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPerfmonCounters'')) AND (i.name = ''NC_fhsmPerfmonCounters_ObjectName_CounterName_InstanceName_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPerfmonCounters_ObjectName_CounterName_InstanceName_TimestampUTC] to table dbo.fhsmPerfmonCounters'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPerfmonCounters_ObjectName_CounterName_InstanceName_TimestampUTC ON dbo.fhsmPerfmonCounters(ObjectName, CounterName, InstanceName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmPerfmonCounters
		--
		BEGIN
			SET @objectName = ''dbo.fhsmPerfmonCounters'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmPerfmonStatistics and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmPerfmonStatistics'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmPerfmonStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmPerfmonStatistics(
					Id int identity(1,1)
					,ObjectName nvarchar(128) NOT NULL
					,CounterName nvarchar(128) NOT NULL
					,InstanceName nvarchar(128) NOT NULL
					,CounterValue bigint NOT NULL
					,CounterType int NOT NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmPerfmonStatistics PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPerfmonStatistics'')) AND (i.name = ''NC_fhsmPerfmonStatistics_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPerfmonStatistics_TimestampUTC] to table dbo.fhsmPerfmonStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPerfmonStatistics_TimestampUTC ON dbo.fhsmPerfmonStatistics(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPerfmonStatistics'')) AND (i.name = ''NC_fhsmPerfmonStatistics_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPerfmonStatistics_Timestamp] to table dbo.fhsmPerfmonStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPerfmonStatistics_Timestamp ON dbo.fhsmPerfmonStatistics(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPerfmonStatistics'')) AND (i.name = ''NC_fhsmPerfmonStatistics_ObjectName_CounterName_InstanceName_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPerfmonStatistics_ObjectName_CounterName_InstanceName_TimestampUTC] to table dbo.fhsmPerfmonStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPerfmonStatistics_ObjectName_CounterName_InstanceName_TimestampUTC ON dbo.fhsmPerfmonStatistics(ObjectName, CounterName, InstanceName, TimestampUTC) INCLUDE(CounterValue)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmPerfmonStatistics
		--
		BEGIN
			SET @objectName = ''dbo.fhsmPerfmonStatistics'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Add default perfmon counters if they dont exists
	--
	BEGIN
		SET @serviceName = CASE WHEN @@SERVICENAME = ''MSSQLSERVER'' THEN ''SQLServer'' ELSE ''MSSQL$'' + @@SERVICENAME END;

		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Forwarded Records/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Page compression attempts/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Page Splits/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Skipped Ghosted Records/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Table Lock Escalations/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Worktables Created/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Group'', ''Active Hadr Threads'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Bytes Received from Replica/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Bytes Sent to Replica/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Bytes Sent to Transport/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Flow Control Time (ms/sec)'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Flow Control/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Resent Messages/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Availability Replica'', ''Sends to Replica/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Page life expectancy'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Page reads/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Page writes/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Readahead pages/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Target pages'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Total pages'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', '''', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Active Transactions'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Database Flow Control Delay'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Database Flow Controls/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Group Commit Time'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Group Commits/Sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Log Apply Pending Queue'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Log Apply Ready Queue'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Log Compression Cache misses/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Log remaining for undo'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Log Send Queue'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Recovery Queue'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Redo blocked/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Redo Bytes Remaining'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Database Replica'', ''Redone Bytes/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''Log Bytes Flushed/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''Log Growths'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''Log Pool LogWriter Pushes/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''Log Shrinks'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''Transactions/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''Write Transactions/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Databases'', ''XTP Memory Used (KB)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Exec Statistics'', ''Distributed Query'', ''Execs in progress'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Exec Statistics'', ''DTC calls'', ''Execs in progress'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Exec Statistics'', ''Extended Procedures'', ''Execs in progress'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Exec Statistics'', ''OLEDB calls'', ''Execs in progress'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':General Statistics'', ''Active Temp Tables'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':General Statistics'', ''Logins/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':General Statistics'', ''Logouts/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':General Statistics'', ''Mars Deadlocks'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':General Statistics'', ''Processes blocked'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Number of Deadlocks/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Memory Manager'', ''Memory Grants Pending'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Errors'', ''Errors/sec'', ''_Total'');
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Batch Requests/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Forced Parameterizations/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Guided plan executions/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''SQL Attention rate'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''SQL Compilations/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''SQL Re-Compilations/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Workload Group Stats'', ''Query optimizations/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Workload Group Stats'', ''Suboptimal plans/sec'', NULL);
		/* Below counters added by Jefferson Elias */
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Worktables From Cache Base'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Worktables From Cache Ratio'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Database pages'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Free pages'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Stolen pages'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Memory Manager'', ''Granted Workspace Memory (KB)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Memory Manager'', ''Maximum Workspace Memory (KB)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Memory Manager'', ''Target Server Memory (KB)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Memory Manager'', ''Total Server Memory (KB)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Buffer cache hit ratio'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Buffer cache hit ratio base'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Checkpoint pages/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Free list stalls/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Lazy writes/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Auto-Param Attempts/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Failed Auto-Params/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Safe Auto-Params/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':SQL Statistics'', ''Unsafe Auto-Params/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Workfiles Created/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':General Statistics'', ''User Connections'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Latches'', ''Average Latch Wait Time (ms)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Latches'', ''Average Latch Wait Time Base'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Latches'', ''Latch Waits/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Latches'', ''Total Latch Wait Time (ms)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Average Wait Time (ms)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Average Wait Time Base'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Lock Requests/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Lock Timeouts/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Lock Wait Time (ms)'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Locks'', ''Lock Waits/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Transactions'', ''Longest Transaction Running Time'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Full Scans/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Access Methods'', ''Index Searches/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Manager'', ''Page lookups/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Cursor Manager by Type'', ''Active cursors'', NULL);
		/* Below counters are for In-Memory OLTP (Hekaton), which have a different naming convention.
			And yes, they actually hard-coded the version numbers into the counters, and SQL 2019 still says 2017, oddly.
			For why, see: https://connect.microsoft.com/SQLServer/feedback/details/817216/xtp-perfmon-counters-should-appear-under-sql-server-perfmon-counter-group
		*/
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Cursors'', ''Expired rows removed/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Cursors'', ''Expired rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Garbage Collection'', ''Rows processed/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP IO Governor'', ''Io Issued/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Phantom Processor'', ''Phantom expired rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Phantom Processor'', ''Phantom rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Transaction Log'', ''Log bytes written/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Transaction Log'', ''Log records written/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Transactions'', ''Transactions aborted by user/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Transactions'', ''Transactions aborted/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2014 XTP Transactions'', ''Transactions created/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Cursors'', ''Expired rows removed/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Cursors'', ''Expired rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Garbage Collection'', ''Rows processed/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP IO Governor'', ''Io Issued/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Phantom Processor'', ''Phantom expired rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Phantom Processor'', ''Phantom rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Transaction Log'', ''Log bytes written/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Transaction Log'', ''Log records written/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Transactions'', ''Transactions aborted by user/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Transactions'', ''Transactions aborted/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2016 XTP Transactions'', ''Transactions created/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Cursors'', ''Expired rows removed/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Cursors'', ''Expired rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Garbage Collection'', ''Rows processed/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP IO Governor'', ''Io Issued/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Phantom Processor'', ''Phantom expired rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Phantom Processor'', ''Phantom rows touched/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Transaction Log'', ''Log bytes written/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Transaction Log'', ''Log records written/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Transactions'', ''Transactions aborted by user/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Transactions'', ''Transactions aborted/sec'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES (''SQL Server 2017 XTP Transactions'', ''Transactions created/sec'', NULL);
		/* Added by Flemming Haurum */
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Buffer Node'', ''Page life expectancy'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Resource Pool Stats'', ''CPU usage %'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Resource Pool Stats'', ''CPU usage % base'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Workload Group Stats'', ''CPU usage %'', NULL);
		INSERT INTO @fhsmPerfmonCounters(ObjectName, CounterName, InstanceName) VALUES(@serviceName + '':Workload Group Stats'', ''CPU usage % base'', NULL);

		MERGE dbo.fhsmPerfmonCounters AS tgt
		USING @fhsmPerfmonCounters AS src ON (src.ObjectName = tgt.ObjectName) AND (src.CounterName = tgt.CounterName) AND ((src.InstanceName = tgt.InstanceName) OR ((src.InstanceName IS NULL) AND (tgt.InstanceName IS NULL)))
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(ObjectName, CounterName, InstanceName)
			VALUES(src.ObjectName, src.CounterName, src.InstanceName);
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create helper view dbo.fhsmPerformStatisticsActual
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmPerformStatisticsActual'''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW dbo.fhsmPerformStatisticsActual AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW dbo.fhsmPerformStatisticsActual
				AS
					WITH
					rowDates AS (
						SELECT
							DISTINCT
							TimestampUTC
						FROM dbo.fhsmPerfmonStatistics
					)
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
					,rankedRowDates AS (
						SELECT
							thisDate.TimestampUTC
							,ROW_NUMBER() OVER(ORDER BY thisDate.TimestampUTC) AS Idx
						FROM rowDates AS thisDate
					)
				'';
			END;
			SET @stmt += ''
					,checkDates AS (
						SELECT
							a.TimestampUTC
							,a.PreviousTimestampUTC
						FROM (
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
							SELECT
								thisDate.TimestampUTC
								,prevDate.TimestampUTC AS PreviousTimestampUTC
							FROM rankedRowDates AS thisDate
							LEFT OUTER JOIN rankedRowDates AS prevDate ON
								(prevDate.Idx = thisDate.Idx - 1)
				'';
			END
			ELSE BEGIN
				-- SQL Versions SQL2012 or higher

				SET @stmt += ''
							SELECT
								thisDate.TimestampUTC
								,LAG(thisDate.TimestampUTC) OVER(ORDER BY thisDate.TimestampUTC) AS PreviousTimestampUTC
							FROM rowDates AS thisDate
				'';
			END;
			SET @stmt += ''
						) AS a
						WHERE (a.PreviousTimestampUTC IS NOT NULL)
					)
					,PerfmonDeltas AS (
						SELECT
							pMon.ObjectName
							,pMon.CounterName
							,pMon.InstanceName
							,DATEDIFF(SECOND, pMonPrior.TimestampUTC, pMon.TimestampUTC) AS ElapsedSeconds
							,pMon.CounterValue
							,pMon.CounterType
							,(pMon.CounterValue - pMonPrior.CounterValue) AS CounterDelta
							,(pMon.CounterValue - pMonPrior.CounterValue) * 1.0 / DATEDIFF(SECOND, pMonPrior.TimestampUTC, pMon.TimestampUTC) AS CounterDeltaPerSecond
							,pMon.TimestampUTC
							,pMon.Timestamp
						FROM dbo.fhsmPerfmonStatistics AS pMon
						INNER HASH JOIN checkDates AS dates ON (dates.TimestampUTC = pMon.TimestampUTC)
						INNER JOIN dbo.fhsmPerfmonStatistics AS pMonPrior
							ON (pMonPrior.TimestampUTC = dates.PreviousTimestampUTC)
							AND (pMonPrior.ObjectName = pMon.ObjectName)
							AND (pMonPrior.CounterName = pMon.CounterName)
							AND (pMonPrior.InstanceName = pMon.InstanceName)
						WHERE DATEDIFF(MINUTE, dates.PreviousTimestampUTC, dates.TimestampUTC) BETWEEN 1 AND 60
					)
					,PerfAverageBulk AS (
						SELECT
							ObjectName
							,InstanceName
							,CounterName
							,CASE WHEN (CHARINDEX(''''('''', CounterName) = 0) THEN CounterName ELSE LEFT(CounterName, CHARINDEX(''''('''', CounterName) - 1) END AS CounterJoin
							,CounterDelta
							,TimestampUTC
							,Timestamp
						FROM PerfmonDeltas
						WHERE (CounterType IN (1073874176))
					)
					,PerfLargeRawBase AS (
						SELECT
							ObjectName
							,InstanceName
							,LEFT(CounterName, CHARINDEX(''''BASE'''', UPPER(CounterName)) - 1) AS CounterJoin
							,CounterValue
							,TimestampUTC
							,Timestamp
						FROM PerfmonDeltas
						WHERE (CounterType IN (1073939712))
					)
					,PerfLargeRawFraction AS (
						SELECT
							ObjectName
							,InstanceName
							,CounterName
							,CounterName AS CounterJoin
							,CounterValue
							,TimestampUTC
							,Timestamp
						FROM PerfmonDeltas
						WHERE (CounterType IN (537003264))
					)
					,PerfCounterBulkCount AS (
						SELECT
							ObjectName
							,InstanceName
							,CounterName
							,CounterDelta / ElapsedSeconds AS CounterValue
							,TimestampUTC
							,Timestamp
						FROM PerfmonDeltas
						WHERE (CounterType IN (272696576, 272696320))
					)
					,PerfCounterRawCount AS (
						SELECT
							ObjectName
							,InstanceName
							,CounterName
							,CounterValue
							,TimestampUTC
							,Timestamp
						FROM PerfmonDeltas
						WHERE (CounterType IN (65792, 65536))
					)
			'';
			SET @stmt += ''
					,AllData AS (
						SELECT
							num.ObjectName
							,num.CounterName
							,num.InstanceName
							,num.CounterDelta / den.CounterValue AS CounterValue
							,num.TimestampUTC
							,num.Timestamp
						FROM PerfAverageBulk AS num
						INNER JOIN PerfLargeRawBase AS den
							ON (den.CounterJoin = num.CounterJoin)
							AND (den.TimestampUTC = num.TimestampUTC)
							AND (den.ObjectName = num.ObjectName)
							AND (den.InstanceName = num.InstanceName)
							AND (den.CounterValue <> 0)

						UNION ALL

						SELECT
							num.ObjectName
							,num.CounterName
							,num.InstanceName
							,CAST((CAST(num.CounterValue AS decimal(19)) / den.CounterValue) AS decimal(23,3)) AS CounterValue
							,num.TimestampUTC
							,num.Timestamp
						FROM PerfLargeRawFraction AS num
						INNER JOIN PerfLargeRawBase AS den
							ON (1=1)
							AND (den.CounterJoin = num.CounterJoin)
							AND (den.TimestampUTC = num.TimestampUTC)
							AND (den.ObjectName = num.ObjectName)
							AND (den.InstanceName = num.InstanceName)
							AND (den.CounterValue <> 0)

						UNION ALL

						SELECT
							ObjectName
							,CounterName
							,InstanceName
							,CounterValue
							,TimestampUTC
							,Timestamp
						FROM PerfCounterBulkCount

						UNION ALL

						SELECT
							ObjectName
							,CounterName
							,InstanceName
							,CounterValue
							,TimestampUTC
							,Timestamp
						FROM PerfCounterRawCount
					)
					SELECT
						a.ObjectName
						,a.CounterName
						,a.InstanceName
						,CASE WHEN (a.CounterValue >= 0) THEN a.CounterValue ELSE NULL END AS CounterValue
						,a.TimestampUTC
						,a.Timestamp
					FROM AllData AS a;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view dbo.fhsmPerformStatisticsActual
		--
		BEGIN
			SET @objectName = ''dbo.fhsmPerformStatisticsActual'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Performance statistics]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Performance statistics'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Performance statistics'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Performance statistics'') + ''
				AS
				SELECT
					psa.CounterValue
					,psa.Timestamp
					,CAST(psa.Timestamp AS date) AS Date
					,(DATEPART(HOUR, psa.Timestamp) * 60 * 60) + (DATEPART(MINUTE, psa.Timestamp) * 60) + (DATEPART(SECOND, psa.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(psa.ObjectName, psa.CounterName, psa.InstanceName, DEFAULT, DEFAULT, DEFAULT) AS k) AS PerfmonKey
				FROM dbo.fhsmPerformStatisticsActual AS psa
				WHERE (
					   ((psa.ObjectName LIKE ''''%:Availability Replica'''') AND (psa.CounterName = ''''Bytes Received from Replica/sec''''))
					OR ((psa.ObjectName LIKE ''''%:Availability Replica'''') AND (psa.CounterName = ''''Bytes Sent to Replica/sec''''))
					OR ((psa.ObjectName LIKE ''''%:Availability Replica'''') AND (psa.CounterName = ''''Bytes Sent to Transport/sec''''))
					OR ((psa.ObjectName LIKE ''''%:Buffer Manager'''')       AND (psa.CounterName = ''''Page life expectancy''''))
					OR ((psa.ObjectName LIKE ''''%:Buffer Node'''')          AND (psa.CounterName = ''''Page life expectancy''''))
					OR ((psa.ObjectName LIKE ''''%:SQL Statistics'''')       AND (psa.CounterName = ''''Batch Requests/sec''''))
					OR ((psa.ObjectName LIKE ''''%:SQL Statistics'''')       AND (psa.CounterName = ''''SQL Compilations/sec''''))
					OR ((psa.ObjectName LIKE ''''%:Resource Pool Stats'''')  AND (psa.CounterName = ''''CPU usage %''''))
					OR ((psa.ObjectName LIKE ''''%:Workload Group Stats'''') AND (psa.CounterName = ''''CPU usage %''''))
				)
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Performance statistics]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Performance statistics'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPPerfmonStatistics
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPPerfmonStatistics'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPPerfmonStatistics AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPPerfmonStatistics (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						SET @stmt = ''''
							SELECT
								RTRIM(dopc.object_name) AS ObjectName
								,RTRIM(dopc.counter_name) AS CounterName
								,RTRIM(dopc.instance_name) AS InstanceName
								,dopc.cntr_value AS CounterValue
								,dopc.cntr_type AS CounterType
								,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
								,@nowUTC, @now
							FROM dbo.fhsmPerfmonCounters AS pc
							INNER JOIN sys.dm_os_performance_counters AS dopc WITH (NOLOCK)
								ON (RTRIM(dopc.counter_name) COLLATE DATABASE_DEFAULT = pc.CounterName)
								AND (RTRIM(dopc.[object_name]) COLLATE DATABASE_DEFAULT = pc.ObjectName)
								AND (
									(pc.InstanceName IS NULL)
									OR (RTRIM(dopc.[instance_name]) COLLATE DATABASE_DEFAULT = pc.InstanceName)
								);
						'''';
						INSERT INTO dbo.fhsmPerfmonStatistics(
							ObjectName, CounterName, InstanceName
							,CounterValue, CounterType
							,LastSQLServiceRestart
							,TimestampUTC, Timestamp
						)
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now, @nowUTC = @nowUTC;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPPerfmonStatistics
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPPerfmonStatistics'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmPerfmonStatistics''
				,1
				,''TimestampUTC''
				,1
				,60
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enablePerformanceStatistics					AS Enabled
				,0												AS DeploymentStatus
				,''Performance statistics''						AS Name
				,PARSENAME(''dbo.fhsmSPPerfmonStatistics'', 1)	AS Task
				,5 * 60											AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3
			,OutputColumn1, OutputColumn2, OutputColumn3
		) AS (
			SELECT
				''Performance counter'' AS DimensionName
				,''PerfmonKey'' AS DimensionKey
				,''dbo.fhsmPerfmonStatistics'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[ObjectName]'', ''src.[CounterName]'', ''src.[InstanceName]''
				,''Object'', ''Counter'', ''Instance''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3
				,OutputColumn1, OutputColumn2, OutputColumn3
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmPerfmonStatistics'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:PlanCacheUsage.sql modified: 2025.08.05 19.12.21
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enablePlanCacheUsage bit;

	SET @enablePlanCacheUsage = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing PlanCacheUsage'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmPlanCacheUsage and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmPlanCacheUsage'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmPlanCacheUsage'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmPlanCacheUsage(
					Id int identity(1,1) NOT NULL
					,ObjectType nvarchar(16) NOT NULL
					,CacheSize bigint NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmPlanCacheUsage PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPlanCacheUsage'')) AND (i.name = ''NC_fhsmPlanCacheUsage_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPlanCacheUsage_TimestampUTC] to table dbo.fhsmPlanCacheUsage'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPlanCacheUsage_TimestampUTC ON dbo.fhsmPlanCacheUsage(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPlanCacheUsage'')) AND (i.name = ''NC_fhsmPlanCacheUsage_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPlanCacheUsage_Timestamp] to table dbo.fhsmPlanCacheUsage'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPlanCacheUsage_Timestamp ON dbo.fhsmPlanCacheUsage(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmPlanCacheUsage
		--
		BEGIN
			SET @objectName = ''dbo.fhsmPlanCacheUsage'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Plan cache usage]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan cache usage'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan cache usage'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan cache usage'') + ''
				AS
				SELECT
					pcu.ObjectType
					,(pcu.CacheSize / 1048576.0) AS CacheSize_MB
					,pcu.Timestamp
					,CAST(pcu.Timestamp AS date) AS Date
					,(DATEPART(HOUR, pcu.Timestamp) * 60 * 60) + (DATEPART(MINUTE, pcu.Timestamp) * 60) + (DATEPART(SECOND, pcu.Timestamp)) AS TimeKey
				FROM dbo.fhsmPlanCacheUsage AS pcu;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Plan cache usage]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan cache usage'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPPlanCacheUsage
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPPlanCacheUsage'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPPlanCacheUsage AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPPlanCacheUsage (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;
			'';
			SET @stmt += ''

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						INSERT INTO dbo.fhsmPlanCacheUsage(ObjectType, CacheSize, TimestampUTC, Timestamp)
						SELECT
							decp.objtype AS ObjectType
							,SUM(CAST(decp.size_in_bytes AS bigint)) AS CacheSize
							,@nowUTC AS TimestampUTC
							,@now AS Timestamp
						FROM sys.dm_exec_cached_plans AS decp
						GROUP BY decp.objtype;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPPlanCacheUsage
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPPlanCacheUsage'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmPlanCacheUsage''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enablePlanCacheUsage							AS Enabled
				,0												AS DeploymentStatus
				,''Plan cache usage''								AS Name
				,PARSENAME(''dbo.fhsmSPPlanCacheUsage'', 1)		AS Task
				,5 * 60											AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmPlanCacheUsage'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:PlanGuides.sql modified: 2025.08.05 19.12.37
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enablePlanGuides bit;

	SET @enablePlanGuides = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing PlanGuides'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmPlanGuides and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmPlanGuides'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmPlanGuides'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmPlanGuides(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,PlanGuideId int NOT NULL
					,Name nvarchar(128) NOT NULL
					,CreateDate datetime NOT NULL
					,ModifyDate datetime NOT NULL
					,IsDisabled bit NOT NULL
					,QueryText nvarchar(max) NULL
					,ScopeTypeDesc nvarchar(60) NULL
					,ScopedSchema nvarchar(128) NULL
					,ScopedObject nvarchar(128) NULL
					,ScopeBatch nvarchar(max) NULL
					,Parameters nvarchar(max) NULL
					,Hints nvarchar(max) NULL
					,MsgNum int NULL
					,Severity tinyint NULL
					,State smallint NULL
					,Message nvarchar(1024) NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmPlanGuides PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPlanGuides'')) AND (i.name = ''NC_fhsmPlanGuides_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPlanGuides_TimestampUTC] to table dbo.fhsmPlanGuides'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPlanGuides_TimestampUTC ON dbo.fhsmPlanGuides(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPlanGuides'')) AND (i.name = ''NC_fhsmPlanGuides_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPlanGuides_Timestamp] to table dbo.fhsmPlanGuides'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPlanGuides_Timestamp ON dbo.fhsmPlanGuides(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmPlanGuides'')) AND (i.name = ''NC_fhsmPlanGuides_DatabaseName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmPlanGuides_DatabaseName] to table dbo.fhsmPlanGuides'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmPlanGuides_DatabaseName ON dbo.fhsmPlanGuides(DatabaseName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmPlanGuides
		--
		BEGIN
			SET @objectName = ''dbo.fhsmPlanGuides'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Plan guides]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan guides'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan guides'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan guides'') + ''
				AS
				SELECT
					pg.PlanGuideId
					,pg.Name
					,pg.CreateDate
					,pg.ModifyDate
					,pg.IsDisabled
					,pg.QueryText
					,pg.ScopeTypeDesc
					,QUOTENAME(pg.ScopedSchema) + ''''.'''' + QUOTENAME(ScopedObject) AS ScopedObject
					,pg.ScopeBatch
					,pg.Parameters
					,pg.Hints
					,pg.MsgNum
					,pg.Severity
					,pg.State
					,pg.Message
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(pg.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
				FROM dbo.fhsmPlanGuides AS pg
				WHERE (pg.TimestampUTC = (
					SELECT TOP (1) pg2.TimestampUTC
					FROM dbo.fhsmPlanGuides AS pg2
					ORDER BY pg2.TimestampUTC DESC
				))
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Plan guides]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Plan guides'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPPlanGuides
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPPlanGuides'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPPlanGuides AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPPlanGuides (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;
					END;
			'';
			SET @stmt += ''

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;
			'';
			SET @stmt += ''

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + '''';

									SELECT
										DB_NAME() AS DatabaseName
										,pg.plan_guide_id AS PlanGuideId
										,pg.name AS Name
										,pg.create_date AS CreateDate
										,pg.modify_date AS ModifyDate
										,pg.is_disabled AS IsDisabled
										,pg.query_text AS QueryText
										,pg.scope_type_desc AS ScopeTypeDesc
										,sch.name AS ScopedSchema
										,o.name AS ScopedObject
										,pg.scope_batch AS ScopeBatch
										,pg.parameters AS Parameters
										,pg.hints AS Hints
										,vpg.msgnum AS MsgNum
										,vpg.severity AS Severity
										,vpg.state AS State
										,vpg.message AS Message
										,@nowUTC, @now
									FROM sys.plan_guides AS pg
									LEFT OUTER JOIN sys.objects AS o ON (o.object_id = pg.scope_object_id)
									LEFT OUTER JOIN sys.schemas AS sch ON (sch.schema_id = o.schema_id)
									OUTER APPLY sys.fn_validate_plan_guide(pg.plan_guide_id) AS vpg
								'''';
								BEGIN TRY
									INSERT INTO dbo.fhsmPlanGuides(
										DatabaseName
										,PlanGuideId, Name
										,CreateDate, ModifyDate
										,IsDisabled, QueryText, ScopeTypeDesc
										,ScopedSchema, ScopedObject
										,ScopeBatch, Parameters, Hints
										,MsgNum, Severity, State, Message
										,TimestampUTC, Timestamp
									)
									EXEC sp_executesql
										@stmt
										,N''''@now datetime, @nowUTC datetime''''
										,@now = @now, @nowUTC = @nowUTC;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPPlanGuides
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPPlanGuides'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlPlanGuides
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlPlanGuides'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlPlanGuides AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlPlanGuides (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlPlanGuides
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlPlanGuides'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmPlanGuides''
				,1
				,''TimestampUTC''
				,1
				,90
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enablePlanGuides								AS Enabled
				,0												AS DeploymentStatus
				,''Plan guides''									AS Name
				,PARSENAME(''dbo.fhsmSPPlanGuides'', 1)			AS Task
				,1 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb''''''		AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmPlanGuides'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmPlanGuides'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:QueryStatistics.sql modified: 2025.08.05 19.12.52
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableQueryStatistics bit;

	SET @enableQueryStatistics = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing QueryStatistics'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Variables used in view to control the statement output
	--
	BEGIN
		DECLARE @maxStatementLength int;

		SET @maxStatementLength = 1024;
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmQueryStatement and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmQueryStatement'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmQueryStatement'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmQueryStatement(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NULL
					,QueryHash binary(8) NULL
					--,PlanHandle varbinary(64) NOT NULL
					,CreationTime datetime NOT NULL
					,LastExecutionTime datetime NOT NULL
					,Statement nvarchar(max) NULL
					,Encrypted bit NULL
					,QueryPlan xml NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmQueryStatement PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmQueryStatement'')) AND (i.name = ''NC_fhsmQueryStatement_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmQueryStatement_TimestampUTC] to table dbo.fhsmQueryStatement'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmQueryStatement_TimestampUTC ON dbo.fhsmQueryStatement(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmQueryStatement'')) AND (i.name = ''NC_fhsmQueryStatement_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmQueryStatement_Timestamp] to table dbo.fhsmQueryStatement'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmQueryStatement_Timestamp ON dbo.fhsmQueryStatement(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmQueryStatement'')) AND (i.name = ''NC_fhsmQueryStatement_ObjectName_CounterName_InstanceName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmQueryStatement_ObjectName_CounterName_InstanceName] to table dbo.fhsmQueryStatement'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmQueryStatement_ObjectName_CounterName_InstanceName ON dbo.fhsmQueryStatement(DatabaseName, QueryHash)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmQueryStatement
		--
		BEGIN
			SET @objectName = ''dbo.fhsmQueryStatement'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmQueryStatistics and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmQueryStatistics'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmQueryStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmQueryStatistics(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NULL
					,QueryHash binary(8) NULL
					,PlanHandle varbinary(64) NOT NULL
					,CreationTime datetime NOT NULL
					,LastExecutionTime datetime NOT NULL
					,ExecutionCount bigint NOT NULL
					,TotalWorkerTimeMS bigint NOT NULL
					,TotalPhysicalReads bigint NOT NULL
					,TotalLogicalWrites bigint NOT NULL
					,TotalLogicalReads bigint NOT NULL
					,TotalClrTimeMS bigint NOT NULL
					,TotalElapsedTimeMS bigint NOT NULL
					,TotalRows bigint NULL
					,TotalSpills bigint NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
				);

				CREATE CLUSTERED INDEX CL_fhsmQueryStatistics_TimestampUTC ON dbo.fhsmQueryStatistics(TimestampUTC)'' + @tableCompressionStmt + '';
				ALTER TABLE dbo.fhsmQueryStatistics ADD CONSTRAINT NCPK_fhsmQueryStatistics PRIMARY KEY NONCLUSTERED(Id)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmQueryStatistics'')) AND (i.name = ''NC_fhsmQueryStatistics_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmQueryStatistics_Timestamp] to table dbo.fhsmQueryStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmQueryStatistics_Timestamp ON dbo.fhsmQueryStatistics(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmQueryStatistics'')) AND (i.name = ''NC_fhsmQueryStatistics_DatabaseName_QueryHash''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmQueryStatistics_DatabaseName_QueryHash] to table dbo.fhsmQueryStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmQueryStatistics_DatabaseName_QueryHash ON dbo.fhsmQueryStatistics(DatabaseName, QueryHash)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmQueryStatistics
		--
		BEGIN
			SET @objectName = ''dbo.fhsmQueryStatistics'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmQueryStatisticsReport if it not already exists
		--
		IF OBJECT_ID(''dbo.fhsmQueryStatisticsReport'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmQueryStatisticsReport'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmQueryStatisticsReport(
					Id int identity(1,1) NOT NULL
					,ExecutionCount bigint NULL
					,WorkerTimeMS bigint NULL
					,PhysicalReads bigint NULL
					,LogicalWrites bigint NULL
					,LogicalReads bigint NULL
					,ClrTimeMS bigint NULL
					,ElapsedTimeMS bigint NULL
					,Rows bigint NULL
					,Spills bigint NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,DatabaseName nvarchar(128) NULL
					,QueryHash binary(8) NOT NULL
					,Date date NOT NULL
					,TimeKey int NOT NULL
					,DatabaseKey bigint NOT NULL
					,QueryStatisticKey bigint NOT NULL
					,CONSTRAINT NCPK_fhsmQueryStatisticsReport PRIMARY KEY NONCLUSTERED(Id)'' + @tableCompressionStmt + ''
				);

				CREATE CLUSTERED INDEX CL_fhsmQueryStatisticsReport ON dbo.fhsmQueryStatisticsReport(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmQueryStatisticsReport
		--
		BEGIN
			SET @objectName = ''dbo.fhsmQueryStatisticsReport'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmQueryStatisticsTemp if it not already exists
		--
		IF OBJECT_ID(''dbo.fhsmQueryStatisticsTemp'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmQueryStatisticsTemp'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmQueryStatisticsTemp(
					DatabaseName nvarchar(128) NULL
					,QueryHash binary(8) NOT NULL
					,PlanHandle varbinary(64) NOT NULL
					,CreationTime datetime NULL
					,LastExecutionTime datetime NULL
					,ExecutionCount bigint NOT NULL
					,TotalWorkerTimeMS bigint NOT NULL
					,TotalPhysicalReads bigint NOT NULL
					,TotalLogicalWrites bigint NOT NULL
					,TotalLogicalReads bigint NOT NULL
					,TotalClrTimeMS bigint NOT NULL
					,TotalElapsedTimeMS bigint NOT NULL
					,TotalRows bigint NULL
					,TotalSpills bigint NULL
					,Statement nvarchar(max) NULL
					,_Rnk_ int NOT NULL
				);

				CREATE CLUSTERED INDEX CL_fhsmQueryStatisticsTemp ON dbo.fhsmQueryStatisticsTemp(_Rnk_, QueryHash)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmQueryStatisticsTemp
		--
		BEGIN
			SET @objectName = ''dbo.fhsmQueryStatisticsTemp'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmQueryStatisticsReportTemp if it not already exists
		--
		IF OBJECT_ID(''dbo.fhsmQueryStatisticsReportTemp'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmQueryStatisticsReportTemp'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmQueryStatisticsReportTemp(
					DatabaseName nvarchar(128) NULL,
					QueryHash binary(8) NOT NULL,
					PlanHandle varbinary(64) NOT NULL,
					CreationTime datetime NULL,
					TimestampUTC datetime NOT NULL,
					Timestamp datetime NOT NULL,
					LastSQLServiceRestart datetime NULL,
					ExecutionCount bigint NOT NULL,
					TotalWorkerTimeMS bigint NOT NULL,
					TotalPhysicalReads bigint NOT NULL,
					TotalLogicalWrites bigint NOT NULL,
					TotalLogicalReads bigint NOT NULL,
					TotalClrTimeMS bigint NOT NULL,
					TotalElapsedTimeMS bigint NOT NULL,
					TotalRows bigint NULL,
					TotalSpills bigint NULL
				);

				CREATE CLUSTERED INDEX CL_fhsmQueryStatisticsReportTemp ON dbo.fhsmQueryStatisticsReportTemp(TimestampUTC, DatabaseName, QueryHash, PlanHandle, CreationTime)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmQueryStatisticsReportTemp
		--
		BEGIN
			SET @objectName = ''dbo.fhsmQueryStatisticsReportTemp'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Query statements]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statements'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statements'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statements'') + ''
				AS
				SELECT
					CONVERT(nvarchar(18), qs.QueryHash, 1) AS [Query hash]
					,qs.CreationTime
					,qs.LastExecutionTime
					,CASE
						WHEN LEN(qs.Statement) > '' + CAST(@maxStatementLength AS nvarchar) + '' THEN LEFT(qs.Statement, '' + CAST(@maxStatementLength AS nvarchar) + '') + CHAR(10) + ''''...Statement truncated''''
						ELSE qs.Statement
					END AS Statement
					,qs.Encrypted
					,CAST(qs.Timestamp AS date) AS Date
					,(DATEPART(HOUR, qs.Timestamp) * 60 * 60) + (DATEPART(MINUTE, qs.Timestamp) * 60) + (DATEPART(SECOND, qs.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(qs.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(qs.DatabaseName, CONVERT(nvarchar(18), qs.QueryHash, 1), DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS QueryStatisticKey
				FROM dbo.fhsmQueryStatement AS qs;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Query statements]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statements'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create fact view @pbiSchema.[Query statistics]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statistics'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statistics'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statistics'') + ''
				AS
				SELECT
					qsr.ExecutionCount
					,qsr.WorkerTimeMS
					,qsr.PhysicalReads
					,qsr.LogicalWrites
					,qsr.LogicalReads
					,qsr.ClrTimeMS
					,qsr.ElapsedTimeMS
					,qsr.Rows
					,qsr.Spills
					,qsr.Date
					,qsr.TimeKey
					,qsr.DatabaseKey
					,qsr.QueryStatisticKey
				FROM dbo.fhsmQueryStatisticsReport AS qsr;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Query statistics]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Query statistics'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPQueryStatistics
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPQueryStatistics'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPQueryStatistics AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPQueryStatistics (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @numberOfRows int;
					DECLARE @numberOfRowsStr nvarchar(128);
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);
					DECLARE @totalRowsStmt nvarchar(max);
					DECLARE @totalSpillsStmt nvarchar(max);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @numberOfRowsStr = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@NumberOfRows''''));
						SET @numberOfRows = dbo.fhsmFNTryParseAsInt(@numberOfRowsStr);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						--
						-- Test if total_rows exists on dm_exec_query_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_exec_query_stats'''') AND (sc.name = ''''total_rows'''')
							)
							BEGIN
								SET @totalRowsStmt = ''''deqs.total_rows'''';
							END
							ELSE BEGIN
								SET @totalRowsStmt = ''''NULL'''';
							END;
						END;

						--
						-- Test if total_spills exists on dm_exec_query_stats
						--
						BEGIN
							IF EXISTS(
								SELECT *
								FROM master.sys.system_columns AS sc
								INNER JOIN master.sys.system_objects AS so ON (so.object_id = sc.object_id)
								WHERE (so.name = ''''dm_exec_query_stats'''') AND (sc.name = ''''total_spills'''')
							)
							BEGIN
								SET @totalSpillsStmt = ''''deqs.total_spills'''';
							END
							ELSE BEGIN
								SET @totalSpillsStmt = ''''NULL'''';
							END;
						END;

						SET @stmt = ''''
							DECLARE @curUTC datetime;
							DECLARE @prevUTC datetime;

							--
							-- Collect DMV data
							--
							BEGIN
								TRUNCATE TABLE dbo.fhsmQueryStatisticsTemp;

								INSERT INTO dbo.fhsmQueryStatisticsTemp
								SELECT '''' + CASE WHEN @numberOfRows > 0 THEN ''''TOP ('''' + CAST(@numberOfRows AS nvarchar) + '''')'''' ELSE '''''''' END + ''''
									COALESCE(DB_NAME(dest.dbid), ''''''''DbId:'''''''' + CAST(dest.dbid AS nvarchar), ''''''''Ad hoc / prepared'''''''') AS DatabaseName
									,deqs.query_hash AS QueryHash
									,deqs.plan_handle AS PlanHandle
									,deqs.creation_time AS CreationTime
									,deqs.last_execution_time AS LastExecutionTime
									,deqs.execution_count AS ExecutionCount
									,(deqs.total_worker_time / 1000.0) AS TotalWorkerTimeMS
									,deqs.total_physical_reads AS TotalPhysicalReads
									,deqs.total_logical_writes AS TotalLogicalWrites
									,deqs.total_logical_reads AS TotalLogicalReads
									,(deqs.total_clr_time / 1000.0) AS TotalClrTimeMS
									,(deqs.total_elapsed_time / 1000.0) AS TotalElapsedTimeMS
									,'''' + @totalRowsStmt + '''' AS TotalRows
									,'''' + @totalSpillsStmt + '''' AS TotalSpills
									,CASE
										WHEN deqs.statement_start_offset > 0 THEN
											--The start of the active command is not at the beginning of the full command text
											CASE deqs.statement_end_offset
												WHEN -1 THEN
													--The end of the full command is also the end of the active statement
													SUBSTRING(dest.text, (deqs.statement_start_offset / 2) + 1, 2147483647)
												ELSE
													--The end of the active statement is not at the end of the full command
													SUBSTRING(dest.text, (deqs.statement_start_offset / 2) + 1, ((deqs.statement_end_offset - deqs.statement_start_offset) / 2) + 1)
											END
										ELSE
											--1st part of full command is running
											CASE deqs.statement_end_offset
												WHEN -1 THEN
													--The end of the full command is also the end of the active statement
													LTRIM(RTRIM(dest.text))
												ELSE
													--The end of the active statement is not at the end of the full command
													LEFT(dest.text, (deqs.statement_end_offset / 2) + 1)
											END
									END AS Statement
									,ROW_NUMBER() OVER(PARTITION BY dest.dbid, deqs.query_hash ORDER BY deqs.last_execution_time DESC, deqs.creation_time DESC) AS _Rnk_
								FROM sys.dm_exec_query_stats AS deqs WITH (NOLOCK)
								OUTER APPLY sys.dm_exec_sql_text(deqs.sql_handle) AS dest
								'''' + CASE WHEN @numberOfRows > 0 THEN ''''ORDER BY TotalLogicalReads DESC'''' ELSE '''''''' END + '''';
							END;
						'''';
						SET @stmt += ''''
							--
							-- Insert records into QueryStatistics
							--
							BEGIN
								INSERT INTO dbo.fhsmQueryStatistics(
									DatabaseName, QueryHash, PlanHandle, CreationTime, LastExecutionTime
									,ExecutionCount, TotalWorkerTimeMS, TotalPhysicalReads, TotalLogicalWrites, TotalLogicalReads, TotalClrTimeMS, TotalElapsedTimeMS, TotalRows, TotalSpills
									,LastSQLServiceRestart
									,TimestampUTC, Timestamp)
								SELECT
									src.DatabaseName, src.QueryHash, src.PlanHandle, src.CreationTime, src.LastExecutionTime
									,src.ExecutionCount, src.TotalWorkerTimeMS, src.TotalPhysicalReads, src.TotalLogicalWrites, src.TotalLogicalReads, src.TotalClrTimeMS, src.TotalElapsedTimeMS, src.TotalRows, src.TotalSpills
									,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
									,@nowUTC, @now
								FROM dbo.fhsmQueryStatisticsTemp AS src;
							END;
						'''';
						SET @stmt += ''''
							--
							-- Insert records into fhsmQueryStatisticsReport
							--
							BEGIN
								SET @curUTC = (SELECT TOP (1) qs.TimestampUTC FROM dbo.fhsmQueryStatistics AS qs ORDER BY qs.TimestampUTC DESC);
								SET @prevUTC = (SELECT TOP (1) qs.TimestampUTC FROM dbo.fhsmQueryStatistics AS qs WHERE (qs.TimestampUTC < @curUTC) ORDER BY qs.TimestampUTC DESC);

								--
								-- Delete if already processed
								--
								BEGIN
									DELETE qsr
									FROM dbo.fhsmQueryStatisticsReport AS qsr WHERE (qsr.TimestampUTC = @curUTC);
								END;

								--
								-- Load base data
								--
								BEGIN
									TRUNCATE TABLE dbo.fhsmQueryStatisticsReportTemp;

									WITH
									pairedDates AS (
										SELECT
											@curUTC AS curTimestampUTC
											,@prevUTC AS prevTimestampUTC
									)
									,summarizedQS AS (
										SELECT
											qs.DatabaseName
											,qs.QueryHash
											,qs.PlanHandle
											,qs.CreationTime
											,qs.TimestampUTC
											,qs.Timestamp
											,qs.LastSQLServiceRestart
											,SUM(qs.ExecutionCount) AS ExecutionCount
											,SUM(qs.TotalWorkerTimeMS) AS TotalWorkerTimeMS
											,SUM(qs.TotalPhysicalReads) AS TotalPhysicalReads
											,SUM(qs.TotalLogicalWrites) AS TotalLogicalWrites
											,SUM(qs.TotalLogicalReads) AS TotalLogicalReads
											,SUM(qs.TotalClrTimeMS) AS TotalClrTimeMS
											,SUM(qs.TotalElapsedTimeMS) AS TotalElapsedTimeMS
											,SUM(qs.TotalRows) AS TotalRows
											,SUM(qs.TotalSpills) AS TotalSpills
										FROM dbo.fhsmQueryStatistics AS qs
										WHERE (qs.TimestampUTC IN (@curUTC, @prevUTC))
										GROUP BY
											qs.DatabaseName
											,qs.QueryHash
											,qs.PlanHandle
											,qs.CreationTime
											,qs.TimestampUTC
											,qs.Timestamp
											,qs.LastSQLServiceRestart
									)
									INSERT INTO dbo.fhsmQueryStatisticsReportTemp(
											DatabaseName, QueryHash, PlanHandle, CreationTime, TimestampUTC, Timestamp, LastSQLServiceRestart
											,ExecutionCount, TotalWorkerTimeMS, TotalPhysicalReads, TotalLogicalWrites, TotalLogicalReads, TotalClrTimeMS, TotalElapsedTimeMS, TotalRows, TotalSpills
									)
									SELECT
										qs.DatabaseName, qs.QueryHash, qs.PlanHandle, qs.CreationTime, qs.TimestampUTC, qs.Timestamp, qs.LastSQLServiceRestart
										,qs.ExecutionCount, qs.TotalWorkerTimeMS, qs.TotalPhysicalReads, qs.TotalLogicalWrites, qs.TotalLogicalReads, qs.TotalClrTimeMS, qs.TotalElapsedTimeMS, qs.TotalRows, qs.TotalSpills
									FROM summarizedQS AS qs
								END;

								--
								-- Process delta
								--
								BEGIN
									INSERT INTO dbo.fhsmQueryStatisticsReport(
										ExecutionCount, WorkerTimeMS, PhysicalReads, LogicalWrites, LogicalReads, ClrTimeMS, ElapsedTimeMS, Rows, Spills
										,TimestampUTC, Timestamp, DatabaseName, QueryHash
										,Date, TimeKey, DatabaseKey, QueryStatisticKey
									)
									SELECT
										 SUM(a.ExecutionCount) AS ExecutionCount
										,SUM(a.WorkerTimeMS) AS WorkerTimeMS
										,SUM(a.PhysicalReads) AS PhysicalReads
										,SUM(a.LogicalWrites) AS LogicalWrites
										,SUM(a.LogicalReads) AS LogicalReads
										,SUM(a.ClrTimeMS) AS ClrTimeMS
										,SUM(a.ElapsedTimeMS) AS ElapsedTimeMS
										,SUM(a.Rows) AS Rows
										,SUM(a.Spills) AS Spills
										,a.TimestampUTC
										,a.Timestamp
										,a.DatabaseName
										,a.QueryHash
										,CAST(a.Timestamp AS date) AS Date
										,(DATEPART(HOUR, a.Timestamp) * 60 * 60) + (DATEPART(MINUTE, a.Timestamp) * 60) + (DATEPART(SECOND, a.Timestamp)) AS TimeKey
										,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
										,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.DatabaseName, CONVERT(nvarchar(18), a.QueryHash, 1), DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS QueryStatisticKey
									FROM (
										SELECT
											CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL															-- Ignore data if distance between current and previous is more than 12 hours
																																														-- Either it is the first data set for this CreationTime, or the counters had an overflow, or the server har been restarted
												WHEN (prevQS.ExecutionCount IS NULL) OR (prevQS.ExecutionCount > curQS.ExecutionCount) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.ExecutionCount
												ELSE curQS.ExecutionCount - prevQS.ExecutionCount																						-- Difference
											END AS ExecutionCount
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalWorkerTimeMS IS NULL) OR (prevQS.TotalWorkerTimeMS > curQS.TotalWorkerTimeMS) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalWorkerTimeMS
												ELSE curQS.TotalWorkerTimeMS - prevQS.TotalWorkerTimeMS
											END AS WorkerTimeMS
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalPhysicalReads IS NULL) OR (prevQS.TotalPhysicalReads > curQS.TotalPhysicalReads) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalPhysicalReads
												ELSE curQS.TotalPhysicalReads - prevQS.TotalPhysicalReads
											END AS PhysicalReads
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalLogicalWrites IS NULL) OR (prevQS.TotalLogicalWrites > curQS.TotalLogicalWrites) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalLogicalWrites
												ELSE curQS.TotalLogicalWrites - prevQS.TotalLogicalWrites
											END AS LogicalWrites
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalLogicalReads IS NULL) OR (prevQS.TotalLogicalReads > curQS.TotalLogicalReads) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalLogicalReads
												ELSE curQS.TotalLogicalReads - prevQS.TotalLogicalReads
											END AS LogicalReads
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalClrTimeMS IS NULL) OR (prevQS.TotalClrTimeMS > curQS.TotalClrTimeMS) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalClrTimeMS
												ELSE curQS.TotalClrTimeMS - prevQS.TotalClrTimeMS
											END AS ClrTimeMS
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalElapsedTimeMS IS NULL) OR (prevQS.TotalElapsedTimeMS > curQS.TotalElapsedTimeMS) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalElapsedTimeMS
												ELSE curQS.TotalElapsedTimeMS - prevQS.TotalElapsedTimeMS
											END AS ElapsedTimeMS
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalRows IS NULL) OR (prevQS.TotalRows > curQS.TotalRows) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalRows
												ELSE curQS.TotalRows - prevQS.TotalRows
											END AS Rows
											,CASE
												WHEN (DATEDIFF(HOUR, prevQS.TimestampUTC, curQS.TimestampUTC) >= 12) THEN NULL
												WHEN (prevQS.TotalSpills IS NULL) OR (prevQS.TotalSpills > curQS.TotalSpills) OR (prevQS.LastSQLServiceRestart <> curQS.LastSQLServiceRestart) THEN curQS.TotalSpills
												ELSE curQS.TotalSpills - prevQS.TotalSpills
											END AS Spills
											,curQS.TimestampUTC
											,curQS.Timestamp
											,curQS.DatabaseName
											,curQS.QueryHash
										FROM dbo.fhsmQueryStatisticsReportTemp AS curQS
										LEFT OUTER JOIN dbo.fhsmQueryStatisticsReportTemp AS prevQS ON (prevQS.TimestampUTC = @prevUTC)
											AND (prevQS.DatabaseName = curQS.DatabaseName)
											AND (prevQS.QueryHash = curQS.QueryHash)
											AND (prevQS.PlanHandle = curQS.PlanHandle)
											AND (prevQS.CreationTime = curQS.CreationTime)
										WHERE (curQS.TimestampUTC = @curUTC)
									) AS a
									WHERE
										(a.ExecutionCount <> 0)
										OR (a.WorkerTimeMS <> 0)
										OR (a.PhysicalReads <> 0)
										OR (a.LogicalWrites <> 0)
										OR (a.LogicalReads <> 0)
										OR (a.ClrTimeMS <> 0)
										OR (a.ElapsedTimeMS <> 0)
										OR (a.Rows <> 0)
										OR (a.Spills <> 0)
									GROUP BY
										a.TimestampUTC
										,a.Timestamp
										,a.DatabaseName
										,a.QueryHash;
								END;
							END;

							--
							-- Delete all records except _Rnk_ = 1 AND QueryHash <> 0x0
							--
							BEGIN
								DELETE t
								FROM dbo.fhsmQueryStatisticsTemp AS t
								WHERE NOT ((t._Rnk_ = 1) AND (t.QueryHash <> 0x0000000000000000));
							END;

							--
							-- Insert records into QueryStatement
							--
							BEGIN
								MERGE dbo.fhsmQueryStatement AS tgt
								USING (
									SELECT
										 t.DatabaseName
										,t.QueryHash
										,t.PlanHandle
										,t.CreationTime
										,t.LastExecutionTime
										,t.Statement
										,deqp.encrypted AS Encrypted
										,deqp.query_plan AS QueryPlan
									FROM dbo.fhsmQueryStatisticsTemp AS t
									CROSS APPLY sys.dm_exec_query_plan(t.PlanHandle) AS deqp
									WHERE (deqp.encrypted = 0)
								) AS src
								ON (src.DatabaseName = tgt.DatabaseName) AND (src.QueryHash = tgt.QueryHash)
								WHEN MATCHED
									THEN UPDATE SET
										tgt.LastExecutionTime = src.LastExecutionTime
										,tgt.Statement = src.Statement
										,tgt.Encrypted = src.Encrypted
										,tgt.QueryPlan = src.QueryPlan
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(DatabaseName, QueryHash, CreationTime, LastExecutionTime, Statement, Encrypted, QueryPlan, TimestampUTC, Timestamp)
									VALUES(src.DatabaseName, src.QueryHash, src.CreationTime, src.LastExecutionTime, src.Statement, src.Encrypted, src.QueryPlan, @nowUTC, @now)
								;
							END;
						'''';
						SET @stmt += ''''
							--
							-- Delete records from QueryStatements where no owner in QueryStatistics exists
							--
							BEGIN
								DELETE qStmt
								FROM dbo.fhsmQueryStatement AS qStmt
								WHERE NOT EXISTS (
									SELECT *
									FROM dbo.fhsmQueryStatistics AS qs
									WHERE (qs.DatabaseName = qStmt.DatabaseName) AND (qs.QueryHash = qStmt.QueryHash)
								);
							END;
						'''';
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now, @nowUTC = @nowUTC;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPQueryStatistics
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPQueryStatistics'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlQueryStatistics
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlQueryStatistics'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlQueryStatistics AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlQueryStatistics (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlQueryStatistics
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlQueryStatistics'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmQueryStatement''
				,1
				,''TimestampUTC''
				,1
				,4
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmQueryStatistics''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL

			UNION ALL

			SELECT
				1
				,''dbo.fhsmQueryStatisticsReport''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableQueryStatistics							AS Enabled
				,0												AS DeploymentStatus
				,''Query statistics''								AS Name
				,PARSENAME(''dbo.fhsmSPQueryStatistics'', 1)		AS Task
				,15 * 60										AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@NumberOfRows=1000''							AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2
			,OutputColumn1, OutputColumn2
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmQueryStatistics'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL
				,''Database'', NULL

			UNION ALL

			SELECT
				''Query statistic'' AS DimensionName
				,''QueryStatisticKey'' AS DimensionKey
				,''dbo.fhsmQueryStatistics'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', ''CONVERT(nvarchar(18), src.QueryHash, 1)''
				,''Database'', ''Query hash''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2
				,OutputColumn1, OutputColumn2
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2
				,src.OutputColumn1, src.OutputColumn2
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmQueryStatistics'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:Triggers.sql modified: 2025.08.05 19.13.08
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableTriggers bit;

	SET @enableTriggers = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing Triggers'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmTriggers and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmTriggers'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmTriggers'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmTriggers(
					Id int identity(1,1) NOT NULL
					,DatabaseName nvarchar(128) NOT NULL
					,ParentClass tinyint NULL
					,ParentSchema nvarchar(128) NULL
					,ParentObject nvarchar(128) NULL
					,Name nvarchar(128) NULL
					,Type char(2) NULL
					,CreateDate datetime NOT NULL
					,ModifyDate datetime NOT NULL
					,IsMsShipped bit NOT NULL
					,IsDisabled bit NOT NULL
					,IsNotForReplication bit NOT NULL
					,IsInsteadOfTrigger bit NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_fhsmTriggers PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTriggers'')) AND (i.name = ''NC_fhsmTriggers_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmTriggers_TimestampUTC] to table dbo.fhsmTriggers'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmTriggers_TimestampUTC ON dbo.fhsmTriggers(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTriggers'')) AND (i.name = ''NC_fhsmTriggers_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmTriggers_Timestamp] to table dbo.fhsmTriggers'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmTriggers_Timestamp ON dbo.fhsmTriggers(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmTriggers'')) AND (i.name = ''NC_fhsmTriggers_DatabaseName''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmTriggers_DatabaseName] to table dbo.fhsmTriggers'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmTriggers_DatabaseName ON dbo.fhsmTriggers(DatabaseName)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Add column added in version 2.5
		--
		IF NOT EXISTS(SELECT * FROM sys.columns AS c WHERE (c.object_id = OBJECT_ID(''dbo.fhsmTriggers'')) AND (c.name = ''Name''))
		BEGIN
			SET @stmt = ''ALTER TABLE dbo.fhsmTriggers ADD [Name] nvarchar(128) NULL;'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmTriggers
		--
		BEGIN
			SET @objectName = ''dbo.fhsmTriggers'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Triggers]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Triggers'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Triggers'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Triggers'') + ''
				AS
				SELECT
					CASE t.ParentClass
						WHEN 0 THEN ''''Database''''
						WHEN 1 THEN ''''Object/Column''''
						ELSE ''''ParentClass:'''' + CAST(t.ParentClass AS nvarchar)
					END AS ParentClass
					,QUOTENAME(t.ParentSchema) + ''''.'''' + QUOTENAME(t.ParentObject) AS ParentObject
					,CASE t.Type
						WHEN ''''TA'''' THEN ''''Assembly trigger''''
						WHEN ''''TR'''' THEN ''''SQL trigger''''
						ELSE ''''Type:'''' + t.Type
					END AS Type
					,t.Name AS TriggerName
					,t.CreateDate
					,t.ModifyDate
					,t.IsMsShipped
					,t.IsDisabled
					,t.IsNotForReplication
					,CASE t.IsInsteadOfTrigger
						WHEN 0 THEN ''''After trigger''''
						ELSE ''''Instead of trigger''''
					END TriggerType
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(t.DatabaseName, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
				FROM dbo.fhsmTriggers AS t
				WHERE (t.TimestampUTC = (
					SELECT TOP (1) t2.TimestampUTC
					FROM dbo.fhsmTriggers AS t2
					ORDER BY t2.TimestampUTC DESC
				))
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Triggers]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Triggers'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPTriggers
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPTriggers'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPTriggers AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPTriggers (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @database nvarchar(128);
					DECLARE @databases nvarchar(max);
					DECLARE @errorMsg nvarchar(max);
					DECLARE @message nvarchar(max);
					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @parameterTable TABLE([Key] nvarchar(128) NOT NULL, Value nvarchar(128) NULL);
					DECLARE @replicaId uniqueidentifier;
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

						INSERT INTO @parameterTable([Key], Value)
						SELECT
							(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 1)) AS [Key]
							,(SELECT s.Txt FROM dbo.fhsmFNSplitString(p.Txt, ''''='''') AS s WHERE (s.Part = 2)) AS Value
						FROM dbo.fhsmFNSplitString(@parameter, '''';'''') AS p;

						SET @databases = (SELECT pt.Value FROM @parameterTable AS pt WHERE (pt.[Key] = ''''@Databases''''));

						--
						-- Trim @databases if Ola Hallengren style has been chosen
						--
						BEGIN
							SET @databases = LTRIM(RTRIM(@databases));
							WHILE (LEFT(@databases, 1) = '''''''''''''''') AND (LEFT(@databases, 1) = '''''''''''''''')
							BEGIN
								SET @databases = SUBSTRING(@databases, 2, LEN(@databases) - 2);
							END;
						END;
					END;
			'';
			SET @stmt += ''

					--
					-- Get the list of databases to process
					--
					BEGIN
						SELECT d.DatabaseName, d.[Order]
						INTO #dbList
						FROM dbo.fhsmFNParseDatabasesStr(@databases) AS d;
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						DECLARE dCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
						SELECT dl.DatabaseName, '' + CASE WHEN (@productVersion1 <= 10) THEN ''NULL'' ELSE ''d.replica_id'' END + '' AS replica_id
						FROM #dbList AS dl
						INNER JOIN sys.databases AS d ON (d.name COLLATE DATABASE_DEFAULT = dl.DatabaseName)
						ORDER BY dl.[Order];

						OPEN dCur;
			'';
			SET @stmt += ''

						WHILE (1 = 1)
						BEGIN
							FETCH NEXT FROM dCur
							INTO @database, @replicaId;

							IF (@@FETCH_STATUS <> 0)
							BEGIN
								BREAK;
							END;

							--
							-- If is a member of a replica, we will only execute when running on the primary
							--
							IF (@replicaId IS NULL)
			'';
			IF (@productVersion1 >= 11)
			BEGIN
				-- SQL Versions SQL2012 or higher
				SET @stmt += ''
								OR (
									(
										SELECT
										CASE
											WHEN (dhags.primary_replica = ar.replica_server_name) THEN 1
											ELSE 0
										END AS IsPrimaryServer
										FROM master.sys.availability_groups AS ag
										INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
										INNER JOIN master.sys.dm_hadr_availability_group_states AS dhags ON ag.group_id = dhags.group_id
										WHERE (ar.replica_server_name = @@SERVERNAME) AND (ar.replica_id = @replicaId)
									) = 1
								)
				'';
			END;
			SET @stmt += ''
							BEGIN
								SET @stmt = ''''
									USE '''' + QUOTENAME(@database) + '''';

									SELECT
										DB_NAME() AS DatabaseName
										,t.parent_class AS ParentClass
										,parentSch.name AS ParentSchema
										,parentO.name AS ParentObject
										,o.name AS Name
										,t.type AS Type
										,t.create_date AS CreateDate
										,t.modify_date AS ModifyDate
										,t.is_ms_shipped AS IsMsShipped
										,t.is_disabled AS IsDisabled
										,t.is_not_for_replication AS IsNotForReplication
										,t.is_instead_of_trigger AS IsInsteadOfTrigger
										,@nowUTC, @now
									FROM sys.triggers AS t
									LEFT OUTER JOIN sys.objects AS o ON (o.object_id = t.object_id)
									LEFT OUTER JOIN sys.objects AS parentO ON (parentO.object_id = t.parent_id)
									LEFT OUTER JOIN sys.schemas AS parentSch ON (parentSch.schema_id = parentO.schema_id);
								'''';
								BEGIN TRY
									INSERT INTO dbo.fhsmTriggers(
										DatabaseName
										,ParentClass, ParentSchema, ParentObject, Name, Type
										,CreateDate, ModifyDate
										,IsMsShipped, IsDisabled, IsNotForReplication, IsInsteadOfTrigger
										,TimestampUTC, Timestamp
									)
									EXEC sp_executesql
										@stmt
										,N''''@now datetime, @nowUTC datetime''''
										,@now = @now, @nowUTC = @nowUTC;
								END TRY
								BEGIN CATCH
									SET @errorMsg = ERROR_MESSAGE();

									SET @message = ''''Database '''''''''''' + @database + '''''''''''' failed due to - '''' + @errorMsg;
									EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Warning'''', @message = @message;
								END CATCH;
							END
							ELSE BEGIN
								SET @message = ''''Database '''''''''''' + @database + '''''''''''' is member of a replica but this server is not the primary node'''';
								EXEC dbo.fhsmSPLog @name = @name, @version = @version, @task = @thisTask, @type = ''''Debug'''', @message = @message;
							END;
						END;

						CLOSE dCur;
						DEALLOCATE dCur;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPTriggers
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPTriggers'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;

		--
		-- Create stored procedure dbo.fhsmSPControlTriggers
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPControlTriggers'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPControlTriggers AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPControlTriggers (
					@Type nvarchar(16)
					,@Command nvarchar(16)
					,@Name nvarchar(128) = NULL
					,@Parameter nvarchar(max) = NULL
					,@Task nvarchar(128) = NULL
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @message nvarchar(max);
					DECLARE @parameterChanges TABLE(
						Action nvarchar(10),
						DeletedTask nvarchar(128),
						DeletedName nvarchar(128),
						DeletedParameter nvarchar(max),
						InsertedTask nvarchar(128),
						InsertedName nvarchar(128),
						InsertedParameter nvarchar(max)
					);
					DECLARE @thisTask nvarchar(128);
					DECLARE @version nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';
			'';
			SET @stmt += ''
					IF (@Type = ''''Parameter'''')
					BEGIN
						IF (@Command = ''''set'''')
						BEGIN
							SET @Parameter = NULLIF(@Parameter, '''''''');

							IF NOT EXISTS (
								SELECT *
								FROM dbo.fhsmSchedules AS s
								WHERE (s.Task = @Task) AND (s.Name = @Name) AND (s.DeploymentStatus <> -1)
							)
							BEGIN
								SET @message = ''''Invalid @Task:'''''''''''' + COALESCE(NULLIF(@Task, ''''''''), ''''<NULL>'''') + '''''''''''' and @Name:'''''''''''' + COALESCE(NULLIF(@Name, ''''''''), ''''<NULL>'''') + '''''''''''''''';
								RAISERROR(@message, 0, 1) WITH NOWAIT;
								RETURN -11;
							END;

							--
							-- Register configuration changes
							--
							BEGIN
								WITH
								conf(Task, Name, Parameter) AS(
									SELECT
										@Task AS Task
										,@Name AS Name
										,@Parameter AS Parameter
								)
								MERGE dbo.fhsmSchedules AS tgt
								USING conf AS src ON (src.[Task] = tgt.[Task] COLLATE SQL_Latin1_General_CP1_CI_AS) AND (src.[Name] = tgt.[Name] COLLATE SQL_Latin1_General_CP1_CI_AS)
								-- Not testing for NULL as a NULL parameter is not allowed
								WHEN MATCHED AND (tgt.Parameter <> src.Parameter)
									THEN UPDATE
										SET tgt.Parameter = src.Parameter
								WHEN NOT MATCHED BY TARGET
									THEN INSERT(Task, Name, Parameter)
									VALUES(src.Task, src.Name, src.Parameter)
								OUTPUT
									$action,
									deleted.Task,
									deleted.Name,
									deleted.Parameter,
									inserted.Task,
									inserted.Name,
									inserted.Parameter
								INTO @parameterChanges;

								IF (@@ROWCOUNT <> 0)
								BEGIN
									SET @message = (
										SELECT ''''Parameter is '''''''''''' + COALESCE(src.InsertedParameter, ''''<NULL>'''') + '''''''''''' - changed from '''''''''''' + COALESCE(src.DeletedParameter, ''''<NULL>'''') + ''''''''''''''''
										FROM @parameterChanges AS src
									);
									IF (@message IS NOT NULL)
									BEGIN
										EXEC dbo.fhsmSPLog @name = @Name, @version = @version, @task = @thisTask, @type = ''''Info'''', @message = @message;
									END;
								END;
							END;
			'';
			SET @stmt += ''
						END
						ELSE BEGIN
							SET @message = ''''Illegal Combination of @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''' and @Command:'''''''''''' + COALESCE(@Command, ''''<NULL>'''') + '''''''''''''''';
							RAISERROR(@message, 0, 1) WITH NOWAIT;
							RETURN -19;
						END;
					END
			'';
			SET @stmt += ''
					ELSE IF (@Type = ''''Uninstall'''')
					BEGIN
						--
						-- Place holder
						--
						SET @Type = @Type;
					END
			'';
			SET @stmt += ''
					ELSE BEGIN
						SET @message = ''''Illegal @Type:'''''''''''' + COALESCE(@Type, ''''<NULL>'''') + '''''''''''''''';
						RAISERROR(@message, 0, 1) WITH NOWAIT;
						RETURN -999;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);

			--
			-- Register extended properties on the stored procedure dbo.fhsmSPControlTriggers
			--
			BEGIN
				SET @objectName = ''dbo.fhsmSPControlTriggers'';
				SET @objName = PARSENAME(@objectName, 1);
				SET @schName = PARSENAME(@objectName, 2);

				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
				EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
			END;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmTriggers''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableTriggers									AS Enabled
				,0												AS DeploymentStatus
				,''Triggers''										AS Name
				,PARSENAME(''dbo.fhsmSPTriggers'', 1)				AS Take
				,12 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T22:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:00:00.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@Databases = ''''USER_DATABASES, msdb''''''		AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmTriggers'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[DatabaseName]'', NULL, NULL, NULL
				,''Database'', NULL, NULL, NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmTriggers'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:WaitStatistics.sql modified: 2025.08.05 19.13.23
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableWaitStatistics bit;

	SET @enableWaitStatistics = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing WaitStatistics'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create table dbo.fhsmWaitCategories if it not already exists
		--
		IF OBJECT_ID(''dbo.fhsmWaitCategories'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmWaitCategories'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmWaitCategories(
					WaitType nvarchar(60) NOT NULL
					,WaitCategory nvarchar(128) NOT NULL
					,Ignorable bit NOT NULL
					,CONSTRAINT PK_fhsmWaitCategories PRIMARY KEY(WaitType)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmWaitCategories
		--
		BEGIN
			SET @objectName = ''dbo.fhsmWaitCategories'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;

		--
		-- Create table dbo.fhsmWaitStatistics and indexes if they not already exists
		--
		IF OBJECT_ID(''dbo.fhsmWaitStatistics'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmWaitStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE TABLE dbo.fhsmWaitStatistics(
					Id int identity(1,1) NOT NULL
					,WaitType nvarchar(60) NOT NULL
					,SumWaitTimeMS bigint NOT NULL
					,SumSignalWaitTimeMS bigint NOT NULL
					,SumWaitingTasks bigint NOT NULL
					,LastSQLServiceRestart datetime NOT NULL
					,TimestampUTC datetime NOT NULL
					,Timestamp datetime NOT NULL
					,CONSTRAINT PK_WaitStatistics PRIMARY KEY(Id)'' + @tableCompressionStmt + ''
				);
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmWaitStatistics'')) AND (i.name = ''NC_fhsmWaitStatistics_TimestampUTC''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmWaitStatistics_TimestampUTC] to table dbo.fhsmWaitStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmWaitStatistics_TimestampUTC ON dbo.fhsmWaitStatistics(TimestampUTC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmWaitStatistics'')) AND (i.name = ''NC_fhsmWaitStatistics_Timestamp''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmWaitStatistics_Timestamp] to table dbo.fhsmWaitStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmWaitStatistics_Timestamp ON dbo.fhsmWaitStatistics(Timestamp)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmWaitStatistics'')) AND (i.name = ''NC_fhsmWaitStatistics_WaitType''))
		BEGIN
			RAISERROR(''Adding index [NC_fhsmWaitStatistics_WaitType] to table dbo.fhsmWaitStatistics'', 0, 1) WITH NOWAIT;

			SET @stmt = ''
				CREATE NONCLUSTERED INDEX NC_fhsmWaitStatistics_WaitType ON dbo.fhsmWaitStatistics(WaitType)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmWaitStatistics
		--
		BEGIN
			SET @objectName = ''dbo.fhsmWaitStatistics'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create default wait categories
	--
	BEGIN
		IF ((SELECT COUNT(*) FROM dbo.fhsmWaitCategories) = 0)
		BEGIN
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''ASYNC_IO_COMPLETION'',''Other Disk IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''ASYNC_NETWORK_IO'',''Network IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BACKUPIO'',''Other Disk IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_CONNECTION_RECEIVE_TASK'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_DISPATCHER'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_ENDPOINT_STATE_MUTEX'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_EVENTHANDLER'',''Service Broker'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_FORWARDER'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_INIT'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_MASTERSTART'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_RECEIVE_WAITFOR'',''User Wait'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_REGISTERALLENDPOINTS'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_SERVICE'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_SHUTDOWN'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_START'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TASK_SHUTDOWN'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TASK_STOP'',''Service Broker'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TASK_SUBMIT'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TO_FLUSH'',''Service Broker'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TRANSMISSION_OBJECT'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TRANSMISSION_TABLE'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TRANSMISSION_WORK'',''Service Broker'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''BROKER_TRANSMITTER'',''Service Broker'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CHECKPOINT_QUEUE'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CHKPT'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_AUTO_EVENT'',''SQL CLR'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_CRST'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_JOIN'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_MANUAL_EVENT'',''SQL CLR'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_MEMORY_SPY'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_MONITOR'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_RWLOCK_READER'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_RWLOCK_WRITER'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_SEMAPHORE'',''SQL CLR'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLR_TASK_START'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CLRHOST_STATE_ACCESS'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CMEMPARTITIONED'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CMEMTHREAD'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CXPACKET'',''Parallelism'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''CXCONSUMER'',''Parallelism'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DBMIRROR_DBM_EVENT'',''Mirroring'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DBMIRROR_DBM_MUTEX'',''Mirroring'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DBMIRROR_EVENTS_QUEUE'',''Mirroring'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DBMIRROR_SEND'',''Mirroring'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DBMIRROR_WORKER_QUEUE'',''Mirroring'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DBMIRRORING_CMD'',''Mirroring'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DIRTY_PAGE_POLL'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DIRTY_PAGE_TABLE_LOCK'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DISPATCHER_QUEUE_SEMAPHORE'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DPT_ENTRY_LOCK'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTC'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTC_ABORT_REQUEST'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTC_RESOLVE'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTC_STATE'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTC_TMDOWN_REQUEST'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTC_WAITFOR_OUTCOME'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTCNEW_ENLIST'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTCNEW_PREPARE'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTCNEW_RECOVERY'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTCNEW_TM'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTCNEW_TRANSACTION_ENLISTMENT'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''DTCPNTSYNC'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''EE_PMOLOCK'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''EXCHANGE'',''Parallelism'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''EXTERNAL_SCRIPT_NETWORK_IOF'',''Network IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FCB_REPLICA_READ'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FCB_REPLICA_WRITE'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_COMPROWSET_RWLOCK'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_IFTS_RWLOCK'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_IFTS_SCHEDULER_IDLE_WAIT'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_IFTSHC_MUTEX'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_IFTSISM_MUTEX'',''Full Text Search'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_MASTER_MERGE'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_MASTER_MERGE_COORDINATOR'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_METADATA_MUTEX'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_PROPERTYLIST_CACHE'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FT_RESTART_CRAWL'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''FULLTEXT GATHERER'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_AG_MUTEX'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_AR_CRITICAL_SECTION_ENTRY'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_AR_MANAGER_MUTEX'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_AR_UNLOAD_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_ARCONTROLLER_NOTIFICATIONS_SUBSCRIBER_LIST'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_BACKUP_BULK_LOCK'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_BACKUP_QUEUE'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_CLUSAPI_CALL'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_COMPRESSED_CACHE_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_CONNECTIVITY_INFO'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DATABASE_FLOW_CONTROL'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DATABASE_VERSIONING_STATE'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DATABASE_WAIT_FOR_RECOVERY'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DATABASE_WAIT_FOR_RESTART'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DATABASE_WAIT_FOR_TRANSITION_TO_VERSIONING'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DB_COMMAND'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DB_OP_COMPLETION_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DB_OP_START_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DBR_SUBSCRIBER'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DBR_SUBSCRIBER_FILTER_LIST'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DBSEEDING'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DBSEEDING_LIST'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_DBSTATECHANGE_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FABRIC_CALLBACK'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_BLOCK_FLUSH'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_FILE_CLOSE'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_FILE_REQUEST'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_IOMGR'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_MANAGER'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_FILESTREAM_PREPROC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_GROUP_COMMIT'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_LOGCAPTURE_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_LOGCAPTURE_WAIT'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_LOGPROGRESS_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_NOTIFICATION_DEQUEUE'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_NOTIFICATION_WORKER_EXCLUSIVE_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_NOTIFICATION_WORKER_STARTUP_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_NOTIFICATION_WORKER_TERMINATION_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_PARTNER_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_READ_ALL_NETWORKS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_RECOVERY_WAIT_FOR_CONNECTION'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_RECOVERY_WAIT_FOR_UNDO'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_REPLICAINFO_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SEEDING_CANCELLATION'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SEEDING_FILE_LIST'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SEEDING_LIMIT_BACKUPS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SEEDING_SYNC_COMPLETION'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SEEDING_TIMEOUT_TASK'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SEEDING_WAIT_FOR_COMPLETION'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SYNC_COMMIT'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_SYNCHRONIZING_THROTTLE'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_TDS_LISTENER_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_TDS_LISTENER_SYNC_PROCESSING'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_THROTTLE_LOG_RATE_GOVERNOR'',''Log Rate Governor'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_TIMER_TASK'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_TRANSPORT_DBRLIST'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_TRANSPORT_FLOW_CONTROL'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_TRANSPORT_SESSION'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_WORK_POOL'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_WORK_QUEUE'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''HADR_XRF_STACK_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''INSTANCE_LOG_RATE_GOVERNOR'',''Log Rate Governor'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''IO_COMPLETION'',''Other Disk IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''IO_QUEUE_LIMIT'',''Other Disk IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''IO_RETRY'',''Other Disk IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LATCH_DT'',''Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LATCH_EX'',''Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LATCH_KP'',''Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LATCH_NL'',''Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LATCH_SH'',''Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LATCH_UP'',''Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LAZYWRITER_SLEEP'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_BU'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_BU_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_BU_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IS_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IS_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IU'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IU_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IU_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IX'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IX_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_IX_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_NL'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_NL_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_NL_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_S'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_S_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_S_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_U'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_U_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_U_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_X'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_X_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RIn_X_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RS_S'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RS_S_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RS_S_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RS_U'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RS_U_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RS_U_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_S'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_S_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_S_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_U'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_U_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_U_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_X'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_X_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_RX_X_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_S'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_S_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_S_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SCH_M'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SCH_M_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SCH_M_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SCH_S'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SCH_S_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SCH_S_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SIU'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SIU_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SIU_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SIX'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SIX_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_SIX_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_U'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_U_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_U_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_UIX'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_UIX_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_UIX_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_X'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_X_ABORT_BLOCKERS'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LCK_M_X_LOW_PRIORITY'',''Lock'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOG_RATE_GOVERNOR'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOGBUFFER'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOGMGR'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOGMGR_FLUSH'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOGMGR_PMM_LOG'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOGMGR_QUEUE'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''LOGMGR_RESERVE_APPEND'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''MEMORY_ALLOCATION_EXT'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''MEMORY_GRANT_UPDATE'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''MSQL_XACT_MGR_MUTEX'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''MSQL_XACT_MUTEX'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''MSSEARCH'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''NET_WAITFOR_PACKET'',''Network IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''ONDEMAND_TASK_QUEUE'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGEIOLATCH_DT'',''Buffer IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGEIOLATCH_EX'',''Buffer IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGEIOLATCH_KP'',''Buffer IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGEIOLATCH_NL'',''Buffer IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGEIOLATCH_SH'',''Buffer IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGEIOLATCH_UP'',''Buffer IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGELATCH_DT'',''Buffer Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGELATCH_EX'',''Buffer Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGELATCH_KP'',''Buffer Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGELATCH_NL'',''Buffer Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGELATCH_SH'',''Buffer Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PAGELATCH_UP'',''Buffer Latch'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_DRAIN_WORKER'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_FLOW_CONTROL'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_LOG_CACHE'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_TRAN_LIST'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_TRAN_TURN'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_WORKER_SYNC'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PARALLEL_REDO_WORKER_WAIT_WORK'',''Replication'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''POOL_LOG_RATE_GOVERNOR'',''Log Rate Governor'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_ABR'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_CLOSEBACKUPMEDIA'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_CLOSEBACKUPTAPE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_CLOSEBACKUPVDIDEVICE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_CLUSAPI_CLUSTERRESOURCECONTROL'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_COCREATEINSTANCE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_COGETCLASSOBJECT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_CREATEACCESSOR'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_DELETEROWS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_GETCOMMANDTEXT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_GETDATA'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_GETNEXTROWS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_GETRESULT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_GETROWSBYBOOKMARK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBFLUSH'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBLOCKREGION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBREADAT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBSETSIZE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBSTAT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBUNLOCKREGION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_LBWRITEAT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_QUERYINTERFACE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_RELEASE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_RELEASEACCESSOR'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_RELEASEROWS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_RELEASESESSION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_RESTARTPOSITION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_SEQSTRMREAD'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_SEQSTRMREADANDWRITE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_SETDATAFAILURE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_SETPARAMETERINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_SETPARAMETERPROPERTIES'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_STRMLOCKREGION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_STRMSEEKANDREAD'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_STRMSEEKANDWRITE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_STRMSETSIZE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_STRMSTAT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_COM_STRMUNLOCKREGION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_CONSOLEWRITE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_CREATEPARAM'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DEBUG'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSADDLINK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSLINKEXISTCHECK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSLINKHEALTHCHECK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSREMOVELINK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSREMOVEROOT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSROOTFOLDERCHECK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSROOTINIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DFSROOTSHARECHECK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DTC_ABORT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DTC_ABORTREQUESTDONE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DTC_BEGINTRANSACTION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DTC_COMMITREQUESTDONE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DTC_ENLIST'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_DTC_PREPAREREQUESTDONE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_FILESIZEGET'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_FSAOLEDB_ABORTTRANSACTION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_FSAOLEDB_COMMITTRANSACTION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_FSAOLEDB_STARTTRANSACTION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_FSRECOVER_UNCONDITIONALUNDO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_GETRMINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_HADR_LEASE_MECHANISM'',''Preemptive'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_HTTP_EVENT_WAIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_HTTP_REQUEST'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_LOCKMONITOR'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_MSS_RELEASE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_ODBCOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLE_UNINIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_ABORTORCOMMITTRAN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_ABORTTRAN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_GETDATASOURCE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_GETLITERALINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_GETPROPERTIES'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_GETPROPERTYINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_GETSCHEMALOCK'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_JOINTRANSACTION'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_RELEASE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDB_SETPROPERTIES'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OLEDBOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_ACCEPTSECURITYCONTEXT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_ACQUIRECREDENTIALSHANDLE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_AUTHENTICATIONOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_AUTHORIZATIONOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_AUTHZGETINFORMATIONFROMCONTEXT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_AUTHZINITIALIZECONTEXTFROMSID'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_AUTHZINITIALIZERESOURCEMANAGER'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_BACKUPREAD'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CLOSEHANDLE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CLUSTEROPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_COMOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_COMPLETEAUTHTOKEN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_COPYFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CREATEDIRECTORY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CREATEFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CRYPTACQUIRECONTEXT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CRYPTIMPORTKEY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_CRYPTOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DECRYPTMESSAGE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DELETEFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DELETESECURITYCONTEXT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DEVICEIOCONTROL'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DEVICEOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DIRSVC_NETWORKOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DISCONNECTNAMEDPIPE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DOMAINSERVICESOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DSGETDCNAME'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_DTCOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_ENCRYPTMESSAGE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_FILEOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_FINDFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_FLUSHFILEBUFFERS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_FORMATMESSAGE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_FREECREDENTIALSHANDLE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_FREELIBRARY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GENERICOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETADDRINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETCOMPRESSEDFILESIZE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETDISKFREESPACE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETFILEATTRIBUTES'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETFILESIZE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETFINALFILEPATHBYHANDLE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETLONGPATHNAME'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETPROCADDRESS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETVOLUMENAMEFORVOLUMEMOUNTPOINT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_GETVOLUMEPATHNAME'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_INITIALIZESECURITYCONTEXT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_LIBRARYOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_LOADLIBRARY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_LOGONUSER'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_LOOKUPACCOUNTSID'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_MESSAGEQUEUEOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_MOVEFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETGROUPGETUSERS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETLOCALGROUPGETMEMBERS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETUSERGETGROUPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETUSERGETLOCALGROUPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETUSERMODALSGET'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICYFREE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_OPENDIRECTORY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_PDH_WMI_INIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_PIPEOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_PROCESSOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_QUERYCONTEXTATTRIBUTES'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_QUERYREGISTRY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_QUERYSECURITYCONTEXTTOKEN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_REMOVEDIRECTORY'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_REPORTEVENT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_REVERTTOSELF'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_RSFXDEVICEOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SECURITYOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SERVICEOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SETENDOFFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SETFILEPOINTER'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SETFILEVALIDDATA'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SETNAMEDSECURITYINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SQLCLROPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_SQMLAUNCH'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_VERIFYSIGNATURE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_VERIFYTRUST'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_VSSOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_WAITFORSINGLEOBJECT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_WINSOCKOPS'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_WRITEFILE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_WRITEFILEGATHER'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_OS_WSASETLASTERROR'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_REENLIST'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_RESIZELOG'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_ROLLFORWARDREDO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_ROLLFORWARDUNDO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SB_STOPENDPOINT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SERVER_STARTUP'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SETRMINFO'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SHAREDMEM_GETDATA'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SNIOPEN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SOSHOST'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SOSTESTING'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_SP_SERVER_DIAGNOSTICS'',''Preemptive'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_STARTRM'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_STREAMFCB_CHECKPOINT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_STREAMFCB_RECOVER'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_STRESSDRIVER'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_TESTING'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_TRANSIMPORT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_UNMARSHALPROPAGATIONTOKEN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_VSS_CREATESNAPSHOT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_VSS_CREATEVOLUMESNAPSHOT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_CALLBACKEXECUTE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_CX_FILE_OPEN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_CX_HTTP_CALL'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_DISPATCHER'',''Preemptive'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_ENGINEINIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_GETTARGETSTATE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_SESSIONCOMMIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_TARGETFINALIZE'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_TARGETINIT'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XE_TIMERRUN'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PREEMPTIVE_XETESTING'',''Preemptive'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_ACTION_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_CHANGE_NOTIFIER_TERMINATION_SYNC'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_CLUSTER_INTEGRATION'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_FAILOVER_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_JOIN'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_OFFLINE_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_ONLINE_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_POST_ONLINE_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_SERVER_READY_CONNECTIONS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADR_WORKITEM_COMPLETED'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_HADRSIM'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''PWAIT_RESOURCE_SEMAPHORE_FT_PARALLEL_QUERY_SYNC'',''Full Text Search'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''QDS_ASYNC_QUEUE'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''QDS_PERSIST_TASK_MAIN_LOOP_SLEEP'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''QDS_SHUTDOWN_QUEUE'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''QUERY_TRACEOUT'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REDO_THREAD_PENDING_WORK'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPL_CACHE_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPL_HISTORYCACHE_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPL_SCHEMA_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPL_TRANFSINFO_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPL_TRANHASHTABLE_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPL_TRANTEXTINFO_ACCESS'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REPLICA_WRITES'',''Replication'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''REQUEST_FOR_DEADLOCK_SEARCH'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''RESERVED_MEMORY_ALLOCATION_EXT'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''RESOURCE_SEMAPHORE'',''Memory'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''RESOURCE_SEMAPHORE_QUERY_COMPILE'',''Compilation'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_BPOOL_FLUSH'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_BUFFERPOOL_HELPLW'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_DBSTARTUP'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_DCOMSTARTUP'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_MASTERDBREADY'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_MASTERMDREADY'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_MASTERUPGRADED'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_MEMORYPOOL_ALLOCATEPAGES'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_MSDBSTARTUP'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_RETRY_VIRTUALALLOC'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_SYSTEMTASK'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_TASK'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_TEMPDBSTARTUP'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SLEEP_WORKSPACE_ALLOCATEPAGE'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SOS_SCHEDULER_YIELD'',''CPU'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SOS_WORK_DISPATCHER'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SP_SERVER_DIAGNOSTICS_SLEEP'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLCLR_APPDOMAIN'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLCLR_ASSEMBLY'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLCLR_DEADLOCK_DETECTION'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLCLR_QUANTUM_PUNISHMENT'',''SQL CLR'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_BUFFER_FLUSH'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_FILE_BUFFER'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_FILE_READ_IO_COMPLETION'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_FILE_WRITE_IO_COMPLETION'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_INCREMENTAL_FLUSH_SLEEP'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_PENDING_BUFFER_WRITERS'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_SHUTDOWN'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''SQLTRACE_WAIT_ENTRIES'',''Idle'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''THREADPOOL'',''Worker Thread'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRACE_EVTNOTIF'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRACEWRITE'',''Tracing'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRAN_MARKLATCH_DT'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRAN_MARKLATCH_EX'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRAN_MARKLATCH_KP'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRAN_MARKLATCH_NL'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRAN_MARKLATCH_SH'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRAN_MARKLATCH_UP'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''TRANSACTION_MUTEX'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''UCS_SESSION_REGISTRATION'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''WAIT_FOR_RESULTS'',''User Wait'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''WAIT_XTP_OFFLINE_CKPT_NEW_LOG'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''WAITFOR'',''User Wait'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''WRITE_COMPLETION'',''Other Disk IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''WRITELOG'',''Tran Log IO'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XACT_OWN_TRANSACTION'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XACT_RECLAIM_SESSION'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XACTLOCKINFO'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XACTWORKSPACE_MUTEX'',''Transaction'',0);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XE_DISPATCHER_WAIT'',''Idle'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XE_LIVE_TARGET_TVF'',''Other'',1);
			INSERT INTO dbo.fhsmWaitCategories(WaitType, WaitCategory, Ignorable) VALUES (''XE_TIMER_EVENT'',''Idle'',1);
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Wait statistics]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Wait statistics'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Wait statistics'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Wait statistics'') + ''
				AS
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
				WITH waitStatistics AS (
					SELECT
						ws.WaitType
						,ws.SumWaitTimeMS
						,ws.SumSignalWaitTimeMS
						,ws.SumWaitingTasks
						,ws.LastSQLServiceRestart
						,ws.TimestampUTC
						,ws.Timestamp
						,ROW_NUMBER() OVER(PARTITION BY ws.WaitType ORDER BY ws.TimestampUTC) AS Idx
					FROM dbo.fhsmWaitStatistics AS ws
				)
				'';
			END;
			SET @stmt += ''
				SELECT
					b.DeltaSumWaitTimeMS AS WaitTimeMS
					,b.DeltaSumSignalWaitTimeMS AS SignalWaitTimeMS
					,b.DeltaSumWaitingTasks AS WaitingTasks

					,b.Timestamp
					,CAST(b.Timestamp AS date) AS Date
					,(DATEPART(HOUR, b.Timestamp) * 60 * 60) + (DATEPART(MINUTE, b.Timestamp) * 60) + (DATEPART(SECOND, b.Timestamp)) AS TimeKey
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(b.WaitType, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS WaitKey
				FROM (
					SELECT
						CASE
							WHEN (DATEDIFF(HOUR, a.PreviousTimestampUTC, a.TimestampUTC) > 12) OR (a.PreviousSumWaitTimeMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL	-- Ignore 1. data set - Yes we loose one data set but better than having visuals showing very high data
							WHEN (a.PreviousSumWaitTimeMS > a.SumWaitTimeMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.SumWaitTimeMS							-- Either has the counters had an overflow or the server har been restarted
							ELSE a.SumWaitTimeMS - a.PreviousSumWaitTimeMS																													-- Difference
						END AS DeltaSumWaitTimeMS
						,CASE
							WHEN (DATEDIFF(HOUR, a.PreviousTimestampUTC, a.TimestampUTC) > 12) OR (a.PreviousSumSignalWaitTimeMS IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
							WHEN (a.PreviousSumSignalWaitTimeMS > a.SumSignalWaitTimeMS) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.SumSignalWaitTimeMS
							ELSE a.SumSignalWaitTimeMS - a.PreviousSumSignalWaitTimeMS
						END AS DeltaSumSignalWaitTimeMS
						,CASE
							WHEN (DATEDIFF(HOUR, a.PreviousTimestampUTC, a.TimestampUTC) > 12) OR (a.PreviousSumWaitingTasks IS NULL) OR (a.PreviousLastSQLServiceRestart IS NULL) THEN NULL
							WHEN (a.PreviousSumWaitingTasks > a.SumWaitingTasks) OR (a.PreviousLastSQLServiceRestart <> a.LastSQLServiceRestart) THEN a.SumWaitingTasks
							ELSE a.SumWaitingTasks - a.PreviousSumWaitingTasks
						END AS DeltaSumWaitingTasks

						,a.Timestamp
						,a.WaitType
					FROM (
			'';
			IF (@productVersion1 <= 10)
			BEGIN
				-- SQL Versions SQL2008R2 or lower

				SET @stmt += ''
						SELECT
							ws.SumWaitTimeMS
							,prevWs.SumWaitTimeMS AS PreviousSumWaitTimeMS
							,ws.SumSignalWaitTimeMS
							,prevWs.SumSignalWaitTimeMS AS PreviousSumSignalWaitTimeMS
							,ws.SumWaitingTasks
							,prevWs.SumWaitingTasks AS PreviousSumWaitingTasks
							,ws.LastSQLServiceRestart
							,prevWs.LastSQLServiceRestart AS PreviousLastSQLServiceRestart
							,ws.TimestampUTC
							,prevWs.TimestampUTC AS PreviousTimestampUTC

							,ws.Timestamp
							,ws.WaitType
						FROM waitStatistics AS ws
						LEFT OUTER JOIN waitStatistics AS prevWs ON
							(prevWs.WaitType = ws.WaitType)
							AND (prevWs.Idx = ws.Idx - 1)
				'';
			END
			ELSE BEGIN
				-- SQL Versions SQL2012 or higher

				SET @stmt += ''
						SELECT
							ws.SumWaitTimeMS
							,LAG(ws.SumWaitTimeMS) OVER(PARTITION BY ws.WaitType ORDER BY ws.TimestampUTC) AS PreviousSumWaitTimeMS
							,ws.SumSignalWaitTimeMS
							,LAG(ws.SumSignalWaitTimeMS) OVER(PARTITION BY ws.WaitType ORDER BY ws.TimestampUTC) AS PreviousSumSignalWaitTimeMS
							,ws.SumWaitingTasks
							,LAG(ws.SumWaitingTasks) OVER(PARTITION BY ws.WaitType ORDER BY ws.TimestampUTC) AS PreviousSumWaitingTasks
							,ws.LastSQLServiceRestart
							,LAG(ws.LastSQLServiceRestart) OVER(PARTITION BY ws.WaitType ORDER BY ws.TimestampUTC) AS PreviousLastSQLServiceRestart
							,ws.TimestampUTC
							,LAG(ws.TimestampUTC) OVER(PARTITION BY ws.WaitType ORDER BY ws.TimestampUTC) AS PreviousTimestampUTC

							,ws.Timestamp
							,ws.WaitType
						FROM dbo.fhsmWaitStatistics AS ws
				'';
			END;
			SET @stmt += ''
					) AS a
				) AS b
				WHERE
					(b.DeltaSumWaitTimeMS <> 0)
					OR (b.DeltaSumSignalWaitTimeMS <> 0)
					OR (b.DeltaSumWaitingTasks <> 0);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Wait statistics]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Wait statistics'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPWaitStatistics
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPWaitStatistics'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPWaitStatistics AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPWaitStatistics (
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @now datetime;
					DECLARE @nowUTC datetime;
					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					--
					-- Get the parameter for the command
					--
					BEGIN
						SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);
					END;

					--
					-- Collect data
					--
					BEGIN
						SELECT
							@now = SYSDATETIME()
							,@nowUTC = SYSUTCDATETIME();

						SET @stmt = ''''
							SELECT
								a.wait_type AS WaitType
								,SUM(a.sum_wait_time_ms) AS SumWaitTimeMS
								,SUM(a.sum_signal_wait_time_ms) AS SumSignalWaitTimeMS
								,SUM(a.sum_waiting_tasks) AS SumWaitingTasks
								,(SELECT d.create_date FROM sys.databases AS d WITH (NOLOCK) WHERE (d.name = ''''''''tempdb'''''''')) AS LastSQLServiceRestart
								,@nowUTC, @now
							FROM (
								SELECT
									owt.wait_type
									,SUM(owt.wait_duration_ms) AS sum_wait_time_ms
									,0 AS sum_signal_wait_time_ms
									,0 AS sum_waiting_tasks
								FROM sys.dm_os_waiting_tasks AS owt WITH (NOLOCK)
								WHERE (owt.session_id > 50)
								GROUP BY owt.wait_type

								UNION ALL

								SELECT
									os.wait_type
									,SUM(os.wait_time_ms) AS sum_wait_time_ms
									,SUM(os.signal_wait_time_ms) AS sum_signal_wait_time_ms
									,SUM(os.waiting_tasks_count) AS sum_waiting_tasks
								FROM sys.dm_os_wait_stats AS os WITH (NOLOCK)
								GROUP BY os.wait_type
							) a
							WHERE EXISTS (
								SELECT *
								FROM dbo.fhsmWaitCategories AS wc
								WHERE (wc.WaitType COLLATE DATABASE_DEFAULT = a.wait_type)
									AND (wc.Ignorable = 0)
							)
							GROUP BY a.wait_type;
						'''';
						INSERT INTO dbo.fhsmWaitStatistics(
							WaitType
							,SumWaitTimeMS, SumSignalWaitTimeMS, SumWaitingTasks
							,LastSQLServiceRestart
							,TimestampUTC, Timestamp
						)
						EXEC sp_executesql
							@stmt
							,N''''@now datetime, @nowUTC datetime''''
							,@now = @now, @nowUTC = @nowUTC;
					END;

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPWaitStatistics
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPWaitStatistics'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmWaitStatistics''
				,1
				,''TimestampUTC''
				,1
				,30
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableWaitStatistics							AS Enabled
				,0												AS DeploymentStatus
				,''Wait statistics''								AS Name
				,PARSENAME(''dbo.fhsmSPWaitStatistics'', 1)		AS Task
				,1 * 60 * 60									AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,NULL											AS Parameter
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1
			,OutputColumn1
		) AS (
			SELECT
				''Wait type'' AS DimensionName
				,''WaitKey'' AS DimensionKey
				,''dbo.fhsmWaitStatistics'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[WaitType]''
				,''Wait type''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.OutputColumn1 = src.OutputColumn1
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1
				,OutputColumn1
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1
				,src.OutputColumn1
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmWaitStatistics'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:WhoIsActive-001-AdamMachanic-12.00-sp_WhoIsActive.sql modified: 2025.02.17 18.45.42
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing WhoIsActive-001'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @returnValue int;
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = ''sp_WhoIsActive'')
BEGIN
    EXEC (''CREATE PROC dbo.sp_WhoIsActive AS SELECT ''''stub version, to be replaced'''''')
END;

DECLARE @stmt nvarchar(max);
SET @stmt = ''
/*********************************************************************************************
Who Is Active? v12.00 (2021-11-10)
(C) 2007-2021, Adam Machanic

Feedback: https://github.com/amachanic/sp_whoisactive/issues
Releases: https://github.com/amachanic/sp_whoisactive/releases
Docs: http://whoisactive.com

License:
    https://github.com/amachanic/sp_whoisactive/blob/master/LICENSE
*********************************************************************************************/
ALTER PROC dbo.sp_WhoIsActive
(
--~
    --Filters--Both inclusive and exclusive
    --Set either filter to '''''''' to disable
    --Valid filter types are: session, program, database, login, and host
    --Session is a session ID, and either 0 or '''''''' can be used to indicate "all" sessions
    --All other filter types support % or _ as wildcards
    @filter sysname = '''''''',
    @filter_type VARCHAR(10) = ''''session'''',
    @not_filter sysname = '''''''',
    @not_filter_type VARCHAR(10) = ''''session'''',

    --Retrieve data about the calling session?
    @show_own_spid BIT = 0,

    --Retrieve data about system sessions?
    @show_system_spids BIT = 0,

    --Controls how sleeping SPIDs are handled, based on the idea of levels of interest
    --0 does not pull any sleeping SPIDs
    --1 pulls only those sleeping SPIDs that also have an open transaction
    --2 pulls all sleeping SPIDs
    @show_sleeping_spids TINYINT = 1,

    --If 1, gets the full stored procedure or running batch, when available
    --If 0, gets only the actual statement that is currently running in the batch or procedure
    @get_full_inner_text BIT = 0,

    --Get associated query plans for running tasks, if available
    --If @get_plans = 1, gets the plan based on the request''''s statement offset
    --If @get_plans = 2, gets the entire plan based on the request''''s plan_handle
    @get_plans TINYINT = 0,

    --Get the associated outer ad hoc query or stored procedure call, if available
    @get_outer_command BIT = 0,

    --Enables pulling transaction log write info, transaction duration, and the
    --implicit_transaction identification column
    @get_transaction_info BIT = 0,

    --Get information on active tasks, based on three interest levels
    --Level 0 does not pull any task-related information
    --Level 1 is a lightweight mode that pulls the top non-CXPACKET wait, giving preference to blockers
    --Level 2 pulls all available task-based metrics, including:
    --number of active tasks, current wait stats, physical I/O, context switches, and blocker information
    @get_task_info TINYINT = 1,

    --Gets associated locks for each request, aggregated in an XML format
    @get_locks BIT = 0,

    --Get average time for past runs of an active query
    --(based on the combination of plan handle, sql handle, and offset)
    @get_avg_time BIT = 0,

    --Get additional non-performance-related information about the session or request
    --text_size, language, date_format, date_first, quoted_identifier, arithabort, ansi_null_dflt_on,
    --ansi_defaults, ansi_warnings, ansi_padding, ansi_nulls, concat_null_yields_null,
    --transaction_isolation_level, lock_timeout, deadlock_priority, row_count, command_type
    --
    --If a SQL Agent job is running, an subnode called agent_info will be populated with some or all of
    --the following: job_id, job_name, step_id, step_name, msdb_query_error (in the event of an error)
    --
    --If @get_task_info is set to 2 and a lock wait is detected, a subnode called block_info will be
    --populated with some or all of the following: lock_type, database_name, object_id, file_id, hobt_id,
    --applock_hash, metadata_resource, metadata_class_id, object_name, schema_name
    @get_additional_info BIT = 0,

    --Get additional information related to workspace memory
    --requested_memory, granted_memory, max_used_memory, and memory_info.
    --
    --Not available for SQL Server 2005.
    @get_memory_info BIT = 0,

    --Walk the blocking chain and count the number of
    --total SPIDs blocked all the way down by a given session
    --Also enables task_info Level 1, if @get_task_info is set to 0
    @find_block_leaders BIT = 0,

    --Pull deltas on various metrics
    --Interval in seconds to wait before doing the second data pull
    @delta_interval TINYINT = 0,

    --List of desired output columns, in desired order
    --Note that the final output will be the intersection of all enabled features and all
    --columns in the list. Therefore, only columns associated with enabled features will
    --actually appear in the output. Likewise, removing columns from this list may effectively
    --disable features, even if they are turned on
    --
    --Each element in this list must be one of the valid output column names. Names must be
    --delimited by square brackets. White space, formatting, and additional characters are
    --allowed, as long as the list contains exact matches of delimited valid column names.
    @output_column_list VARCHAR(8000) = ''''[dd%][session_id][sql_text][sql_command][login_name][wait_info][tasks][tran_log%][cpu%][temp%][block%][reads%][writes%][context%][physical%][query_plan][locks][%]'''',

    --Column(s) by which to sort output, optionally with sort directions.
        --Valid column choices:
        --session_id, physical_io, reads, physical_reads, writes, tempdb_allocations,
        --tempdb_current, CPU, context_switches, used_memory, physical_io_delta, reads_delta,
        --physical_reads_delta, writes_delta, tempdb_allocations_delta, tempdb_current_delta,
        --CPU_delta, context_switches_delta, used_memory_delta, tasks, tran_start_time,
        --open_tran_count, blocking_session_id, blocked_session_count, percent_complete,
        --host_name, login_name, database_name, start_time, login_time, program_name
        --
        --Note that column names in the list must be bracket-delimited. Commas and/or white
        --space are not required.
    @sort_order VARCHAR(500) = ''''[start_time] ASC'''',

    --Formats some of the output columns in a more "human readable" form
    --0 disables outfput format
    --1 formats the output for variable-width fonts
    --2 formats the output for fixed-width fonts
    @format_output TINYINT = 1,

    --If set to a non-blank value, the script will attempt to insert into the specified
    --destination table. Please note that the script will not verify that the table exists,
    --or that it has the correct schema, before doing the insert.
    --Table can be specified in one, two, or three-part format
    @destination_table VARCHAR(4000) = '''''''',

    --If set to 1, no data collection will happen and no result set will be returned; instead,
    --a CREATE TABLE statement will be returned via the @schema parameter, which will match
    --the schema of the result set that would be returned by using the same collection of the
    --rest of the parameters. The CREATE TABLE statement will have a placeholder token of
    --<table_name> in place of an actual table name.
    @return_schema BIT = 0,
    @schema VARCHAR(MAX) = NULL OUTPUT,

    --Help! What do I do?
    @help BIT = 0
--~
)
/*
OUTPUT COLUMNS
--------------
Formatted/Non:    [session_id] [smallint] NOT NULL
    Session ID (a.k.a. SPID)

Formatted:        [dd hh:mm:ss.mss] [varchar](15) NULL
Non-Formatted:    <not returned>
    For an active request, time the query has been running
    For a sleeping session, time since the last batch completed

Formatted:        [dd hh:mm:ss.mss (avg)] [varchar](15) NULL
Non-Formatted:    [avg_elapsed_time] [int] NULL
    (Requires @get_avg_time option)
    How much time has the active portion of the query taken in the past, on average?

Formatted:        [physical_io] [varchar](30) NULL
Non-Formatted:    [physical_io] [bigint] NULL
    Shows the number of physical I/Os, for active requests

Formatted:        [reads] [varchar](30) NULL
Non-Formatted:    [reads] [bigint] NULL
    For an active request, number of reads done for the current query
    For a sleeping session, total number of reads done over the lifetime of the session

Formatted:        [physical_reads] [varchar](30) NULL
Non-Formatted:    [physical_reads] [bigint] NULL
    For an active request, number of physical reads done for the current query
    For a sleeping session, total number of physical reads done over the lifetime of the session

Formatted:        [writes] [varchar](30) NULL
Non-Formatted:    [writes] [bigint] NULL
    For an active request, number of writes done for the current query
    For a sleeping session, total number of writes done over the lifetime of the session

Formatted:        [tempdb_allocations] [varchar](30) NULL
Non-Formatted:    [tempdb_allocations] [bigint] NULL
    For an active request, number of TempDB writes done for the current query
    For a sleeping session, total number of TempDB writes done over the lifetime of the session

Formatted:        [tempdb_current] [varchar](30) NULL
Non-Formatted:    [tempdb_current] [bigint] NULL
    For an active request, number of TempDB pages currently allocated for the query
    For a sleeping session, number of TempDB pages currently allocated for the session

Formatted:        [CPU] [varchar](30) NULL
Non-Formatted:    [CPU] [bigint] NULL
    For an active request, total CPU time consumed by the current query
    For a sleeping session, total CPU time consumed over the lifetime of the session

Formatted:        [context_switches] [varchar](30) NULL
Non-Formatted:    [context_switches] [bigint] NULL
    Shows the number of context switches, for active requests

Formatted:        [used_memory] [varchar](30) NOT NULL
Non-Formatted:    [used_memory] [bigint] NOT NULL
    For an active request, total memory consumption for the current query
    For a sleeping session, total current memory consumption

Formatted:        [max_used_memory] [varchar](30) NULL
Non-Formatted:    [max_used_memory] [bigint] NULL
    (Requires @get_memory_info = 1)
    For an active request, the maximum amount of memory that has been used during
    processing up to the point of observation for the current query

Formatted:        [requested_memory] [varchar](30) NULL
Non-Formatted:    [requested_memory] [bigint] NULL
    (Requires @get_memory_info = 1)
    For an active request, the amount of memory requested by the query processor
    for hash, sort, and parallelism operations

Formatted:        [granted_memory] [varchar](30) NULL
Non-Formatted:    [granted_memory] [bigint] NULL
    (Requires @get_memory_info = 1)
    For an active request, the amount of memory granted to the query processor
    for hash, sort, and parallelism operations

Formatted:        [physical_io_delta] [varchar](30) NULL
Non-Formatted:    [physical_io_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the number of physical I/Os reported on the first and second collections.
    If the request started after the first collection, the value will be NULL

Formatted:        [reads_delta] [varchar](30) NULL
Non-Formatted:    [reads_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the number of reads reported on the first and second collections.
    If the request started after the first collection, the value will be NULL

Formatted:        [physical_reads_delta] [varchar](30) NULL
Non-Formatted:    [physical_reads_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the number of physical reads reported on the first and second collections.
    If the request started after the first collection, the value will be NULL

Formatted:        [writes_delta] [varchar](30) NULL
Non-Formatted:    [writes_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the number of writes reported on the first and second collections.
    If the request started after the first collection, the value will be NULL

Formatted:        [tempdb_allocations_delta] [varchar](30) NULL
Non-Formatted:    [tempdb_allocations_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the number of TempDB writes reported on the first and second collections.
    If the request started after the first collection, the value will be NULL

Formatted:        [tempdb_current_delta] [varchar](30) NULL
Non-Formatted:    [tempdb_current_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the number of allocated TempDB pages reported on the first and second
    collections. If the request started after the first collection, the value will be NULL

Formatted:        [CPU_delta] [varchar](30) NULL
Non-Formatted:    [CPU_delta] [int] NULL
    (Requires @delta_interval option)
    Difference between the CPU time reported on the first and second collections.
    If the request started after the first collection, the value will be NULL

Formatted:        [context_switches_delta] [varchar](30) NULL
Non-Formatted:    [context_switches_delta] [bigint] NULL
    (Requires @delta_interval option)
    Difference between the context switches count reported on the first and second collections
    If the request started after the first collection, the value will be NULL

Formatted:        [used_memory_delta] [varchar](30) NULL
Non-Formatted:    [used_memory_delta] [bigint] NULL
    Difference between the memory usage reported on the first and second collections
    If the request started after the first collection, the value will be NULL

Formatted:        [max_used_memory_delta] [varchar](30) NULL
Non-Formatted:    [max_used_memory_delta] [bigint] NULL
    Difference between the max memory usage reported on the first and second collections
    If the request started after the first collection, the value will be NULL

Formatted:        [tasks] [varchar](30) NULL
Non-Formatted:    [tasks] [smallint] NULL
    Number of worker tasks currently allocated, for active requests

Formatted/Non:    [status] [varchar](30) NOT NULL
    Activity status for the session (running, sleeping, etc)

Formatted/Non:    [wait_info] [nvarchar](4000) NULL
    Aggregates wait information, in the following format:
        (Ax: Bms/Cms/Dms)E
    A is the number of waiting tasks currently waiting on resource type E. B/C/D are wait
    times, in milliseconds. If only one thread is waiting, its wait time will be shown as B.
    If two tasks are waiting, each of their wait times will be shown (B/C). If three or more
    tasks are waiting, the minimum, average, and maximum wait times will be shown (B/C/D).
    If wait type E is a page latch wait and the page is of a "special" type (e.g. PFS, GAM, SGAM),
    the page type will be identified.
    If wait type E is CXPACKET, CXCONSUMER, CXSYNC_PORT, or CXSYNC_CONSUMER the nodeId from the
    query plan will be identified

Formatted/Non:    [locks] [xml] NULL
    (Requires @get_locks option)
    Aggregates lock information, in XML format.
    The lock XML includes the lock mode, locked object, and aggregates the number of requests.
    Attempts are made to identify locked objects by name

Formatted/Non:    [tran_start_time] [datetime] NULL
    (Requires @get_transaction_info option)
    Date and time that the first transaction opened by a session caused a transaction log
    write to occur.

Formatted/Non:    [tran_log_writes] [nvarchar](4000) NULL
    (Requires @get_transaction_info option)
    Aggregates transaction log write information, in the following format:
    A:wB (C kB)
    A is a database that has been touched by an active transaction
    B is the number of log writes that have been made in the database as a result of the transaction
    C is the number of log kilobytes consumed by the log records

Formatted/Non:    [implicit_tran] [nvarchar](3) NULL
    (Requires @get_transaction_info option)
    For active read-write transactions, returns on "ON" the transaction has been started as a result
    of the session using the implicit_transactions option, or "OFF" otherwise.

Formatted:        [open_tran_count] [varchar](30) NULL
Non-Formatted:    [open_tran_count] [smallint] NULL
    Shows the number of open transactions the session has open

Formatted:        [sql_command] [xml] NULL
Non-Formatted:    [sql_command] [nvarchar](max) NULL
    (Requires @get_outer_command option)
    Shows the "outer" SQL command, i.e. the text of the batch or RPC sent to the server,
    if available

Formatted:        [sql_text] [xml] NULL
Non-Formatted:    [sql_text] [nvarchar](max) NULL
    Shows the SQL text for active requests or the last statement executed
    for sleeping sessions, if available in either case.
    If @get_full_inner_text option is set, shows the full text of the batch.
    Otherwise, shows only the active statement within the batch.
    If the query text is locked, a special timeout message will be sent, in the following format:
        <timeout_exceeded />
    If an error occurs, an error message will be sent, in the following format:
        <error message="message" />

Formatted/Non:    [query_plan] [xml] NULL
    (Requires @get_plans option)
    Shows the query plan for the request, if available.
    If the plan is locked, a special timeout message will be sent, in the following format:
        <timeout_exceeded />
    If an error occurs, an error message will be sent, in the following format:
        <error message="message" />

Formatted/Non:    [blocking_session_id] [smallint] NULL
    When applicable, shows the blocking SPID

Formatted:        [blocked_session_count] [varchar](30) NULL
Non-Formatted:    [blocked_session_count] [smallint] NULL
    (Requires @find_block_leaders option)
    The total number of SPIDs blocked by this session,
    all the way down the blocking chain.

Formatted:        [percent_complete] [varchar](30) NULL
Non-Formatted:    [percent_complete] [real] NULL
    When applicable, shows the percent complete (e.g. for backups, restores, and some rollbacks)

Formatted/Non:    [host_name] [sysname] NOT NULL
    Shows the host name for the connection

Formatted/Non:    [login_name] [sysname] NOT NULL
    Shows the login name for the connection

Formatted/Non:    [database_name] [sysname] NULL
    Shows the connected database

Formatted/Non:    [program_name] [sysname] NULL
    Shows the reported program/application name

Formatted/Non:    [additional_info] [xml] NULL
    (Requires @get_additional_info option)
    Returns additional non-performance-related session/request information
    If the script finds a SQL Agent job running, the name of the job and job step will be reported
    If @get_task_info = 2 and the script finds a lock wait, the locked object will be reported

Formatted/Non:    [start_time] [datetime] NOT NULL
    For active requests, shows the time the request started
    For sleeping sessions, shows the time the last batch completed

Formatted/Non:    [login_time] [datetime] NOT NULL
    Shows the time that the session connected

Formatted/Non:    [request_id] [int] NULL
    For active requests, shows the request_id
    Should be 0 unless MARS is being used

Formatted/Non:    [collection_time] [datetime] NOT NULL
    Time that this script''''s final SELECT ran

Formatted/Non:    [memory_info] [xml] NULL
    (Requires @get_memory_info)
    For active queries that require workspace memory, returns information on memory grants,
    resource semaphores, and the resource governor settings that are impacting the allocation.
*/
AS
BEGIN;
    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    SET QUOTED_IDENTIFIER ON;
    SET ANSI_PADDING ON;
    SET CONCAT_NULL_YIELDS_NULL ON;
    SET ANSI_WARNINGS ON;
    SET NUMERIC_ROUNDABORT OFF;
    SET ARITHABORT ON;

    IF
        @filter IS NULL
        OR @filter_type IS NULL
        OR @not_filter IS NULL
        OR @not_filter_type IS NULL
        OR @show_own_spid IS NULL
        OR @show_system_spids IS NULL
        OR @show_sleeping_spids IS NULL
        OR @get_full_inner_text IS NULL
        OR @get_plans IS NULL
        OR @get_outer_command IS NULL
        OR @get_transaction_info IS NULL
        OR @get_task_info IS NULL
        OR @get_locks IS NULL
        OR @get_avg_time IS NULL
        OR @get_additional_info IS NULL
        OR @find_block_leaders IS NULL
        OR @delta_interval IS NULL
        OR @format_output IS NULL
        OR @output_column_list IS NULL
        OR @sort_order IS NULL
        OR @return_schema IS NULL
        OR @destination_table IS NULL
        OR @help IS NULL
    BEGIN;
        RAISERROR(''''Input parameters cannot be NULL'''', 16, 1);
        RETURN;
    END;
   
    IF @filter_type NOT IN (''''session'''', ''''program'''', ''''database'''', ''''login'''', ''''host'''')
    BEGIN;
        RAISERROR(''''Valid filter types are: session, program, database, login, host'''', 16, 1);
        RETURN;
    END;
   
    IF @filter_type = ''''session'''' AND @filter LIKE ''''%[^0123456789]%''''
    BEGIN;
        RAISERROR(''''Session filters must be valid integers'''', 16, 1);
        RETURN;
    END;
   
    IF @not_filter_type NOT IN (''''session'''', ''''program'''', ''''database'''', ''''login'''', ''''host'''')
    BEGIN;
        RAISERROR(''''Valid filter types are: session, program, database, login, host'''', 16, 1);
        RETURN;
    END;
   
    IF @not_filter_type = ''''session'''' AND @not_filter LIKE ''''%[^0123456789]%''''
    BEGIN;
        RAISERROR(''''Session filters must be valid integers'''', 16, 1);
        RETURN;
    END;
   
    IF @show_sleeping_spids NOT IN (0, 1, 2)
    BEGIN;
        RAISERROR(''''Valid values for @show_sleeping_spids are: 0, 1, or 2'''', 16, 1);
        RETURN;
    END;
   
    IF @get_plans NOT IN (0, 1, 2)
    BEGIN;
        RAISERROR(''''Valid values for @get_plans are: 0, 1, or 2'''', 16, 1);
        RETURN;
    END;

    IF @get_task_info NOT IN (0, 1, 2)
    BEGIN;
        RAISERROR(''''Valid values for @get_task_info are: 0, 1, or 2'''', 16, 1);
        RETURN;
    END;

    IF @format_output NOT IN (0, 1, 2)
    BEGIN;
        RAISERROR(''''Valid values for @format_output are: 0, 1, or 2'''', 16, 1);
        RETURN;
    END;

    IF @get_memory_info = 1 AND NOT EXISTS (SELECT * FROM sys.all_objects WHERE name = ''''resource_governor_resource_pools'''')
    BEGIN;
        RAISERROR(''''@get_memory_info is not available for SQL Server 2005.'''', 16, 1);
        RETURN;
    END;

    IF @help = 1
    BEGIN;
        DECLARE
            @header VARCHAR(MAX),
            @params VARCHAR(MAX),
            @outputs VARCHAR(MAX);

        SELECT
            @header =
                REPLACE
                (
                    REPLACE
                    (
                        CONVERT
                        (
                            VARCHAR(MAX),
                            SUBSTRING
                            (
                                t.text,
                                CHARINDEX(''''/'''' + REPLICATE(''''*'''', 93), t.text) + 94,
                                CHARINDEX(REPLICATE(''''*'''', 93) + ''''/'''', t.text) - (CHARINDEX(''''/'''' + REPLICATE(''''*'''', 93), t.text) + 94)
                            )
                        ),
                        CHAR(13)+CHAR(10),
                        CHAR(13)
                    ),
                    ''''    '''',
                    ''''''''
                ),
            @params =
                CHAR(13) +
                    REPLACE
                    (
                        REPLACE
                        (
                            CONVERT
                            (
                                VARCHAR(MAX),
                                SUBSTRING
                                (
                                    t.text,
                                    CHARINDEX(''''--~'''', t.text) + 5,
                                    CHARINDEX(''''--~'''', t.text, CHARINDEX(''''--~'''', t.text) + 5) - (CHARINDEX(''''--~'''', t.text) + 5)
                                )
                            ),
                            CHAR(13)+CHAR(10),
                            CHAR(13)
                        ),
                        ''''    '''',
                        ''''''''
                    ),
                @outputs =
                    CHAR(13) +
                        REPLACE
                        (
                            REPLACE
                            (
                                REPLACE
                                (
                                    CONVERT
                                    (
                                        VARCHAR(MAX),
                                        SUBSTRING
                                        (
                                            t.text,
                                            CHARINDEX(''''OUTPUT COLUMNS''''+CHAR(13)+CHAR(10)+''''--------------'''', t.text) + 32,
                                            CHARINDEX(''''*/'''', t.text, CHARINDEX(''''OUTPUT COLUMNS''''+CHAR(13)+CHAR(10)+''''--------------'''', t.text) + 32) - (CHARINDEX(''''OUTPUT COLUMNS''''+CHAR(13)+CHAR(10)+''''--------------'''', t.text) + 32)
                                        )
                                    ),
                                    ''''    '''',
                                    CHAR(255)
                                ),
                                CHAR(13)+CHAR(10),
                                CHAR(13)
                            ),
                            ''''    '''',
                            ''''''''
                        ) +
                        CHAR(13)
        FROM sys.dm_exec_requests AS r
        CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
        WHERE
            r.session_id = @@SPID;

        WITH
        a0 AS
        (SELECT 1 AS n UNION ALL SELECT 1),
        a1 AS
        (SELECT 1 AS n FROM a0 AS a CROSS JOIN a0 AS b),
        a2 AS
        (SELECT 1 AS n FROM a1 AS a CROSS JOIN a1 AS b),
        a3 AS
        (SELECT 1 AS n FROM a2 AS a CROSS JOIN a2 AS b),
        a4 AS
        (SELECT 1 AS n FROM a3 AS a CROSS JOIN a3 AS b),
        numbers AS
        (
            SELECT TOP(LEN(@header) - 1)
                ROW_NUMBER() OVER
                (
                    ORDER BY (SELECT NULL)
                ) AS number
            FROM a4
            ORDER BY
                number
        )
        SELECT
            RTRIM(LTRIM(
                SUBSTRING
                (
                    @header,
                    number + 1,
                    CHARINDEX(CHAR(13), @header, number + 1) - number - 1
                )
            )) AS [------header---------------------------------------------------------------------------------------------------------------]
        FROM numbers
        WHERE
            SUBSTRING(@header, number, 1) = CHAR(13);

        WITH
        a0 AS
        (SELECT 1 AS n UNION ALL SELECT 1),
        a1 AS
        (SELECT 1 AS n FROM a0 AS a CROSS JOIN a0 AS b),
        a2 AS
        (SELECT 1 AS n FROM a1 AS a CROSS JOIN a1 AS b),
        a3 AS
        (SELECT 1 AS n FROM a2 AS a CROSS JOIN a2 AS b),
        a4 AS
        (SELECT 1 AS n FROM a3 AS a CROSS JOIN a3 AS b),
        numbers AS
        (
            SELECT TOP(LEN(@params) - 1)
                ROW_NUMBER() OVER
                (
                    ORDER BY (SELECT NULL)
                ) AS number
            FROM a4
            ORDER BY
                number
        ),
        tokens AS
        (
            SELECT
                RTRIM(LTRIM(
                    SUBSTRING
                    (
                        @params,
                        number + 1,
                        CHARINDEX(CHAR(13), @params, number + 1) - number - 1
                    )
                )) AS token,
                number,
                CASE
                    WHEN SUBSTRING(@params, number + 1, 1) = CHAR(13) THEN number
                    ELSE COALESCE(NULLIF(CHARINDEX('''','''' + CHAR(13) + CHAR(13), @params, number), 0), LEN(@params))
                END AS param_group,
                ROW_NUMBER() OVER
                (
                    PARTITION BY
                        CHARINDEX('''','''' + CHAR(13) + CHAR(13), @params, number),
                        SUBSTRING(@params, number+1, 1)
                    ORDER BY
                        number
                ) AS group_order
            FROM numbers
            WHERE
                SUBSTRING(@params, number, 1) = CHAR(13)
        ),
        parsed_tokens AS
        (
            SELECT
                MIN
                (
                    CASE
                        WHEN token LIKE ''''@%'''' THEN token
                        ELSE NULL
                    END
                ) AS parameter,
                MIN
                (
                    CASE
                        WHEN token LIKE ''''--%'''' THEN RIGHT(token, LEN(token) - 2)
                        ELSE NULL
                    END
                ) AS description,
                param_group,
                group_order
            FROM tokens
            WHERE
                NOT
                (
                    token = ''''''''
                    AND group_order > 1
                )
            GROUP BY
                param_group,
                group_order
        )
        SELECT
            CASE
                WHEN description IS NULL AND parameter IS NULL THEN ''''-------------------------------------------------------------------------''''
                WHEN param_group = MAX(param_group) OVER() THEN parameter
                ELSE COALESCE(LEFT(parameter, LEN(parameter) - 1), '''''''')
            END AS [------parameter----------------------------------------------------------],
            CASE
                WHEN description IS NULL AND parameter IS NULL THEN ''''----------------------------------------------------------------------------------------------------------------------''''
                ELSE COALESCE(description, '''''''')
            END AS [------description-----------------------------------------------------------------------------------------------------]
        FROM parsed_tokens
        ORDER BY
            param_group,
            group_order;
       
        WITH
        a0 AS
        (SELECT 1 AS n UNION ALL SELECT 1),
        a1 AS
        (SELECT 1 AS n FROM a0 AS a CROSS JOIN a0 AS b),
        a2 AS
        (SELECT 1 AS n FROM a1 AS a CROSS JOIN a1 AS b),
        a3 AS
        (SELECT 1 AS n FROM a2 AS a CROSS JOIN a2 AS b),
        a4 AS
        (SELECT 1 AS n FROM a3 AS a CROSS JOIN a3 AS b),
        numbers AS
        (
            SELECT TOP(LEN(@outputs) - 1)
                ROW_NUMBER() OVER
                (
                    ORDER BY (SELECT NULL)
                ) AS number
            FROM a4
            ORDER BY
                number
        ),
        tokens AS
        (
            SELECT
                RTRIM(LTRIM(
                    SUBSTRING
                    (
                        @outputs,
                        number + 1,
                        CASE
                            WHEN
                                COALESCE(NULLIF(CHARINDEX(CHAR(13) + ''''Formatted'''', @outputs, number + 1), 0), LEN(@outputs)) <
                                    COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs))
                                THEN COALESCE(NULLIF(CHARINDEX(CHAR(13) + ''''Formatted'''', @outputs, number + 1), 0), LEN(@outputs)) - number - 1
                            ELSE
                                COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs)) - number - 1
                        END
                    )
                )) AS token,
                number,
                COALESCE(NULLIF(CHARINDEX(CHAR(13) + ''''Formatted'''', @outputs, number + 1), 0), LEN(@outputs)) AS output_group,
                ROW_NUMBER() OVER
                (
                    PARTITION BY
                        COALESCE(NULLIF(CHARINDEX(CHAR(13) + ''''Formatted'''', @outputs, number + 1), 0), LEN(@outputs))
                    ORDER BY
                        number
                ) AS output_group_order
            FROM numbers
            WHERE
                SUBSTRING(@outputs, number, 10) = CHAR(13) + ''''Formatted''''
                OR SUBSTRING(@outputs, number, 2) = CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2
        ),
        output_tokens AS
        (
            SELECT
                *,
                CASE output_group_order
                    WHEN 2 THEN MAX(CASE output_group_order WHEN 1 THEN token ELSE NULL END) OVER (PARTITION BY output_group)
                    ELSE ''''''''
                END COLLATE Latin1_General_Bin2 AS column_info
            FROM tokens
        )
        SELECT
            CASE output_group_order
                WHEN 1 THEN ''''-----------------------------------''''
                WHEN 2 THEN
                    CASE
                        WHEN CHARINDEX(''''Formatted/Non:'''', column_info) = 1 THEN
                            SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+1, CHARINDEX('''']'''', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info))
                        ELSE
                            SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2, CHARINDEX('''']'''', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)-1)
                    END
                ELSE ''''''''
            END AS formatted_column_name,
            CASE output_group_order
                WHEN 1 THEN ''''-----------------------------------''''
                WHEN 2 THEN
                    CASE
                        WHEN CHARINDEX(''''Formatted/Non:'''', column_info) = 1 THEN
                            SUBSTRING(column_info, CHARINDEX('''']'''', column_info)+2, LEN(column_info))
                        ELSE
                            SUBSTRING(column_info, CHARINDEX('''']'''', column_info)+2, CHARINDEX(''''Non-Formatted:'''', column_info, CHARINDEX('''']'''', column_info)+2) - CHARINDEX('''']'''', column_info)-3)
                    END
                ELSE ''''''''
            END AS formatted_column_type,
            CASE output_group_order
                WHEN 1 THEN ''''---------------------------------------''''
                WHEN 2 THEN
                    CASE
                        WHEN CHARINDEX(''''Formatted/Non:'''', column_info) = 1 THEN ''''''''
                        ELSE
                            CASE
                                WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+1, 1) = ''''<'''' THEN
                                    SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+1, CHARINDEX(''''>'''', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info)))
                                ELSE
                                    SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+1, CHARINDEX('''']'''', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info)))
                            END
                    END
                ELSE ''''''''
            END AS unformatted_column_name,
            CASE output_group_order
                WHEN 1 THEN ''''---------------------------------------''''
                WHEN 2 THEN
                    CASE
                        WHEN CHARINDEX(''''Formatted/Non:'''', column_info) = 1 THEN ''''''''
                        ELSE
                            CASE
                                WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+1, 1) = ''''<'''' THEN ''''''''
                                ELSE
                                    SUBSTRING(column_info, CHARINDEX('''']'''', column_info, CHARINDEX(''''Non-Formatted:'''', column_info))+2, CHARINDEX(''''Non-Formatted:'''', column_info, CHARINDEX('''']'''', column_info)+2) - CHARINDEX('''']'''', column_info)-3)
                            END
                    END
                ELSE ''''''''
            END AS unformatted_column_type,
            CASE output_group_order
                WHEN 1 THEN ''''----------------------------------------------------------------------------------------------------------------------''''
                ELSE REPLACE(token, CHAR(255) COLLATE Latin1_General_Bin2, '''''''')
            END AS [------description-----------------------------------------------------------------------------------------------------]
        FROM output_tokens
        WHERE
            NOT
            (
                output_group_order = 1
                AND output_group = LEN(@outputs)
            )
        ORDER BY
            output_group,
            CASE output_group_order
                WHEN 1 THEN 99
                ELSE output_group_order
            END;

        RETURN;
    END;

    WITH
    a0 AS
    (SELECT 1 AS n UNION ALL SELECT 1),
    a1 AS
    (SELECT 1 AS n FROM a0 AS a CROSS JOIN a0 AS b),
    a2 AS
    (SELECT 1 AS n FROM a1 AS a CROSS JOIN a1 AS b),
    a3 AS
    (SELECT 1 AS n FROM a2 AS a CROSS JOIN a2 AS b),
    a4 AS
    (SELECT 1 AS n FROM a3 AS a CROSS JOIN a3 AS b),
    numbers AS
    (
        SELECT TOP(LEN(@output_column_list))
            ROW_NUMBER() OVER
            (
                ORDER BY (SELECT NULL)
            ) AS number
        FROM a4
        ORDER BY
            number
    ),
    tokens AS
    (
        SELECT
            ''''|['''' +
                SUBSTRING
                (
                    @output_column_list,
                    number + 1,
                    CHARINDEX('''']'''', @output_column_list, number) - number - 1
                ) + ''''|]'''' AS token,
            number
        FROM numbers
        WHERE
            SUBSTRING(@output_column_list, number, 1) = ''''[''''
    ),
    ordered_columns AS
    (
        SELECT
            x.column_name,
            ROW_NUMBER() OVER
            (
                PARTITION BY
                    x.column_name
                ORDER BY
                    tokens.number,
                    x.default_order
            ) AS r,
            ROW_NUMBER() OVER
            (
                ORDER BY
                    tokens.number,
                    x.default_order
            ) AS s
        FROM tokens
        JOIN
        (
            SELECT ''''[session_id]'''' AS column_name, 1 AS default_order
            UNION ALL
            SELECT ''''[dd hh:mm:ss.mss]'''', 2
            WHERE
                @format_output IN (1, 2)
            UNION ALL
            SELECT ''''[dd hh:mm:ss.mss (avg)]'''', 3
            WHERE
                @format_output IN (1, 2)
                AND @get_avg_time = 1
            UNION ALL
            SELECT ''''[avg_elapsed_time]'''', 4
            WHERE
                @format_output = 0
                AND @get_avg_time = 1
            UNION ALL
            SELECT ''''[physical_io]'''', 5
            WHERE
                @get_task_info = 2
            UNION ALL
            SELECT ''''[reads]'''', 6
            UNION ALL
            SELECT ''''[physical_reads]'''', 7
            UNION ALL
            SELECT ''''[writes]'''', 8
            UNION ALL
            SELECT ''''[tempdb_allocations]'''', 9
            UNION ALL
            SELECT ''''[tempdb_current]'''', 10
            UNION ALL
            SELECT ''''[CPU]'''', 11
            UNION ALL
            SELECT ''''[context_switches]'''', 12
            WHERE
                @get_task_info = 2
            UNION ALL
            SELECT ''''[used_memory]'''', 13
            UNION ALL
            SELECT ''''[max_used_memory]'''', 14
            WHERE
                @get_memory_info = 1
            UNION ALL
            SELECT ''''[requested_memory]'''', 15
            WHERE
                @get_memory_info = 1
            UNION ALL
            SELECT ''''[granted_memory]'''', 16
            WHERE
                @get_memory_info = 1
            UNION ALL
            SELECT ''''[physical_io_delta]'''', 17
            WHERE
                @delta_interval > 0   
                AND @get_task_info = 2
            UNION ALL
            SELECT ''''[reads_delta]'''', 18
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[physical_reads_delta]'''', 19
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[writes_delta]'''', 20
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[tempdb_allocations_delta]'''', 21
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[tempdb_current_delta]'''', 22
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[CPU_delta]'''', 23
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[context_switches_delta]'''', 24
            WHERE
                @delta_interval > 0
                AND @get_task_info = 2
            UNION ALL
            SELECT ''''[used_memory_delta]'''', 25
            WHERE
                @delta_interval > 0
            UNION ALL
            SELECT ''''[max_used_memory_delta]'''', 26
            WHERE
                @delta_interval > 0
                AND @get_memory_info = 1
            UNION ALL
            SELECT ''''[tasks]'''', 27
            WHERE
                @get_task_info = 2
            UNION ALL
            SELECT ''''[status]'''', 28
            UNION ALL
            SELECT ''''[wait_info]'''', 29
            WHERE
                @get_task_info > 0
                OR @find_block_leaders = 1
            UNION ALL
            SELECT ''''[locks]'''', 30
            WHERE
                @get_locks = 1
            UNION ALL
            SELECT ''''[tran_start_time]'''', 31
            WHERE
                @get_transaction_info = 1
            UNION ALL
            SELECT ''''[tran_log_writes]'''', 32
            WHERE
                @get_transaction_info = 1
            UNION ALL
            SELECT ''''[implicit_tran]'''', 33
            WHERE
                @get_transaction_info = 1
            UNION ALL
            SELECT ''''[open_tran_count]'''', 34
            UNION ALL
            SELECT ''''[sql_command]'''', 35
            WHERE
                @get_outer_command = 1
            UNION ALL
            SELECT ''''[sql_text]'''', 36
            UNION ALL
            SELECT ''''[query_plan]'''', 37
            WHERE
                @get_plans >= 1
            UNION ALL
            SELECT ''''[blocking_session_id]'''', 38
            WHERE
                @get_task_info > 0
                OR @find_block_leaders = 1
            UNION ALL
            SELECT ''''[blocked_session_count]'''', 39
            WHERE
                @find_block_leaders = 1
            UNION ALL
            SELECT ''''[percent_complete]'''', 40
            UNION ALL
            SELECT ''''[host_name]'''', 41
            UNION ALL
            SELECT ''''[login_name]'''', 42
            UNION ALL
            SELECT ''''[database_name]'''', 43
            UNION ALL
            SELECT ''''[program_name]'''', 44
            UNION ALL
            SELECT ''''[additional_info]'''', 45
            WHERE
                @get_additional_info = 1
            UNION ALL
            SELECT ''''[memory_info]'''', 46
            WHERE
                @get_memory_info = 1
            UNION ALL
            SELECT ''''[start_time]'''', 47
            UNION ALL
            SELECT ''''[login_time]'''', 48
            UNION ALL
            SELECT ''''[request_id]'''', 49
            UNION ALL
            SELECT ''''[collection_time]'''', 50
        ) AS x ON
            x.column_name LIKE token ESCAPE ''''|''''
    )
    SELECT
        @output_column_list =
            STUFF
            (
                (
                    SELECT
                        '''','''' + column_name as [text()]
                    FROM ordered_columns
                    WHERE
                        r = 1
                    ORDER BY
                        s
                    FOR XML
                        PATH('''''''')
                ),
                1,
                1,
                ''''''''
            );
   
    IF COALESCE(RTRIM(@output_column_list), '''''''') = ''''''''
    BEGIN;
        RAISERROR(''''No valid column matches found in @output_column_list or no columns remain due to selected options.'''', 16, 1);
        RETURN;
    END;
   
    IF @destination_table <> ''''''''
    BEGIN;
        SET @destination_table =
            --database
            COALESCE(QUOTENAME(PARSENAME(@destination_table, 3)) + ''''.'''', '''''''') +
            --schema
            COALESCE(QUOTENAME(PARSENAME(@destination_table, 2)) + ''''.'''', '''''''') +
            --table
            COALESCE(QUOTENAME(PARSENAME(@destination_table, 1)), '''''''');
           
        IF COALESCE(RTRIM(@destination_table), '''''''') = ''''''''
        BEGIN;
            RAISERROR(''''Destination table not properly formatted.'''', 16, 1);
            RETURN;
        END;
    END;

    WITH
    a0 AS
    (SELECT 1 AS n UNION ALL SELECT 1),
    a1 AS
    (SELECT 1 AS n FROM a0 AS a CROSS JOIN a0 AS b),
    a2 AS
    (SELECT 1 AS n FROM a1 AS a CROSS JOIN a1 AS b),
    a3 AS
    (SELECT 1 AS n FROM a2 AS a CROSS JOIN a2 AS b),
    a4 AS
    (SELECT 1 AS n FROM a3 AS a CROSS JOIN a3 AS b),
    numbers AS
    (
        SELECT TOP(LEN(@sort_order))
            ROW_NUMBER() OVER
            (
                ORDER BY (SELECT NULL)
            ) AS number
        FROM a4
        ORDER BY
            number
    ),
    tokens AS
    (
        SELECT
            ''''|['''' +
                SUBSTRING
                (
                    @sort_order,
                    number + 1,
                    CHARINDEX('''']'''', @sort_order, number) - number - 1
                ) + ''''|]'''' AS token,
            SUBSTRING
            (
                @sort_order,
                CHARINDEX('''']'''', @sort_order, number) + 1,
                COALESCE(NULLIF(CHARINDEX(''''['''', @sort_order, CHARINDEX('''']'''', @sort_order, number)), 0), LEN(@sort_order)) - CHARINDEX('''']'''', @sort_order, number)
            ) AS next_chunk,
            number
        FROM numbers
        WHERE
            SUBSTRING(@sort_order, number, 1) = ''''[''''
    ),
    ordered_columns AS
    (
        SELECT
            x.column_name +
                CASE
                    WHEN LOWER(tokens.next_chunk) LIKE ''''%asc%'''' THEN '''' ASC''''
                    WHEN LOWER(tokens.next_chunk) LIKE ''''%desc%'''' THEN '''' DESC''''
                    ELSE ''''''''
                END AS column_name,
            ROW_NUMBER() OVER
            (
                PARTITION BY
                    x.column_name
                ORDER BY
                    tokens.number
            ) AS r,
            tokens.number
        FROM tokens
        JOIN
        (
            SELECT ''''[session_id]'''' AS column_name
            UNION ALL
            SELECT ''''[physical_io]''''
            UNION ALL
            SELECT ''''[reads]''''
            UNION ALL
            SELECT ''''[physical_reads]''''
            UNION ALL
            SELECT ''''[writes]''''
            UNION ALL
            SELECT ''''[tempdb_allocations]''''
            UNION ALL
            SELECT ''''[tempdb_current]''''
            UNION ALL
            SELECT ''''[CPU]''''
            UNION ALL
            SELECT ''''[context_switches]''''
            UNION ALL
            SELECT ''''[used_memory]''''
            UNION ALL
            SELECT ''''[max_used_memory]''''
            UNION ALL
            SELECT ''''[requested_memory]''''
            UNION ALL
            SELECT ''''[granted_memory]''''
            UNION ALL
            SELECT ''''[physical_io_delta]''''
            UNION ALL
            SELECT ''''[reads_delta]''''
            UNION ALL
            SELECT ''''[physical_reads_delta]''''
            UNION ALL
            SELECT ''''[writes_delta]''''
            UNION ALL
            SELECT ''''[tempdb_allocations_delta]''''
            UNION ALL
            SELECT ''''[tempdb_current_delta]''''
            UNION ALL
            SELECT ''''[CPU_delta]''''
            UNION ALL
            SELECT ''''[context_switches_delta]''''
            UNION ALL
            SELECT ''''[used_memory_delta]''''
            UNION ALL
            SELECT ''''[max_used_memory_delta]''''
            UNION ALL
            SELECT ''''[tasks]''''
            UNION ALL
            SELECT ''''[tran_start_time]''''
            UNION ALL
            SELECT ''''[open_tran_count]''''
            UNION ALL
            SELECT ''''[blocking_session_id]''''
            UNION ALL
            SELECT ''''[blocked_session_count]''''
            UNION ALL
            SELECT ''''[percent_complete]''''
            UNION ALL
            SELECT ''''[host_name]''''
            UNION ALL
            SELECT ''''[login_name]''''
            UNION ALL
            SELECT ''''[database_name]''''
            UNION ALL
            SELECT ''''[start_time]''''
            UNION ALL
            SELECT ''''[login_time]''''
            UNION ALL
            SELECT ''''[program_name]''''
        ) AS x ON
            x.column_name LIKE token ESCAPE ''''|''''
    )
    SELECT
        @sort_order = COALESCE(z.sort_order, '''''''')
    FROM
    (
        SELECT
            STUFF
            (
                (
                    SELECT
                        '''','''' + column_name as [text()]
                    FROM ordered_columns
                    WHERE
                        r = 1
                    ORDER BY
                        number
                    FOR XML
                        PATH('''''''')
                ),
                1,
                1,
                ''''''''
            ) AS sort_order
    ) AS z;

    CREATE TABLE #sessions
    (
        recursion SMALLINT NOT NULL,
        session_id SMALLINT NOT NULL,
        request_id INT NOT NULL,
        session_number INT NOT NULL,
        elapsed_time INT NOT NULL,
        avg_elapsed_time INT NULL,
        physical_io BIGINT NULL,
        reads BIGINT NULL,
        physical_reads BIGINT NULL,
        writes BIGINT NULL,
        tempdb_allocations BIGINT NULL,
        tempdb_current BIGINT NULL,
        CPU BIGINT NULL,
        thread_CPU_snapshot BIGINT NULL,
        context_switches BIGINT NULL,
        used_memory BIGINT NOT NULL,
        max_used_memory BIGINT NULL,
        requested_memory BIGINT NULL,
        granted_memory BIGINT NULL,
        tasks SMALLINT NULL,
        status VARCHAR(30) NOT NULL,
        wait_info NVARCHAR(4000) NULL,
        locks XML NULL,
        transaction_id BIGINT NULL,
        tran_start_time DATETIME NULL,
        tran_log_writes NVARCHAR(4000) NULL,
        implicit_tran NVARCHAR(3) NULL,
        open_tran_count SMALLINT NULL,
        sql_command XML NULL,
        sql_handle VARBINARY(64) NULL,
        statement_start_offset INT NULL,
        statement_end_offset INT NULL,
        sql_text XML NULL,
        plan_handle VARBINARY(64) NULL,
        query_plan XML NULL,
        blocking_session_id SMALLINT NULL,
        blocked_session_count SMALLINT NULL,
        percent_complete REAL NULL,
        host_name sysname NULL,
        login_name sysname NOT NULL,
        database_name sysname NULL,
        program_name sysname NULL,
        additional_info XML NULL,
        memory_info XML NULL,
        start_time DATETIME NOT NULL,
        login_time DATETIME NULL,
        last_request_start_time DATETIME NULL,
        PRIMARY KEY CLUSTERED (session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON),
        UNIQUE NONCLUSTERED (transaction_id, session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON)
    );

    IF @return_schema = 0
    BEGIN;
        --Disable unnecessary autostats on the table
        CREATE STATISTICS s_session_id ON #sessions (session_id)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_request_id ON #sessions (request_id)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_transaction_id ON #sessions (transaction_id)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_session_number ON #sessions (session_number)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_status ON #sessions (status)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_start_time ON #sessions (start_time)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_last_request_start_time ON #sessions (last_request_start_time)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;
        CREATE STATISTICS s_recursion ON #sessions (recursion)
        WITH SAMPLE 0 ROWS, NORECOMPUTE;

        DECLARE @recursion SMALLINT;
        SET @recursion =
            CASE @delta_interval
                WHEN 0 THEN 1
                ELSE -1
            END;

        DECLARE @first_collection_ms_ticks BIGINT;
        DECLARE @last_collection_start DATETIME;
        DECLARE @sys_info BIT;
        SET @sys_info = ISNULL(CONVERT(BIT, SIGN(OBJECT_ID(''''sys.dm_os_sys_info''''))), 0);

        --Used for the delta pull
        REDO:;
       
        IF
            @get_locks = 1
            AND @recursion = 1
            AND @output_column_list LIKE ''''%|[locks|]%'''' ESCAPE ''''|''''
        BEGIN;
            SELECT
                y.resource_type,
                y.database_name,
                y.object_id,
                y.file_id,
                y.page_type,
                y.hobt_id,
                y.allocation_unit_id,
                y.index_id,
                y.schema_id,
                y.principal_id,
                y.request_mode,
                y.request_status,
                y.session_id,
                y.resource_description,
                y.request_count,
                s.request_id,
                s.start_time,
                CONVERT(sysname, NULL) AS object_name,
                CONVERT(sysname, NULL) AS index_name,
                CONVERT(sysname, NULL) AS schema_name,
                CONVERT(sysname, NULL) AS principal_name,
                CONVERT(NVARCHAR(2048), NULL) AS query_error
            INTO #locks
            FROM
            (
                SELECT
                    sp.spid AS session_id,
                    CASE sp.status
                        WHEN ''''sleeping'''' THEN CONVERT(INT, 0)
                        ELSE sp.request_id
                    END AS request_id,
                    CASE sp.status
                        WHEN ''''sleeping'''' THEN sp.last_batch
                        ELSE COALESCE(req.start_time, sp.last_batch)
                    END AS start_time,
                    sp.dbid
                FROM sys.sysprocesses AS sp
                OUTER APPLY
                (
                    SELECT TOP(1)
                        CASE
                            WHEN
                            (
                                sp.hostprocess > ''''''''
                                OR r.total_elapsed_time < 0
                            ) THEN
                                r.start_time
                            ELSE
                                DATEADD
                                (
                                    ms,
                                    1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
                                    DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
                                )
                        END AS start_time
                    FROM sys.dm_exec_requests AS r
                    WHERE
                        r.session_id = sp.spid
                        AND r.request_id = sp.request_id
                ) AS req
                WHERE
                    --Process inclusive filter
                    1 =
                        CASE
                            WHEN @filter <> '''''''' THEN
                                CASE @filter_type
                                    WHEN ''''session'''' THEN
                                        CASE
                                            WHEN
                                                CONVERT(SMALLINT, @filter) = 0
                                                OR sp.spid = CONVERT(SMALLINT, @filter)
                                                    THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''program'''' THEN
                                        CASE
                                            WHEN sp.program_name LIKE @filter THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''login'''' THEN
                                        CASE
                                            WHEN sp.loginame LIKE @filter THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''host'''' THEN
                                        CASE
                                            WHEN sp.hostname LIKE @filter THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''database'''' THEN
                                        CASE
                                            WHEN DB_NAME(sp.dbid) LIKE @filter THEN 1
                                            ELSE 0
                                        END
                                    ELSE 0
                                END
                            ELSE 1
                        END
                    --Process exclusive filter
                    AND 0 =
                        CASE
                            WHEN @not_filter <> '''''''' THEN
                                CASE @not_filter_type
                                    WHEN ''''session'''' THEN
                                        CASE
                                            WHEN sp.spid = CONVERT(SMALLINT, @not_filter) THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''program'''' THEN
                                        CASE
                                            WHEN sp.program_name LIKE @not_filter THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''login'''' THEN
                                        CASE
                                            WHEN sp.loginame LIKE @not_filter THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''host'''' THEN
                                        CASE
                                            WHEN sp.hostname LIKE @not_filter THEN 1
                                            ELSE 0
                                        END
                                    WHEN ''''database'''' THEN
                                        CASE
                                            WHEN DB_NAME(sp.dbid) LIKE @not_filter THEN 1
                                            ELSE 0
                                        END
                                    ELSE 0
                                END
                            ELSE 0
                        END
                    AND
                    (
                        @show_own_spid = 1
                        OR sp.spid <> @@SPID
                    )
                    AND
                    (
                        @show_system_spids = 1
                        OR sp.hostprocess > ''''''''
                    )
                    AND sp.ecid = 0
            ) AS s
            INNER HASH JOIN
            (
                SELECT
                    x.resource_type,
                    x.database_name,
                    x.object_id,
                    x.file_id,
                    CASE
                        WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN ''''PFS''''
                        WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN ''''GAM''''
                        WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN ''''SGAM''''
                        WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN ''''DCM''''
                        WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN ''''BCM''''
                        WHEN x.page_no IS NOT NULL THEN ''''*''''
                        ELSE NULL
                    END AS page_type,
                    x.hobt_id,
                    x.allocation_unit_id,
                    x.index_id,
                    x.schema_id,
                    x.principal_id,
                    x.request_mode,
                    x.request_status,
                    x.session_id,
                    x.request_id,
                    CASE
                        WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '''''''')
                        ELSE NULL
                    END AS resource_description,
                    COUNT(*) AS request_count
                FROM
                (
                    SELECT
                        tl.resource_type +
                            CASE
                                WHEN tl.resource_subtype = '''''''' THEN ''''''''
                                ELSE ''''.'''' + tl.resource_subtype
                            END AS resource_type,
                        COALESCE(DB_NAME(tl.resource_database_id), N''''(null)'''') AS database_name,
                        CONVERT
                        (
                            INT,
                            CASE
                                WHEN tl.resource_type = ''''OBJECT'''' THEN tl.resource_associated_entity_id
                                WHEN tl.resource_description LIKE ''''%object_id = %'''' THEN
                                    (
                                        SUBSTRING
                                        (
                                            tl.resource_description,
                                            (CHARINDEX(''''object_id = '''', tl.resource_description) + 12),
                                            COALESCE
                                            (
                                                NULLIF
                                                (
                                                    CHARINDEX('''','''', tl.resource_description, CHARINDEX(''''object_id = '''', tl.resource_description) + 12),
                                                    0
                                                ),
                                                DATALENGTH(tl.resource_description)+1
                                            ) - (CHARINDEX(''''object_id = '''', tl.resource_description) + 12)
                                        )
                                    )
                                ELSE NULL
                            END
                        ) AS object_id,
                        CONVERT
                        (
                            INT,
                            CASE
                                WHEN tl.resource_type = ''''FILE'''' THEN CONVERT(INT, tl.resource_description)
                                WHEN tl.resource_type IN (''''PAGE'''', ''''EXTENT'''', ''''RID'''') THEN LEFT(tl.resource_description, CHARINDEX('''':'''', tl.resource_description)-1)
                                ELSE NULL
                            END
                        ) AS file_id,
                        CONVERT
                        (
                            INT,
                            CASE
                                WHEN tl.resource_type IN (''''PAGE'''', ''''EXTENT'''', ''''RID'''') THEN
                                    SUBSTRING
                                    (
                                        tl.resource_description,
                                        CHARINDEX('''':'''', tl.resource_description) + 1,
                                        COALESCE
                                        (
                                            NULLIF
                                            (
                                                CHARINDEX('''':'''', tl.resource_description, CHARINDEX('''':'''', tl.resource_description) + 1),
                                                0
                                            ),
                                            DATALENGTH(tl.resource_description)+1
                                        ) - (CHARINDEX('''':'''', tl.resource_description) + 1)
                                    )
                                ELSE NULL
                            END
                        ) AS page_no,
                        CASE
                            WHEN tl.resource_type IN (''''PAGE'''', ''''KEY'''', ''''RID'''', ''''HOBT'''') THEN tl.resource_associated_entity_id
                            ELSE NULL
                        END AS hobt_id,
                        CASE
                            WHEN tl.resource_type = ''''ALLOCATION_UNIT'''' THEN tl.resource_associated_entity_id
                            ELSE NULL
                        END AS allocation_unit_id,
                        CONVERT
                        (
                            INT,
                            CASE
                                WHEN
                                    /*TODO: Deal with server principals*/
                                    tl.resource_subtype <> ''''SERVER_PRINCIPAL''''
                                    AND tl.resource_description LIKE ''''%index_id or stats_id = %'''' THEN
                                    (
                                        SUBSTRING
                                        (
                                            tl.resource_description,
                                            (CHARINDEX(''''index_id or stats_id = '''', tl.resource_description) + 23),
                                            COALESCE
                                            (
                                                NULLIF
                                                (
                                                    CHARINDEX('''','''', tl.resource_description, CHARINDEX(''''index_id or stats_id = '''', tl.resource_description) + 23),
                                                    0
                                                ),
                                                DATALENGTH(tl.resource_description)+1
                                            ) - (CHARINDEX(''''index_id or stats_id = '''', tl.resource_description) + 23)
                                        )
                                    )
                                ELSE NULL
                            END
                        ) AS index_id,
                        CONVERT
                        (
                            INT,
                            CASE
                                WHEN tl.resource_description LIKE ''''%schema_id = %'''' THEN
                                    (
                                        SUBSTRING
                                        (
                                            tl.resource_description,
                                            (CHARINDEX(''''schema_id = '''', tl.resource_description) + 12),
                                            COALESCE
                                            (
                                                NULLIF
                                                (
                                                    CHARINDEX('''','''', tl.resource_description, CHARINDEX(''''schema_id = '''', tl.resource_description) + 12),
                                                    0
                                                ),
                                                DATALENGTH(tl.resource_description)+1
                                            ) - (CHARINDEX(''''schema_id = '''', tl.resource_description) + 12)
                                        )
                                    )
                                ELSE NULL
                            END
                        ) AS schema_id,
                        CONVERT
                        (
                            INT,
                            CASE
                                WHEN tl.resource_description LIKE ''''%principal_id = %'''' THEN
                                    (
                                        SUBSTRING
                                        (
                                            tl.resource_description,
                                            (CHARINDEX(''''principal_id = '''', tl.resource_description) + 15),
                                            COALESCE
                                            (
                                                NULLIF
                                                (
                                                    CHARINDEX('''','''', tl.resource_description, CHARINDEX(''''principal_id = '''', tl.resource_description) + 15),
                                                    0
                                                ),
                                                DATALENGTH(tl.resource_description)+1
                                            ) - (CHARINDEX(''''principal_id = '''', tl.resource_description) + 15)
                                        )
                                    )
                                ELSE NULL
                            END
                        ) AS principal_id,
                        tl.request_mode,
                        tl.request_status,
                        tl.request_session_id AS session_id,
                        tl.request_request_id AS request_id,

                        /*TODO: Applocks, other resource_descriptions*/
                        RTRIM(tl.resource_description) AS resource_description,
                        tl.resource_associated_entity_id
                        /*********************************************/
                    FROM
                    (
                        SELECT
                            request_session_id,
                            CONVERT(VARCHAR(120), resource_type) COLLATE Latin1_General_Bin2 AS resource_type,
                            CONVERT(VARCHAR(120), resource_subtype) COLLATE Latin1_General_Bin2 AS resource_subtype,
                            resource_database_id,
                            CONVERT(VARCHAR(512), resource_description) COLLATE Latin1_General_Bin2 AS resource_description,
                            resource_associated_entity_id,
                            CONVERT(VARCHAR(120), request_mode) COLLATE Latin1_General_Bin2 AS request_mode,
                            CONVERT(VARCHAR(120), request_status) COLLATE Latin1_General_Bin2 AS request_status,
                            request_request_id
                        FROM sys.dm_tran_locks
                    ) AS tl
                ) AS x
                GROUP BY
                    x.resource_type,
                    x.database_name,
                    x.object_id,
                    x.file_id,
                    CASE
                        WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN ''''PFS''''
                        WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN ''''GAM''''
                        WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN ''''SGAM''''
                        WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN ''''DCM''''
                        WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN ''''BCM''''
                        WHEN x.page_no IS NOT NULL THEN ''''*''''
                        ELSE NULL
                    END,
                    x.hobt_id,
                    x.allocation_unit_id,
                    x.index_id,
                    x.schema_id,
                    x.principal_id,
                    x.request_mode,
                    x.request_status,
                    x.session_id,
                    x.request_id,
                    CASE
                        WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '''''''')
                        ELSE NULL
                    END
            ) AS y ON
                y.session_id = s.session_id
                AND y.request_id = s.request_id
            OPTION (HASH GROUP);

            --Disable unnecessary autostats on the table
            CREATE STATISTICS s_database_name ON #locks (database_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_object_id ON #locks (object_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_hobt_id ON #locks (hobt_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_allocation_unit_id ON #locks (allocation_unit_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_index_id ON #locks (index_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_schema_id ON #locks (schema_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_principal_id ON #locks (principal_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_request_id ON #locks (request_id)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_start_time ON #locks (start_time)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_resource_type ON #locks (resource_type)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_object_name ON #locks (object_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_schema_name ON #locks (schema_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_page_type ON #locks (page_type)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_request_mode ON #locks (request_mode)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_request_status ON #locks (request_status)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_resource_description ON #locks (resource_description)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_index_name ON #locks (index_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_principal_name ON #locks (principal_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
        END;
       
        DECLARE
            @sql VARCHAR(MAX),
            @sql_n NVARCHAR(MAX),
            @core_session_join VARCHAR(MAX);

        SET @core_session_join =
                ''''@sessions AS sp
                LEFT OUTER LOOP JOIN sys.dm_exec_sessions AS s ON
                    s.session_id = sp.session_id
                    AND s.login_time = sp.login_time
                LEFT OUTER LOOP JOIN sys.dm_exec_requests AS r ON
                    sp.status <> ''''''''sleeping''''''''
                    AND r.session_id = sp.session_id
                    AND r.request_id = sp.request_id
                    AND
                    (
                        (
                            s.is_user_process = 0
                            AND sp.is_user_process = 0
                        )
                        OR
                        (
                            r.start_time = s.last_request_start_time
                            AND s.last_request_end_time <= sp.last_request_end_time
                        )
                    ) '''';

        SET @sql =
            CONVERT(VARCHAR(MAX), '''''''') +
            ''''DECLARE @blocker BIT;
            SET @blocker = 0;
            DECLARE @i INT;
            SET @i = 2147483647;

            DECLARE @sessions TABLE
            (
                session_id SMALLINT NOT NULL,
                request_id INT NOT NULL,
                login_time DATETIME,
                last_request_end_time DATETIME,
                status VARCHAR(30),
                statement_start_offset INT,
                statement_end_offset INT,
                sql_handle BINARY(20),
                host_name NVARCHAR(128),
                login_name NVARCHAR(128),
                program_name NVARCHAR(128),
                database_id SMALLINT,
                memory_usage INT,
                open_tran_count SMALLINT,
                '''' +
                CASE
                    WHEN
                    (
                        @get_task_info <> 0
                        OR @find_block_leaders = 1
                    ) THEN
                        ''''wait_type NVARCHAR(32),
                        wait_resource NVARCHAR(256),
                        wait_time BIGINT,
                        ''''
                    ELSE
                        ''''''''
                END +
                ''''blocked SMALLINT,
                is_user_process BIT,
                cmd VARCHAR(32),
                PRIMARY KEY CLUSTERED (session_id, request_id) WITH (IGNORE_DUP_KEY = ON)
            );

            DECLARE @blockers TABLE
            (
                session_id INT NOT NULL PRIMARY KEY WITH (IGNORE_DUP_KEY = ON)
            );

            BLOCKERS:;

            INSERT @sessions
            (
                session_id,
                request_id,
                login_time,
                last_request_end_time,
                status,
                statement_start_offset,
                statement_end_offset,
                sql_handle,
                host_name,
                login_name,
                program_name,
                database_id,
                memory_usage,
                open_tran_count,
                '''' +
                CASE
                    WHEN
                    (
                        @get_task_info <> 0
                        OR @find_block_leaders = 1
                    ) THEN
                        ''''wait_type,
                        wait_resource,
                        wait_time,
                        ''''
                    ELSE
                        ''''''''
                END +
                ''''blocked,
                is_user_process,
                cmd
            )
            SELECT TOP(@i)
                spy.session_id,
                spy.request_id,
                spy.login_time,
                spy.last_request_end_time,
                spy.status,
                spy.statement_start_offset,
                spy.statement_end_offset,
                spy.sql_handle,
                spy.host_name,
                spy.login_name,
                spy.program_name,
                spy.database_id,
                spy.memory_usage,
                spy.open_tran_count,
                '''' +
                CASE
                    WHEN
                    (
                        @get_task_info <> 0
                        OR @find_block_leaders = 1
                    ) THEN
                        ''''spy.wait_type,
                        CASE
                            WHEN
                                spy.wait_type LIKE N''''''''PAGE%LATCH_%''''''''
                                OR spy.wait_type IN (N''''''''CXPACKET'''''''', N''''''''CXCONSUMER'''''''', N''''''''CXSYNC_PORT'''''''', N''''''''CXSYNC_CONSUMER'''''''')
                                OR spy.wait_type LIKE N''''''''LATCH[_]%''''''''
                                OR spy.wait_type = N''''''''OLEDB'''''''' THEN
                                    spy.wait_resource
                            ELSE
                                NULL
                        END AS wait_resource,
                        spy.wait_time,
                        ''''
                    ELSE
                        ''''''''
                END +
                ''''spy.blocked,
                spy.is_user_process,
                spy.cmd
            FROM
            (
                SELECT TOP(@i)
                    spx.*,
                    '''' +
                    CASE
                        WHEN
                        (
                            @get_task_info <> 0
                            OR @find_block_leaders = 1
                        ) THEN
                            ''''ROW_NUMBER() OVER
                            (
                                PARTITION BY
                                    spx.session_id,
                                    spx.request_id
                                ORDER BY
                                    CASE
                                        WHEN spx.wait_type LIKE N''''''''LCK[_]%'''''''' THEN
                                            1
                                        ELSE
                                            99
                                    END,
                                    spx.wait_time DESC,
                                    spx.blocked DESC
                            ) AS r
                            ''''
                        ELSE
                            ''''1 AS r
                            ''''
                    END +
                ''''FROM
                (
                    SELECT TOP(@i)
                        sp0.session_id,
                        sp0.request_id,
                        sp0.login_time,
                        sp0.last_request_end_time,
                        LOWER(sp0.status) AS status,
                        CASE
                            WHEN sp0.cmd = ''''''''CREATE INDEX'''''''' THEN
                                0
                            ELSE
                                sp0.stmt_start
                        END AS statement_start_offset,
                        CASE
                            WHEN sp0.cmd = N''''''''CREATE INDEX'''''''' THEN
                                -1
                            ELSE
                                COALESCE(NULLIF(sp0.stmt_end, 0), -1)
                        END AS statement_end_offset,
                        sp0.sql_handle,
                        sp0.host_name,
                        sp0.login_name,
                        sp0.program_name,
                        sp0.database_id,
                        sp0.memory_usage,
                        sp0.open_tran_count,
                        '''' +
                        CASE
                            WHEN
                            (
                                @get_task_info <> 0
                                OR @find_block_leaders = 1
                            ) THEN
                                ''''CASE
                                    WHEN sp0.wait_time > 0 AND sp0.wait_type NOT IN (N''''''''CXPACKET'''''''', N''''''''CXCONSUMER'''''''', N''''''''CXSYNC_PORT'''''''', N''''''''CXSYNC_CONSUMER'''''''') THEN
                                        sp0.wait_type
                                    ELSE
                                        NULL
                                END AS wait_type,
                                CASE
                                    WHEN sp0.wait_time > 0 AND sp0.wait_type NOT IN (N''''''''CXPACKET'''''''', N''''''''CXCONSUMER'''''''', N''''''''CXSYNC_PORT'''''''', N''''''''CXSYNC_CONSUMER'''''''') THEN
                                        sp0.wait_resource
                                    ELSE
                                        NULL
                                END AS wait_resource,
                                CASE
                                    WHEN sp0.wait_type NOT IN (N''''''''CXPACKET'''''''', N''''''''CXCONSUMER'''''''', N''''''''CXSYNC_PORT'''''''', N''''''''CXSYNC_CONSUMER'''''''') THEN
                                        sp0.wait_time
                                    ELSE
                                        0
                                END AS wait_time,
                                ''''
                            ELSE
                                ''''''''
                        END +
                        ''''sp0.blocked,
                        sp0.is_user_process,
                        sp0.cmd
                    FROM
                    (
                        SELECT TOP(@i)
                            sp1.session_id,
                            sp1.request_id,
                            sp1.login_time,
                            sp1.last_request_end_time,
                            sp1.status,
                            sp1.cmd,
                            sp1.stmt_start,
                            sp1.stmt_end,
                            MAX(NULLIF(sp1.sql_handle, 0x00)) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS sql_handle,
                            sp1.host_name,
                            MAX(sp1.login_name) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS login_name,
                            sp1.program_name,
                            sp1.database_id,
                            MAX(sp1.memory_usage)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS memory_usage,
                            MAX(sp1.open_tran_count)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS open_tran_count,
                            sp1.wait_type,
                            sp1.wait_resource,
                            sp1.wait_time,
                            sp1.blocked,
                            sp1.hostprocess,
                            sp1.is_user_process
                        FROM
                        (
                            SELECT TOP(@i)
                                sp2.spid AS session_id,
                                v2.request_id,
                                MAX(sp2.login_time) AS login_time,
                                MAX(sp2.last_batch) AS last_request_end_time,
                                MAX(CONVERT(VARCHAR(30), RTRIM(sp2.status)) COLLATE Latin1_General_Bin2) AS status,
                                MAX(CONVERT(VARCHAR(32), RTRIM(sp2.cmd)) COLLATE Latin1_General_Bin2) AS cmd,
                                MAX(sp2.stmt_start) AS stmt_start,
                                MAX(sp2.stmt_end) AS stmt_end,
                                MAX(sp2.sql_handle) AS sql_handle,
                                MAX(CONVERT(sysname, RTRIM(sp2.hostname)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS host_name,
                                MAX(CONVERT(sysname, RTRIM(sp2.loginame)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS login_name,
                                MAX
                                (
                                    CASE
                                        WHEN blk.queue_id IS NOT NULL THEN
                                            N''''''''Service Broker
                                                database_id: '''''''' + CONVERT(NVARCHAR, blk.database_id) +
                                                N'''''''' queue_id: '''''''' + CONVERT(NVARCHAR, blk.queue_id)
                                        ELSE
                                            CONVERT
                                            (
                                                sysname,
                                                RTRIM(sp2.program_name)
                                            )
                                    END COLLATE SQL_Latin1_General_CP1_CI_AS
                                ) AS program_name,
                                MAX(sp2.dbid) AS database_id,
                                MAX(sp2.memusage) AS memory_usage,
                                MAX(sp2.open_tran) AS open_tran_count,
                                RTRIM(sp2.lastwaittype) AS wait_type,
                                v2.wait_resource,
                                MAX(sp2.waittime) AS wait_time,
                                COALESCE(NULLIF(sp2.blocked, sp2.spid), 0) AS blocked,
                                MAX
                                (
                                    CASE
                                        WHEN blk.session_id = sp2.spid THEN
                                            ''''''''blocker''''''''
                                        ELSE
                                            RTRIM(sp2.hostprocess)
                                    END
                                ) AS hostprocess,
                                CONVERT
                                (
                                    BIT,
                                    MAX
                                    (
                                        CASE
                                            WHEN sp2.hostprocess > '''''''''''''''' THEN
                                                1
                                            ELSE
                                                0
                                        END
                                    )
                                ) AS is_user_process
                            FROM
                            (
                                SELECT TOP(@i)
                                    session_id,
                                    CONVERT(INT, NULL) AS queue_id,
                                    CONVERT(INT, NULL) AS database_id
                                FROM @blockers

                                UNION ALL

                                SELECT TOP(@i)
                                    CONVERT(SMALLINT, 0),
                                    CONVERT(INT, NULL) AS queue_id,
                                    CONVERT(INT, NULL) AS database_id
                                WHERE
                                    @blocker = 0

                                UNION ALL

                                SELECT TOP(@i)
                                    CONVERT(SMALLINT, spid),
                                    queue_id,
                                    database_id
                                FROM sys.dm_broker_activated_tasks
                                WHERE
                                    @blocker = 0
                            ) AS blk
                            INNER JOIN sys.sysprocesses AS sp2 ON
                                sp2.spid = blk.session_id
                                OR
                                (
                                    blk.session_id = 0
                                    AND @blocker = 0
                                )
                            CROSS APPLY
                            (
                                SELECT
                                    CASE sp2.status
                                        WHEN ''''''''sleeping'''''''' THEN
                                            CONVERT(INT, 0)
                                        ELSE
                                            sp2.request_id
                                    END AS request_id,
                                    RTRIM
                                    (
                                        LEFT
                                        (
                                            sp2.waitresource COLLATE Latin1_General_Bin2,
                                            ISNULL(NULLIF(CHARINDEX('''''''' (LATCH '''''''', sp2.waitresource COLLATE Latin1_General_Bin2) - 1, -1), 256)
                                        )
                                    ) AS wait_resource
                            ) AS v2
                            '''' +
                            CASE
                                WHEN
                                (
                                    @get_task_info = 0
                                    AND @find_block_leaders = 0
                                ) THEN
                                    ''''WHERE
                                        sp2.ecid = 0
                                    ''''
                                ELSE
                                    ''''''''
                            END +
                            ''''GROUP BY
                                sp2.spid,
                                v2.request_id,
                                RTRIM(sp2.lastwaittype),
                                v2.wait_resource,
                                COALESCE(NULLIF(sp2.blocked, sp2.spid), 0)
                        ) AS sp1
                    ) AS sp0
                    WHERE
                        @blocker = 1
                        OR
                        (1=1
                        '''' +
                            --inclusive filter
                            CASE
                                WHEN @filter <> '''''''' THEN
                                    CASE @filter_type
                                        WHEN ''''session'''' THEN
                                            CASE
                                                WHEN CONVERT(SMALLINT, @filter) <> 0 THEN
                                                    ''''AND sp0.session_id = CONVERT(SMALLINT, @filter)
                                                    ''''
                                                ELSE
                                                    ''''''''
                                            END
                                        WHEN ''''program'''' THEN
                                            ''''AND sp0.program_name LIKE @filter
                                            ''''
                                        WHEN ''''login'''' THEN
                                            ''''AND sp0.login_name LIKE @filter
                                            ''''
                                        WHEN ''''host'''' THEN
                                            ''''AND sp0.host_name LIKE @filter
                                            ''''
                                        WHEN ''''database'''' THEN
                                            ''''AND DB_NAME(sp0.database_id) LIKE @filter
                                            ''''
                                        ELSE
                                            ''''''''
                                    END
                                ELSE
                                    ''''''''
                            END +
                            --exclusive filter
                            CASE
                                WHEN @not_filter <> '''''''' THEN
                                    CASE @not_filter_type
                                        WHEN ''''session'''' THEN
                                            CASE
                                                WHEN CONVERT(SMALLINT, @not_filter) <> 0 THEN
                                                    ''''AND sp0.session_id <> CONVERT(SMALLINT, @not_filter)
                                                    ''''
                                                ELSE
                                                    ''''''''
                                            END
                                        WHEN ''''program'''' THEN
                                            ''''AND sp0.program_name NOT LIKE @not_filter
                                            ''''
                                        WHEN ''''login'''' THEN
                                            ''''AND sp0.login_name NOT LIKE @not_filter
                                            ''''
                                        WHEN ''''host'''' THEN
                                            ''''AND sp0.host_name NOT LIKE @not_filter
                                            ''''
                                        WHEN ''''database'''' THEN
                                            ''''AND DB_NAME(sp0.database_id) NOT LIKE @not_filter
                                            ''''
                                        ELSE
                                            ''''''''
                                    END
                                ELSE
                                    ''''''''
                            END +
                            CASE @show_own_spid
                                WHEN 1 THEN
                                    ''''''''
                                ELSE
                                    ''''AND sp0.session_id <> @@spid
                                    ''''
                            END +
                            CASE
                                WHEN @show_system_spids = 0 THEN
                                    ''''AND sp0.hostprocess > ''''''''''''''''
                                    ''''
                                ELSE
                                    ''''''''
                            END +
                            CASE @show_sleeping_spids
                                WHEN 0 THEN
                                    ''''AND sp0.status <> ''''''''sleeping''''''''
                                    ''''
                                WHEN 1 THEN
                                    ''''AND
                                    (
                                        sp0.status <> ''''''''sleeping''''''''
                                        OR sp0.open_tran_count > 0
                                    )
                                    ''''
                                ELSE
                                    ''''''''
                            END +
                        '''')
                ) AS spx
            ) AS spy
            WHERE
                spy.r = 1;
            '''' +
            CASE @recursion
                WHEN 1 THEN
                    ''''IF @@ROWCOUNT > 0
                    BEGIN;
                        INSERT @blockers
                        (
                            session_id
                        )
                        SELECT TOP(@i)
                            blocked
                        FROM @sessions
                        WHERE
                            NULLIF(blocked, 0) IS NOT NULL

                        EXCEPT

                        SELECT TOP(@i)
                            session_id
                        FROM @sessions;
                        '''' +

                        CASE
                            WHEN
                            (
                                @get_task_info > 0
                                OR @find_block_leaders = 1
                            ) THEN
                                ''''IF @@ROWCOUNT > 0
                                BEGIN;
                                    SET @blocker = 1;
                                    GOTO BLOCKERS;
                                END;
                                ''''
                            ELSE
                                ''''''''
                        END +
                    ''''END;
                    ''''
                ELSE
                    ''''''''
            END +
            ''''SELECT TOP(@i)
                @recursion AS recursion,
                x.session_id,
                x.request_id,
                DENSE_RANK() OVER
                (
                    ORDER BY
                        x.session_id
                ) AS session_number,
                '''' +
                CASE
                    WHEN @output_column_list LIKE ''''%|[dd hh:mm:ss.mss|]%'''' ESCAPE ''''|'''' THEN
                        ''''x.elapsed_time ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS elapsed_time,
                    '''' +
                CASE
                    WHEN
                        (
                            @output_column_list LIKE ''''%|[dd hh:mm:ss.mss (avg)|]%'''' ESCAPE ''''|'''' OR
                            @output_column_list LIKE ''''%|[avg_elapsed_time|]%'''' ESCAPE ''''|''''
                        )
                        AND @recursion = 1
                            THEN
                                ''''x.avg_elapsed_time / 1000 ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS avg_elapsed_time,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[physical_io|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[physical_io_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.physical_io ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS physical_io,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[reads|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[reads_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.reads ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS reads,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[physical_reads|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[physical_reads_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.physical_reads ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS physical_reads,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[writes|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[writes_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.writes ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS writes,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[tempdb_allocations|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[tempdb_allocations_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.tempdb_allocations ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS tempdb_allocations,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[tempdb_current|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[tempdb_current_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.tempdb_current ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS tempdb_current,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[CPU|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[CPU_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.CPU ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS CPU,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[CPU_delta|]%'''' ESCAPE ''''|''''
                        AND @get_task_info = 2
                        AND @sys_info = 1
                            THEN
                                ''''x.thread_CPU_snapshot ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS thread_CPU_snapshot,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[context_switches|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[context_switches_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.context_switches ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS context_switches,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[used_memory|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[used_memory_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                CASE
                                    WHEN @get_memory_info = 1 THEN
                                        ''''COALESCE(x.mg_used_memory_kb / 8, x.used_memory) ''''
                                    ELSE
                                        ''''x.used_memory ''''
                                END
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS used_memory,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[max_used_memory|]%'''' ESCAPE ''''|''''
                        OR @output_column_list LIKE ''''%|[max_used_memory_delta|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.max_used_memory_kb / 8 ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS max_used_memory,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[requested_memory|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.requested_memory_kb / 8 ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS requested_memory,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[granted_memory|]%'''' ESCAPE ''''|''''
                            THEN
                                ''''x.mg_granted_memory_kb / 8 ''''
                    ELSE
                        ''''0 ''''
                END +
                    ''''AS granted_memory,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[tasks|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.tasks ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS tasks,
                    '''' +
                CASE
                    WHEN
                        (
                            @output_column_list LIKE ''''%|[status|]%'''' ESCAPE ''''|''''
                            OR @output_column_list LIKE ''''%|[sql_command|]%'''' ESCAPE ''''|''''
                        )
                        AND @recursion = 1
                            THEN
                                ''''x.status ''''
                    ELSE
                        '''''''''''''''''''' ''''
                END +
                    ''''AS status,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[wait_info|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                CASE @get_task_info
                                    WHEN 2 THEN
                                        ''''COALESCE(x.task_wait_info, x.sys_wait_info) ''''
                                    ELSE
                                        ''''x.sys_wait_info ''''
                                END
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS wait_info,
                    '''' +
                CASE
                    WHEN
                        (
                            @output_column_list LIKE ''''%|[tran_start_time|]%'''' ESCAPE ''''|''''
                            OR @output_column_list LIKE ''''%|[tran_log_writes|]%'''' ESCAPE ''''|''''
                        )
                        AND @recursion = 1
                            THEN
                                ''''x.transaction_id ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS transaction_id,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[open_tran_count|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.open_tran_count ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS open_tran_count,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[sql_text|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.sql_handle ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS sql_handle,
                    '''' +
                CASE
                    WHEN
                        (
                            @output_column_list LIKE ''''%|[sql_text|]%'''' ESCAPE ''''|''''
                            OR @output_column_list LIKE ''''%|[query_plan|]%'''' ESCAPE ''''|''''
                        )
                        AND @recursion = 1
                            THEN
                                ''''x.statement_start_offset ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS statement_start_offset,
                    '''' +
                CASE
                    WHEN
                        (
                            @output_column_list LIKE ''''%|[sql_text|]%'''' ESCAPE ''''|''''
                            OR @output_column_list LIKE ''''%|[query_plan|]%'''' ESCAPE ''''|''''
                        )
                        AND @recursion = 1
                            THEN
                                ''''x.statement_end_offset ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS statement_end_offset,
                    '''' +
                ''''NULL AS sql_text,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[query_plan|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.plan_handle ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS plan_handle,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[blocking_session_id|]%'''' ESCAPE ''''|'''' OR @find_block_leaders = 1
                        AND @recursion = 1
                            THEN
                                ''''NULLIF(x.blocking_session_id, 0) ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS blocking_session_id,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[percent_complete|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.percent_complete ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS percent_complete,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[host_name|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.host_name ''''
                    ELSE
                        '''''''''''''''''''' ''''
                END +
                    ''''AS host_name,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[login_name|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.login_name ''''
                    ELSE
                        '''''''''''''''''''' ''''
                END +
                    ''''AS login_name,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[database_name|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''DB_NAME(x.database_id) ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS database_name,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[program_name|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.program_name ''''
                    ELSE
                        '''''''''''''''''''' ''''
                END +
                    ''''AS program_name,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[additional_info|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''(
                                    SELECT TOP(@i)
                                        x.text_size,
                                        x.language,
                                        x.date_format,
                                        x.date_first,
                                        CASE x.quoted_identifier
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS quoted_identifier,
                                        CASE x.arithabort
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS arithabort,
                                        CASE x.ansi_null_dflt_on
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS ansi_null_dflt_on,
                                        CASE x.ansi_defaults
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS ansi_defaults,
                                        CASE x.ansi_warnings
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS ansi_warnings,
                                        CASE x.ansi_padding
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS ansi_padding,
                                        CASE ansi_nulls
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS ansi_nulls,
                                        CASE x.concat_null_yields_null
                                            WHEN 0 THEN ''''''''OFF''''''''
                                            WHEN 1 THEN ''''''''ON''''''''
                                        END AS concat_null_yields_null,
                                        CASE x.transaction_isolation_level
                                            WHEN 0 THEN ''''''''Unspecified''''''''
                                            WHEN 1 THEN ''''''''ReadUncomitted''''''''
                                            WHEN 2 THEN ''''''''ReadCommitted''''''''
                                            WHEN 3 THEN ''''''''Repeatable''''''''
                                            WHEN 4 THEN ''''''''Serializable''''''''
                                            WHEN 5 THEN ''''''''Snapshot''''''''
                                        END AS transaction_isolation_level,
                                        x.lock_timeout,
                                        x.deadlock_priority,
                                        x.row_count,
                                        x.command_type,
                                        '''' +
                                        CASE
                                            WHEN OBJECT_ID(''''master.dbo.fn_varbintohexstr'''') IS NOT NULL THEN
                                                ''''master.dbo.fn_varbintohexstr(x.sql_handle) AS sql_handle,
                                                master.dbo.fn_varbintohexstr(x.plan_handle) AS plan_handle,''''
                                            ELSE
                                                ''''CONVERT(VARCHAR(256), x.sql_handle, 1) AS sql_handle,
                                                CONVERT(VARCHAR(256), x.plan_handle, 1) AS plan_handle,''''
                                        END +
                                        ''''
                                        x.statement_start_offset,
                                        x.statement_end_offset,
                                        '''' +
                                        CASE
                                            WHEN @output_column_list LIKE ''''%|[program_name|]%'''' ESCAPE ''''|'''' THEN
                                                ''''(
                                                    SELECT TOP(1)
                                                        CONVERT(uniqueidentifier, CONVERT(XML, '''''''''''''''').value(''''''''xs:hexBinary( substring(sql:column("agent_info.job_id_string"), 0) )'''''''', ''''''''binary(16)'''''''')) AS job_id,
                                                        agent_info.step_id,
                                                        (
                                                            SELECT TOP(1)
                                                                NULL
                                                            FOR XML
                                                                PATH(''''''''job_name''''''''),
                                                                TYPE
                                                        ),
                                                        (
                                                            SELECT TOP(1)
                                                                NULL
                                                            FOR XML
                                                                PATH(''''''''step_name''''''''),
                                                                TYPE
                                                        )
                                                    FROM
                                                    (
                                                        SELECT TOP(1)
                                                            SUBSTRING(x.program_name, CHARINDEX(''''''''0x'''''''', x.program_name) + 2, 32) AS job_id_string,
                                                            SUBSTRING(x.program_name, CHARINDEX('''''''': Step '''''''', x.program_name) + 7, CHARINDEX('''''''')'''''''', x.program_name, CHARINDEX('''''''': Step '''''''', x.program_name)) - (CHARINDEX('''''''': Step '''''''', x.program_name) + 7)) AS step_id
                                                        WHERE
                                                            x.program_name LIKE N''''''''SQLAgent - TSQL JobStep (Job 0x%''''''''
                                                    ) AS agent_info
                                                    FOR XML
                                                        PATH(''''''''agent_job_info''''''''),
                                                        TYPE
                                                ),
                                                ''''
                                            ELSE ''''''''
                                        END +
                                        CASE
                                            WHEN @get_task_info = 2 THEN
                                                ''''CONVERT(XML, x.block_info) AS block_info,
                                                ''''
                                            ELSE
                                                ''''''''
                                        END + ''''
                                        x.host_process_id,
                                        x.group_id,
                                        x.original_login_name,
                                        '''' +
                                        CASE
                                            WHEN OBJECT_ID(''''master.dbo.fn_varbintohexstr'''') IS NOT NULL THEN
                                                ''''master.dbo.fn_varbintohexstr(x.context_info) AS context_info''''
                                            ELSE
                                                ''''CONVERT(VARCHAR(256), x.context_info, 1) AS context_info''''
                                        END + ''''
                                    FOR XML
                                        PATH(''''''''additional_info''''''''),
                                        TYPE
                                ) ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS additional_info,
                    '''' +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[memory_info|]%'''' ESCAPE ''''|''''
                        AND @get_memory_info = 1 THEN''''
                        (
                            SELECT TOP(@i)
                            (
                                SELECT TOP(@i)   
                                    x.request_time,
                                    x.grant_time,
                                    x.wait_time_ms,
                                    x.requested_memory_kb,   
                                    x.mg_granted_memory_kb AS granted_memory_kb,
                                    x.mg_used_memory_kb AS used_memory_kb,
                                    x.max_used_memory_kb,
                                    x.ideal_memory_kb,   
                                    x.required_memory_kb,
                                    x.queue_id,
                                    x.wait_order,
                                    x.is_next_candidate,
                                    x.dop,
                                    CAST(x.query_cost AS NUMERIC(38, 4)) AS query_cost
                                FOR XML
                                    PATH(''''''''memory_grant''''''''),
                                    TYPE
                            ),
                            (
                                SELECT TOP(@i)
                                    x.timeout_error_count,
                                    x.target_memory_kb,
                                    x.max_target_memory_kb,
                                    x.total_memory_kb,
                                    x.available_memory_kb,
                                    x.rs_granted_memory_kb AS granted_memory_kb,
                                    x.rs_used_memory_kb AS used_memory_kb,
                                    x.grantee_count,
                                    x.waiter_count
                                FOR XML
                                    PATH(''''''''resource_semaphore''''''''),
                                    TYPE
                            ),
                            (
                                SELECT TOP(@i)   
                                    x.wg_name AS name,
                                    x.request_max_memory_grant_percent,
                                    x.request_max_cpu_time_sec,
                                    x.request_memory_grant_timeout_sec,
                                    x.max_dop
                                FOR XML
                                    PATH(''''''''workload_group''''''''),
                                    TYPE
                            ),
                            (
                                SELECT TOP(@i)   
                                    x.rp_name AS name,
                                    x.min_memory_percent,
                                    x.max_memory_percent,
                                    x.min_cpu_percent,
                                    x.max_cpu_percent
                                FOR XML
                                    PATH(''''''''resource_pool''''''''),
                                    TYPE
                            )
                            WHERE
                                x.request_time IS NOT NULL
                            FOR XML
                                PATH(''''''''memory_info''''''''),
                                TYPE
                        )               
                    ''''
                    ELSE
                        ''''NULL ''''
                END + ''''AS memory_info,
                x.start_time,
                ''''
                +
                CASE
                    WHEN
                        @output_column_list LIKE ''''%|[login_time|]%'''' ESCAPE ''''|''''
                        AND @recursion = 1
                            THEN
                                ''''x.login_time ''''
                    ELSE
                        ''''NULL ''''
                END +
                    ''''AS login_time,
                x.last_request_start_time
            FROM
            (
                SELECT TOP(@i)
                    y.*,
                    CASE
                        WHEN DATEDIFF(hour, y.start_time, GETDATE()) > 576 THEN
                            DATEDIFF(second, GETDATE(), y.start_time)
                        ELSE DATEDIFF(ms, y.start_time, GETDATE())
                    END AS elapsed_time,
                    COALESCE(tempdb_info.tempdb_allocations, 0) AS tempdb_allocations,
                    COALESCE
                    (
                        CASE
                            WHEN tempdb_info.tempdb_current < 0 THEN 0
                            ELSE tempdb_info.tempdb_current
                        END,
                        0
                    ) AS tempdb_current,
                    '''' +
                    CASE
                        WHEN
                            (
                                @get_task_info <> 0
                                OR @find_block_leaders = 1
                            ) THEN
                                ''''N''''''''('''''''' + CONVERT(NVARCHAR, y.wait_duration_ms) + N''''''''ms)'''''''' +
                                    y.wait_type +
                                        CASE
                                            WHEN y.wait_type LIKE N''''''''PAGE%LATCH_%'''''''' THEN
                                                N'''''''':'''''''' +
                                                COALESCE(DB_NAME(CONVERT(INT, LEFT(y.resource_description, CHARINDEX(N'''''''':'''''''', y.resource_description) - 1))), N''''''''(null)'''''''') +
                                                N'''''''':'''''''' +
                                                SUBSTRING(y.resource_description, CHARINDEX(N'''''''':'''''''', y.resource_description) + 1, LEN(y.resource_description) - CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - CHARINDEX(N'''''''':'''''''', y.resource_description)) +
                                                N''''''''('''''''' +
                                                    CASE
                                                        WHEN
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) = 1 OR
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) % 8088 = 0
                                                                THEN
                                                                    N''''''''PFS''''''''
                                                        WHEN
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) = 2 OR
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) % 511232 = 0
                                                                THEN
                                                                    N''''''''GAM''''''''
                                                        WHEN
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) = 3 OR
                                                            (CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) - 1) % 511232 = 0
                                                                THEN
                                                                    N''''''''SGAM''''''''
                                                        WHEN
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) = 6 OR
                                                            (CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) - 6) % 511232 = 0
                                                                THEN
                                                                    N''''''''DCM''''''''
                                                        WHEN
                                                            CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) = 7 OR
                                                            (CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(y.resource_description)) - 1)) - 7) % 511232 = 0
                                                                THEN
                                                                    N''''''''BCM''''''''
                                                        ELSE
                                                            N''''''''*''''''''
                                                    END +
                                                N'''''''')''''''''
                                            WHEN y.wait_type IN (N''''''''CXPACKET'''''''', N''''''''CXCONSUMER'''''''', N''''''''CXSYNC_PORT'''''''', N''''''''CXSYNC_CONSUMER'''''''') THEN
                                                N'''''''':'''''''' +
                                                    SUBSTRING
                                                    (
                                                        y.resource_description,
                                                        CHARINDEX(N''''''''nodeId'''''''', y.resource_description) + 7,
                                                        CASE
                                                            WHEN CHARINDEX(N'''''''' '''''''', y.resource_description, CHARINDEX(N''''''''nodeId'''''''', y.resource_description)) > 0
                                                            THEN CHARINDEX(N'''''''' '''''''', y.resource_description, CHARINDEX(N''''''''nodeId'''''''', y.resource_description) + 7) - 7 - CHARINDEX(N''''''''nodeId'''''''', y.resource_description)
                                                            ELSE 4
                                                        END
                                                    )
                                            WHEN y.wait_type LIKE N''''''''LATCH[_]%'''''''' THEN
                                                N'''''''' ['''''''' + LEFT(y.resource_description, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', y.resource_description), 0), LEN(y.resource_description) + 1) - 1) + N'''''''']''''''''
                                            WHEN
                                                y.wait_type = N''''''''OLEDB''''''''
                                                AND y.resource_description LIKE N''''''''%(SPID=%)'''''''' THEN
                                                    N''''''''['''''''' + LEFT(y.resource_description, CHARINDEX(N''''''''(SPID='''''''', y.resource_description) - 2) +
                                                        N'''''''':'''''''' + SUBSTRING(y.resource_description, CHARINDEX(N''''''''(SPID='''''''', y.resource_description) + 6, CHARINDEX(N'''''''')'''''''', y.resource_description, (CHARINDEX(N''''''''(SPID='''''''', y.resource_description) + 6)) - (CHARINDEX(N''''''''(SPID='''''''', y.resource_description) + 6)) + '''''''']''''''''
                                            ELSE
                                                N''''''''''''''''
                                        END COLLATE Latin1_General_Bin2 AS sys_wait_info,
                                        ''''
                            ELSE
                                ''''''''
                        END +
                        CASE
                            WHEN @get_task_info = 2 THEN
                                ''''tasks.physical_io,
                                tasks.context_switches,
                                tasks.tasks,
                                tasks.block_info,
                                tasks.wait_info AS task_wait_info,
                                tasks.thread_CPU_snapshot,
                                ''''
                            ELSE
                                ''''''''
                    END +
                    CASE
                        WHEN NOT (@get_avg_time = 1 AND @recursion = 1) THEN
                            ''''CONVERT(INT, NULL) ''''
                        ELSE
                            ''''qs.total_elapsed_time / qs.execution_count ''''
                    END +
                        ''''AS avg_elapsed_time
                FROM
                (
                    SELECT TOP(@i)
                        sp.session_id,
                        sp.request_id,
                        COALESCE(r.logical_reads, s.logical_reads) AS reads,
                        COALESCE(r.reads, s.reads) AS physical_reads,
                        COALESCE(r.writes, s.writes) AS writes,
                        COALESCE(r.CPU_time, s.CPU_time) AS CPU,
                        '''' +
                        CASE
                            WHEN @get_memory_info = 1 THEN
                                ''''sp.memory_usage AS used_memory,
                                mg.used_memory_kb AS mg_used_memory_kb,
                                mg.max_used_memory_kb,
                                mg.request_time,
                                mg.grant_time,
                                mg.wait_time_ms,
                                mg.requested_memory_kb,
                                mg.granted_memory_kb AS mg_granted_memory_kb,
                                mg.required_memory_kb,
                                mg.ideal_memory_kb,
                                mg.dop AS dop,
                                mg.query_cost AS query_cost,
                                mg.queue_id AS queue_id,
                                mg.wait_order AS wait_order,
                                mg.is_next_candidate,
                                rs.target_memory_kb,
                                rs.max_target_memory_kb,
                                rs.total_memory_kb,
                                rs.available_memory_kb,
                                rs.granted_memory_kb AS rs_granted_memory_kb,
                                rs.used_memory_kb AS rs_used_memory_kb,
                                rs.grantee_count,
                                rs.waiter_count,
                                rs.timeout_error_count,
                                wg.name AS wg_name,
                                wg.request_max_memory_grant_percent,
                                wg.request_max_cpu_time_sec,
                                wg.request_memory_grant_timeout_sec,
                                wg.max_dop,
                                rp.name AS rp_name,
                                rp.min_memory_percent,
                                rp.max_memory_percent,
                                rp.min_cpu_percent,
                                rp.max_cpu_percent,
                                ''''
                            ELSE
                                ''''sp.memory_usage + COALESCE(r.granted_query_memory, 0) AS used_memory,
                                ''''
                        END +
                        ''''LOWER(sp.status) AS status,
                        COALESCE(r.sql_handle, sp.sql_handle) AS sql_handle,
                        COALESCE(r.statement_start_offset, sp.statement_start_offset) AS statement_start_offset,
                        COALESCE(r.statement_end_offset, sp.statement_end_offset) AS statement_end_offset,
                        '''' +
                        CASE
                            WHEN
                            (
                                @get_task_info <> 0
                                OR @find_block_leaders = 1
                            ) THEN
                                ''''sp.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
                                sp.wait_resource COLLATE Latin1_General_Bin2 AS resource_description,
                                sp.wait_time AS wait_duration_ms,
                                ''''
                            ELSE
                                ''''''''
                        END +
                        ''''NULLIF(sp.blocked, 0) AS blocking_session_id,
                        r.plan_handle,
                        NULLIF(r.percent_complete, 0) AS percent_complete,
                        sp.host_name,
                        sp.login_name,
                        sp.program_name,
                        s.host_process_id,
                        COALESCE(r.text_size, s.text_size) AS text_size,
                        COALESCE(r.language, s.language) AS language,
                        COALESCE(r.date_format, s.date_format) AS date_format,
                        COALESCE(r.date_first, s.date_first) AS date_first,
                        COALESCE(r.quoted_identifier, s.quoted_identifier) AS quoted_identifier,
                        COALESCE(r.arithabort, s.arithabort) AS arithabort,
                        COALESCE(r.ansi_null_dflt_on, s.ansi_null_dflt_on) AS ansi_null_dflt_on,
                        COALESCE(r.ansi_defaults, s.ansi_defaults) AS ansi_defaults,
                        COALESCE(r.ansi_warnings, s.ansi_warnings) AS ansi_warnings,
                        COALESCE(r.ansi_padding, s.ansi_padding) AS ansi_padding,
                        COALESCE(r.ansi_nulls, s.ansi_nulls) AS ansi_nulls,
                        COALESCE(r.concat_null_yields_null, s.concat_null_yields_null) AS concat_null_yields_null,
                        COALESCE(r.transaction_isolation_level, s.transaction_isolation_level) AS transaction_isolation_level,
                        COALESCE(r.lock_timeout, s.lock_timeout) AS lock_timeout,
                        COALESCE(r.deadlock_priority, s.deadlock_priority) AS deadlock_priority,
                        COALESCE(r.row_count, s.row_count) AS row_count,
                        COALESCE(r.command, sp.cmd) AS command_type,
                        NULLIF(COALESCE(r.context_info, s.context_info), 0x) AS context_info,
                        COALESCE
                        (
                            CASE
                                WHEN
                                (
                                    s.is_user_process = 0
                                    AND r.total_elapsed_time >= 0
                                ) THEN
                                    DATEADD
                                    (
                                        ms,
                                        1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
                                        DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
                                    )
                            END,
                            NULLIF(COALESCE(r.start_time, sp.last_request_end_time), CONVERT(DATETIME, ''''''''19000101'''''''', 112)),
                            sp.login_time
                        ) AS start_time,
                        sp.login_time,
                        CASE
                            WHEN s.is_user_process = 1 THEN
                                s.last_request_start_time
                            ELSE
                                COALESCE
                                (
                                    DATEADD
                                    (
                                        ms,
                                        1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
                                        DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
                                    ),
                                    s.last_request_start_time
                                )
                        END AS last_request_start_time,
                        r.transaction_id,
                        sp.database_id,
                        sp.open_tran_count,
                        '''' +
                        CASE
                            WHEN EXISTS
                            (
                                SELECT
                                    *
                                FROM sys.all_columns AS ac
                                WHERE
                                    ac.object_id = OBJECT_ID(''''sys.dm_exec_sessions'''')
                                    AND ac.name = ''''group_id''''
                            )
                                THEN ''''s.group_id,''''
                            ELSE ''''CONVERT(INT, NULL) AS group_id,''''
                        END + ''''
                        s.original_login_name
                    FROM '''' +
                    CASE
                        WHEN @get_memory_info = 1 THEN
                            ''''(
                                SELECT TOP(@i)
                                    rp0.*
                                FROM sys.resource_governor_resource_pools AS rp0
                            ) AS rp
                            RIGHT OUTER HASH JOIN
                            (
                                (
                                    SELECT TOP(@i)
                                        wg0.*
                                    FROM sys.resource_governor_workload_groups AS wg0
                                ) AS wg
                                RIGHT OUTER HASH JOIN
                                (
                                    (
                                        SELECT TOP(@i)
                                            rs0.*
                                        FROM sys.dm_exec_query_resource_semaphores AS rs0
                                    ) AS rs
                                    RIGHT OUTER HASH JOIN
                                    (
                                        '''' + @core_session_join +
                                        ''''LEFT OUTER LOOP JOIN sys.dm_exec_query_memory_grants AS mg ON
                                            sp.session_id = mg.session_id
                                            AND sp.request_id = mg.request_id
                                    ) ON
                                        rs.resource_semaphore_id = mg.resource_semaphore_id
                                        AND rs.pool_id = mg.pool_id
                                ) ON
                                    wg.group_id = s.group_id
                            ) ON
                                rp.pool_id = wg.pool_id ''''
                        ELSE @core_session_join
                    END + ''''
                ) AS y
                '''' +
                CASE
                    WHEN @get_task_info = 2 THEN
                        CONVERT(VARCHAR(MAX), '''''''') +
                        ''''LEFT OUTER HASH JOIN
                        (
                            SELECT TOP(@i)
                                task_nodes.task_node.value(''''''''(session_id/text())[1]'''''''', ''''''''SMALLINT'''''''') AS session_id,
                                task_nodes.task_node.value(''''''''(request_id/text())[1]'''''''', ''''''''INT'''''''') AS request_id,
                                task_nodes.task_node.value(''''''''(physical_io/text())[1]'''''''', ''''''''BIGINT'''''''') AS physical_io,
                                task_nodes.task_node.value(''''''''(context_switches/text())[1]'''''''', ''''''''BIGINT'''''''') AS context_switches,
                                task_nodes.task_node.value(''''''''(tasks/text())[1]'''''''', ''''''''INT'''''''') AS tasks,
                                task_nodes.task_node.value(''''''''(block_info/text())[1]'''''''', ''''''''NVARCHAR(4000)'''''''') AS block_info,
                                task_nodes.task_node.value(''''''''(waits/text())[1]'''''''', ''''''''NVARCHAR(4000)'''''''') AS wait_info,
                                task_nodes.task_node.value(''''''''(thread_CPU_snapshot/text())[1]'''''''', ''''''''BIGINT'''''''') AS thread_CPU_snapshot
                            FROM
                            (
                                SELECT TOP(@i)
                                    CONVERT
                                    (
                                        XML,
                                        REPLACE
                                        (
                                            CONVERT(NVARCHAR(MAX), tasks_raw.task_xml_raw) COLLATE Latin1_General_Bin2,
                                            N''''''''</waits></tasks><tasks><waits>'''''''',
                                            N'''''''', ''''''''
                                        )
                                    ) AS task_xml
                                FROM
                                (
                                    SELECT TOP(@i)
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.session_id
                                            ELSE
                                                NULL
                                        END AS [session_id],
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.request_id
                                            ELSE
                                                NULL
                                        END AS [request_id],
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.physical_io
                                            ELSE
                                                NULL
                                        END AS [physical_io],
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.context_switches
                                            ELSE
                                                NULL
                                        END AS [context_switches],
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.thread_CPU_snapshot
                                            ELSE
                                                NULL
                                        END AS [thread_CPU_snapshot],
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.tasks
                                            ELSE
                                                NULL
                                        END AS [tasks],
                                        CASE waits.r
                                            WHEN 1 THEN
                                                waits.block_info
                                            ELSE
                                                NULL
                                        END AS [block_info],
                                        REPLACE
                                        (
                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                CONVERT
                                                (
                                                    NVARCHAR(MAX),
                                                    N''''''''('''''''' +
                                                        CONVERT(NVARCHAR, num_waits) + N''''''''x: '''''''' +
                                                        CASE num_waits
                                                            WHEN 1 THEN
                                                                CONVERT(NVARCHAR, min_wait_time) + N''''''''ms''''''''
                                                            WHEN 2 THEN
                                                                CASE
                                                                    WHEN min_wait_time <> max_wait_time THEN
                                                                        CONVERT(NVARCHAR, min_wait_time) + N''''''''/'''''''' + CONVERT(NVARCHAR, max_wait_time) + N''''''''ms''''''''
                                                                    ELSE
                                                                        CONVERT(NVARCHAR, max_wait_time) + N''''''''ms''''''''
                                                                END
                                                            ELSE
                                                                CASE
                                                                    WHEN min_wait_time <> max_wait_time THEN
                                                                        CONVERT(NVARCHAR, min_wait_time) + N''''''''/'''''''' + CONVERT(NVARCHAR, avg_wait_time) + N''''''''/'''''''' + CONVERT(NVARCHAR, max_wait_time) + N''''''''ms''''''''
                                                                    ELSE
                                                                        CONVERT(NVARCHAR, max_wait_time) + N''''''''ms''''''''
                                                                END
                                                        END +
                                                    N'''''''')'''''''' + wait_type COLLATE Latin1_General_Bin2
                                                ),
                                                NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                                NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                                NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                            NCHAR(0),
                                            N''''''''''''''''
                                        ) AS [waits]
                                    FROM
                                    (
                                        SELECT TOP(@i)
                                            w1.*,
                                            ROW_NUMBER() OVER
                                            (
                                                PARTITION BY
                                                    w1.session_id,
                                                    w1.request_id
                                                ORDER BY
                                                    w1.block_info DESC,
                                                    w1.num_waits DESC,
                                                    w1.wait_type
                                            ) AS r
                                        FROM
                                        (
                                            SELECT TOP(@i)
                                                task_info.session_id,
                                                task_info.request_id,
                                                task_info.physical_io,
                                                task_info.context_switches,
                                                task_info.thread_CPU_snapshot,
                                                task_info.num_tasks AS tasks,
                                                CASE
                                                    WHEN task_info.runnable_time IS NOT NULL THEN
                                                        ''''''''RUNNABLE''''''''
                                                    ELSE
                                                        wt2.wait_type
                                                END AS wait_type,
                                                NULLIF(COUNT(COALESCE(task_info.runnable_time, wt2.waiting_task_address)), 0) AS num_waits,
                                                MIN(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS min_wait_time,
                                                AVG(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS avg_wait_time,
                                                MAX(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS max_wait_time,
                                                MAX(wt2.block_info) AS block_info
                                            FROM
                                            (
                                                SELECT TOP(@i)
                                                    t.session_id,
                                                    t.request_id,
                                                    SUM(CONVERT(BIGINT, t.pending_io_count)) OVER (PARTITION BY t.session_id, t.request_id) AS physical_io,
                                                    SUM(CONVERT(BIGINT, t.context_switches_count)) OVER (PARTITION BY t.session_id, t.request_id) AS context_switches,
                                                    '''' +
                                                    CASE
                                                        WHEN
                                                            @output_column_list LIKE ''''%|[CPU_delta|]%'''' ESCAPE ''''|''''
                                                            AND @sys_info = 1
                                                            THEN
                                                                ''''SUM(tr.usermode_time + tr.kernel_time) OVER (PARTITION BY t.session_id, t.request_id) ''''
                                                        ELSE
                                                            ''''CONVERT(BIGINT, NULL) ''''
                                                    END +
                                                        '''' AS thread_CPU_snapshot,
                                                    COUNT(*) OVER (PARTITION BY t.session_id, t.request_id) AS num_tasks,
                                                    t.task_address,
                                                    t.task_state,
                                                    CASE
                                                        WHEN
                                                            t.task_state = ''''''''RUNNABLE''''''''
                                                            AND w.runnable_time > 0 THEN
                                                                w.runnable_time
                                                        ELSE
                                                            NULL
                                                    END AS runnable_time
                                                FROM sys.dm_os_tasks AS t
                                                CROSS APPLY
                                                (
                                                    SELECT TOP(1)
                                                        sp2.session_id
                                                    FROM @sessions AS sp2
                                                    WHERE
                                                        sp2.session_id = t.session_id
                                                        AND sp2.request_id = t.request_id
                                                        AND sp2.status <> ''''''''sleeping''''''''
                                                ) AS sp20
                                                LEFT OUTER HASH JOIN
                                                (
                                                '''' +
                                                    CASE
                                                        WHEN @sys_info = 1 THEN
                                                            ''''SELECT TOP(@i)
                                                                (
                                                                    SELECT TOP(@i)
                                                                        ms_ticks
                                                                    FROM sys.dm_os_sys_info
                                                                ) -
                                                                    w0.wait_resumed_ms_ticks AS runnable_time,
                                                                w0.worker_address,
                                                                w0.thread_address,
                                                                w0.task_bound_ms_ticks
                                                            FROM sys.dm_os_workers AS w0
                                                            WHERE
                                                                w0.state = ''''''''RUNNABLE''''''''
                                                                OR @first_collection_ms_ticks >= w0.task_bound_ms_ticks''''
                                                        ELSE
                                                            ''''SELECT
                                                                CONVERT(BIGINT, NULL) AS runnable_time,
                                                                CONVERT(VARBINARY(8), NULL) AS worker_address,
                                                                CONVERT(VARBINARY(8), NULL) AS thread_address,
                                                                CONVERT(BIGINT, NULL) AS task_bound_ms_ticks
                                                            WHERE
                                                                1 = 0''''
                                                        END +
                                                ''''
                                                ) AS w ON
                                                    w.worker_address = t.worker_address
                                                '''' +
                                                CASE
                                                    WHEN
                                                        @output_column_list LIKE ''''%|[CPU_delta|]%'''' ESCAPE ''''|''''
                                                        AND @sys_info = 1
                                                        THEN
                                                            ''''LEFT OUTER HASH JOIN sys.dm_os_threads AS tr ON
                                                                tr.thread_address = w.thread_address
                                                                AND @first_collection_ms_ticks >= w.task_bound_ms_ticks
                                                            ''''
                                                    ELSE
                                                        ''''''''
                                                END +
                                            '''') AS task_info
                                            LEFT OUTER HASH JOIN
                                            (
                                                SELECT TOP(@i)
                                                    wt1.wait_type,
                                                    wt1.waiting_task_address,
                                                    MAX(wt1.wait_duration_ms) AS wait_duration_ms,
                                                    MAX(wt1.block_info) AS block_info
                                                FROM
                                                (
                                                    SELECT DISTINCT TOP(@i)
                                                        wt.wait_type +
                                                            CASE
                                                                WHEN wt.wait_type LIKE N''''''''PAGE%LATCH_%'''''''' THEN
                                                                    '''''''':'''''''' +
                                                                    COALESCE(DB_NAME(CONVERT(INT, LEFT(wt.resource_description, CHARINDEX(N'''''''':'''''''', wt.resource_description) - 1))), N''''''''(null)'''''''') +
                                                                    N'''''''':'''''''' +
                                                                    SUBSTRING(wt.resource_description, CHARINDEX(N'''''''':'''''''', wt.resource_description) + 1, LEN(wt.resource_description) - CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - CHARINDEX(N'''''''':'''''''', wt.resource_description)) +
                                                                    N''''''''('''''''' +
                                                                        CASE
                                                                            WHEN
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) = 1 OR
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) % 8088 = 0
                                                                                    THEN
                                                                                        N''''''''PFS''''''''
                                                                            WHEN
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) = 2 OR
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) % 511232 = 0
                                                                                    THEN
                                                                                        N''''''''GAM''''''''
                                                                            WHEN
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) = 3 OR
                                                                                (CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) - 1) % 511232 = 0
                                                                                    THEN
                                                                                        N''''''''SGAM''''''''
                                                                            WHEN
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) = 6 OR
                                                                                (CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) - 6) % 511232 = 0
                                                                                    THEN
                                                                                        N''''''''DCM''''''''
                                                                            WHEN
                                                                                CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) = 7 OR
                                                                                (CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'''''''':'''''''', REVERSE(wt.resource_description)) - 1)) - 7) % 511232 = 0
                                                                                    THEN
                                                                                        N''''''''BCM''''''''
                                                                            ELSE
                                                                                N''''''''*''''''''
                                                                        END +
                                                                    N'''''''')''''''''
                                                                WHEN wt.wait_type IN (N''''''''CXPACKET'''''''', N''''''''CXCONSUMER'''''''', N''''''''CXSYNC_PORT'''''''', N''''''''CXSYNC_CONSUMER'''''''') THEN
                                                                    N'''''''':'''''''' +
                                                                        SUBSTRING
                                                                        (
                                                                            wt.resource_description,
                                                                            CHARINDEX(N''''''''nodeId'''''''', wt.resource_description) + 7,
                                                                            CASE
                                                                                WHEN CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''nodeId'''''''', wt.resource_description)) > 0
                                                                                 THEN CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''nodeId'''''''', wt.resource_description) + 7) - 7 - CHARINDEX(N''''''''nodeId'''''''', wt.resource_description)
                                                                                ELSE 4
                                                                            END
                                                                        )
                                                                WHEN wt.wait_type LIKE N''''''''LATCH[_]%'''''''' THEN
                                                                    N'''''''' ['''''''' + LEFT(wt.resource_description, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 1) + N'''''''']''''''''
                                                                ELSE
                                                                    N''''''''''''''''
                                                            END COLLATE Latin1_General_Bin2 AS wait_type,
                                                        CASE
                                                            WHEN
                                                            (
                                                                wt.blocking_session_id IS NOT NULL
                                                                AND wt.wait_type LIKE N''''''''LCK[_]%''''''''
                                                            ) THEN
                                                                (
                                                                    SELECT TOP(@i)
                                                                        x.lock_type,
                                                                        REPLACE
                                                                        (
                                                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                                                DB_NAME
                                                                                (
                                                                                    CONVERT
                                                                                    (
                                                                                        INT,
                                                                                        SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''dbid='''''''', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''dbid='''''''', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''dbid='''''''', wt.resource_description) - 5)
                                                                                    )
                                                                                ),
                                                                                NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                                                                NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                                                                NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                                                            NCHAR(0),
                                                                            N''''''''''''''''
                                                                        ) AS database_name,
                                                                        CASE x.lock_type
                                                                            WHEN N''''''''objectlock'''''''' THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''objid='''''''', wt.resource_description), 0) + 6, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''objid='''''''', wt.resource_description) + 6), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''objid='''''''', wt.resource_description) - 6)
                                                                            ELSE
                                                                                NULL
                                                                        END AS object_id,
                                                                        CASE x.lock_type
                                                                            WHEN N''''''''filelock'''''''' THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''fileid='''''''', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''fileid='''''''', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''fileid='''''''', wt.resource_description) - 7)
                                                                            ELSE
                                                                                NULL
                                                                        END AS file_id,
                                                                        CASE
                                                                            WHEN x.lock_type in (N''''''''pagelock'''''''', N''''''''extentlock'''''''', N''''''''ridlock'''''''') THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''associatedObjectId='''''''', wt.resource_description), 0) + 19, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''associatedObjectId='''''''', wt.resource_description) + 19), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''associatedObjectId='''''''', wt.resource_description) - 19)
                                                                            WHEN x.lock_type in (N''''''''keylock'''''''', N''''''''hobtlock'''''''', N''''''''allocunitlock'''''''') THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''hobtid='''''''', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''hobtid='''''''', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''hobtid='''''''', wt.resource_description) - 7)
                                                                            ELSE
                                                                                NULL
                                                                        END AS hobt_id,
                                                                        CASE x.lock_type
                                                                            WHEN N''''''''applicationlock'''''''' THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''hash='''''''', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''hash='''''''', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''hash='''''''', wt.resource_description) - 5)
                                                                            ELSE
                                                                                NULL
                                                                        END AS applock_hash,
                                                                        CASE x.lock_type
                                                                            WHEN N''''''''metadatalock'''''''' THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''subresource='''''''', wt.resource_description), 0) + 12, COALESCE(NULLIF(CHARINDEX(N'''''''' '''''''', wt.resource_description, CHARINDEX(N''''''''subresource='''''''', wt.resource_description) + 12), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''''''''subresource='''''''', wt.resource_description) - 12)
                                                                            ELSE
                                                                                NULL
                                                                        END AS metadata_resource,
                                                                        CASE x.lock_type
                                                                            WHEN N''''''''metadatalock'''''''' THEN
                                                                                SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''''''''classid='''''''', wt.resource_description), 0) + 8, COALESCE(NULLIF(CHARINDEX(N'''''''' dbid='''''''', wt.resource_description) - CHARINDEX(N''''''''classid='''''''', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 8)
                                                                            ELSE
                                                                                NULL
                                                                        END AS metadata_class_id
                                                                    FROM
                                                                    (
                                                                        SELECT TOP(1)
                                                                            LEFT(wt.resource_description, CHARINDEX(N'''''''' '''''''', wt.resource_description) - 1) COLLATE Latin1_General_Bin2 AS lock_type
                                                                    ) AS x
                                                                    FOR XML
                                                                        PATH('''''''''''''''')
                                                                )
                                                            ELSE NULL
                                                        END AS block_info,
                                                        wt.wait_duration_ms,
                                                        wt.waiting_task_address
                                                    FROM
                                                    (
                                                        SELECT TOP(@i)
                                                            wt0.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
                                                            LEFT
                                                            (
                                                                p.resource_description,
                                                                ISNULL(NULLIF(CHARINDEX('''''''' (LATCH '''''''', p.resource_description) - 1, -1), 256)
                                                            ) AS resource_description,
                                                            wt0.wait_duration_ms,
                                                            wt0.waiting_task_address,
                                                            CASE
                                                                WHEN wt0.blocking_session_id = p.blocked THEN
                                                                    wt0.blocking_session_id
                                                                ELSE
                                                                    NULL
                                                            END AS blocking_session_id
                                                        FROM sys.dm_os_waiting_tasks AS wt0
                                                        CROSS APPLY
                                                        (
                                                            SELECT TOP(1)
                                                                s0.blocked,
                                                                wt0.resource_description COLLATE Latin1_General_Bin2 AS resource_description
                                                            FROM @sessions AS s0
                                                            WHERE
                                                                s0.session_id = wt0.session_id
                                                                AND COALESCE(s0.wait_type, N'''''''''''''''') <> N''''''''OLEDB''''''''
                                                                AND wt0.wait_type <> N''''''''OLEDB''''''''
                                                        ) AS p
                                                    ) AS wt
                                                ) AS wt1
                                                GROUP BY
                                                    wt1.wait_type,
                                                    wt1.waiting_task_address
                                            ) AS wt2 ON
                                                wt2.waiting_task_address = task_info.task_address
                                                AND wt2.wait_duration_ms > 0
                                                AND task_info.runnable_time IS NULL
                                            GROUP BY
                                                task_info.session_id,
                                                task_info.request_id,
                                                task_info.physical_io,
                                                task_info.context_switches,
                                                task_info.thread_CPU_snapshot,
                                                task_info.num_tasks,
                                                CASE
                                                    WHEN task_info.runnable_time IS NOT NULL THEN
                                                        ''''''''RUNNABLE''''''''
                                                    ELSE
                                                        wt2.wait_type
                                                END
                                        ) AS w1
                                    ) AS waits
                                    ORDER BY
                                        waits.session_id,
                                        waits.request_id,
                                        waits.r
                                    FOR XML
                                        PATH(N''''''''tasks''''''''),
                                        TYPE
                                ) AS tasks_raw (task_xml_raw)
                            ) AS tasks_final
                            CROSS APPLY tasks_final.task_xml.nodes(N''''''''/tasks'''''''') AS task_nodes (task_node)
                            WHERE
                                task_nodes.task_node.exist(N''''''''session_id'''''''') = 1
                        ) AS tasks ON
                            tasks.session_id = y.session_id
                            AND tasks.request_id = y.request_id
                        ''''
                    ELSE
                        ''''''''
                END +
                ''''LEFT OUTER HASH JOIN
                (
                    SELECT TOP(@i)
                        t_info.session_id,
                        COALESCE(t_info.request_id, -1) AS request_id,
                        SUM(t_info.tempdb_allocations) AS tempdb_allocations,
                        SUM(t_info.tempdb_current) AS tempdb_current
                    FROM
                    (
                        SELECT TOP(@i)
                            tsu.session_id,
                            tsu.request_id,
                            tsu.user_objects_alloc_page_count +
                                tsu.internal_objects_alloc_page_count AS tempdb_allocations,
                            tsu.user_objects_alloc_page_count +
                                tsu.internal_objects_alloc_page_count -
                                tsu.user_objects_dealloc_page_count -
                                tsu.internal_objects_dealloc_page_count AS tempdb_current
                        FROM sys.dm_db_task_space_usage AS tsu
                        CROSS APPLY
                        (
                            SELECT TOP(1)
                                s0.session_id
                            FROM @sessions AS s0
                            WHERE
                                s0.session_id = tsu.session_id
                        ) AS p

                        UNION ALL

                        SELECT TOP(@i)
                            ssu.session_id,
                            NULL AS request_id,
                            ssu.user_objects_alloc_page_count +
                                ssu.internal_objects_alloc_page_count AS tempdb_allocations,
                            ssu.user_objects_alloc_page_count +
                                ssu.internal_objects_alloc_page_count -
                                ssu.user_objects_dealloc_page_count -
                                ssu.internal_objects_dealloc_page_count AS tempdb_current
                        FROM sys.dm_db_session_space_usage AS ssu
                        CROSS APPLY
                        (
                            SELECT TOP(1)
                                s0.session_id
                            FROM @sessions AS s0
                            WHERE
                                s0.session_id = ssu.session_id
                        ) AS p
                    ) AS t_info
                    GROUP BY
                        t_info.session_id,
                        COALESCE(t_info.request_id, -1)
                ) AS tempdb_info ON
                    tempdb_info.session_id = y.session_id
                    AND tempdb_info.request_id =
                        CASE
                            WHEN y.status = N''''''''sleeping'''''''' THEN
                                -1
                            ELSE
                                y.request_id
                        END
                '''' +
                CASE
                    WHEN
                        NOT
                        (
                            @get_avg_time = 1
                            AND @recursion = 1
                        ) THEN
                            ''''''''
                    ELSE
                        ''''LEFT OUTER HASH JOIN
                        (
                            SELECT TOP(@i)
                                *
                            FROM sys.dm_exec_query_stats
                        ) AS qs ON
                            qs.sql_handle = y.sql_handle
                            AND qs.plan_handle = y.plan_handle
                            AND qs.statement_start_offset = y.statement_start_offset
                            AND qs.statement_end_offset = y.statement_end_offset
                        ''''
                END +
            '''') AS x
            OPTION (KEEPFIXED PLAN, OPTIMIZE FOR (@i = 1)); '''';

        SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

        SET @last_collection_start = GETDATE();

        IF
            @recursion = -1
            AND @sys_info = 1
        BEGIN;
            SELECT
                @first_collection_ms_ticks = ms_ticks
            FROM sys.dm_os_sys_info;
        END;

        INSERT #sessions
        (
            recursion,
            session_id,
            request_id,
            session_number,
            elapsed_time,
            avg_elapsed_time,
            physical_io,
            reads,
            physical_reads,
            writes,
            tempdb_allocations,
            tempdb_current,
            CPU,
            thread_CPU_snapshot,
            context_switches,
            used_memory,
            max_used_memory,
            requested_memory,
            granted_memory,
            tasks,
            status,
            wait_info,
            transaction_id,
            open_tran_count,
            sql_handle,
            statement_start_offset,
            statement_end_offset,       
            sql_text,
            plan_handle,
            blocking_session_id,
            percent_complete,
            host_name,
            login_name,
            database_name,
            program_name,
            additional_info,
            memory_info,
            start_time,
            login_time,
            last_request_start_time
        )
        EXEC sp_executesql
            @sql_n,
            N''''@recursion SMALLINT, @filter sysname, @not_filter sysname, @first_collection_ms_ticks BIGINT'''',
            @recursion, @filter, @not_filter, @first_collection_ms_ticks;

        --Collect transaction information?
        IF
            @recursion = 1
            AND
            (
                @output_column_list LIKE ''''%|[tran_start_time|]%'''' ESCAPE ''''|''''
                OR @output_column_list LIKE ''''%|[tran_log_writes|]%'''' ESCAPE ''''|''''
                OR @output_column_list LIKE ''''%|[implicit_tran|]%'''' ESCAPE ''''|''''
            )
        BEGIN;   
            DECLARE @i INT;
            SET @i = 2147483647;

            UPDATE s
            SET
                tran_start_time =
                    CONVERT
                    (
                        DATETIME,
                        LEFT
                        (
                            x.trans_info,
                            NULLIF(CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info) - 1, -1)
                        ),
                        121
                    ),
                tran_log_writes =
                    RIGHT
                    (
                        x.trans_info,
                        LEN(x.trans_info) - CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info)
                    ),
                implicit_tran =
                    CASE
                        WHEN x.implicit_tran = 1 THEN ''''ON''''
                        ELSE ''''OFF''''
                    END
            FROM
            (
                SELECT TOP(@i)
                    trans_nodes.trans_node.value(''''(session_id/text())[1]'''', ''''SMALLINT'''') AS session_id,
                    COALESCE(trans_nodes.trans_node.value(''''(request_id/text())[1]'''', ''''INT''''), 0) AS request_id,
                    trans_nodes.trans_node.value(''''(implicit_tran/text())[1]'''', ''''INT'''') AS implicit_tran,
                    trans_nodes.trans_node.value(''''(trans_info/text())[1]'''', ''''NVARCHAR(4000)'''') AS trans_info
                FROM
                (
                    SELECT TOP(@i)
                        CONVERT
                        (
                            XML,
                            REPLACE
                            (
                                CONVERT(NVARCHAR(MAX), trans_raw.trans_xml_raw) COLLATE Latin1_General_Bin2,
                                N''''</trans_info></trans><trans><trans_info>'''', N''''''''
                            )
                        )
                    FROM
                    (
                        SELECT TOP(@i)
                            CASE u_trans.r
                                WHEN 1 THEN u_trans.session_id
                                ELSE NULL
                            END AS [session_id],
                            CASE u_trans.r
                                WHEN 1 THEN u_trans.request_id
                                ELSE NULL
                            END AS [request_id],
                            u_trans.implicit_tran AS [implicit_tran],
                            CONVERT
                            (
                                NVARCHAR(MAX),
                                CASE
                                    WHEN u_trans.database_id IS NOT NULL THEN
                                        CASE u_trans.r
                                            WHEN 1 THEN COALESCE(CONVERT(NVARCHAR, u_trans.transaction_start_time, 121) + NCHAR(254), N'''''''')
                                            ELSE N''''''''
                                        END +
                                            REPLACE
                                            (
                                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                    CONVERT(VARCHAR(128), COALESCE(DB_NAME(u_trans.database_id), N''''(null)'''')),
                                                    NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                                    NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                                    NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                                                NCHAR(0),
                                                N''''?''''
                                            ) +
                                            N'''': '''' +
                                        CONVERT(NVARCHAR, u_trans.log_record_count) + N'''' ('''' + CONVERT(NVARCHAR, u_trans.log_kb_used) + N'''' kB)'''' +
                                        N'''',''''
                                    ELSE
                                        N''''N/A,''''
                                END COLLATE Latin1_General_Bin2
                            ) AS [trans_info]
                        FROM
                        (
                            SELECT TOP(@i)
                                trans.*,
                                ROW_NUMBER() OVER
                                (
                                    PARTITION BY
                                        trans.session_id,
                                        trans.request_id
                                    ORDER BY
                                        trans.transaction_start_time DESC
                                ) AS r
                            FROM
                            (
                                SELECT TOP(@i)
                                    session_tran_map.session_id,
                                    session_tran_map.request_id,
                                    s_tran.database_id,
                                    COALESCE(SUM(s_tran.database_transaction_log_record_count), 0) AS log_record_count,
                                    COALESCE(SUM(s_tran.database_transaction_log_bytes_used), 0) / 1024 AS log_kb_used,
                                    MIN(s_tran.database_transaction_begin_time) AS transaction_start_time,
                                    MAX
                                    (
                                        CASE
                                            WHEN a_tran.name = ''''implicit_transaction'''' THEN 1
                                            ELSE 0
                                        END
                                    ) AS implicit_tran
                                FROM
                                (
                                    SELECT TOP(@i)
                                        *
                                    FROM sys.dm_tran_active_transactions
                                    WHERE
                                        transaction_begin_time <= @last_collection_start
                                ) AS a_tran
                                INNER HASH JOIN
                                (
                                    SELECT TOP(@i)
                                        *
                                    FROM sys.dm_tran_database_transactions
                                    WHERE
                                        database_id < 32767
                                ) AS s_tran ON
                                    s_tran.transaction_id = a_tran.transaction_id
                                LEFT OUTER HASH JOIN
                                (
                                    SELECT TOP(@i)
                                        *
                                    FROM sys.dm_tran_session_transactions
                                ) AS tst ON
                                    s_tran.transaction_id = tst.transaction_id
                                CROSS APPLY
                                (
                                    SELECT TOP(1)
                                        s3.session_id,
                                        s3.request_id
                                    FROM
                                    (
                                        SELECT TOP(1)
                                            s1.session_id,
                                            s1.request_id
                                        FROM #sessions AS s1
                                        WHERE
                                            s1.transaction_id = s_tran.transaction_id
                                            AND s1.recursion = 1
                                           
                                        UNION ALL
                                   
                                        SELECT TOP(1)
                                            s2.session_id,
                                            s2.request_id
                                        FROM #sessions AS s2
                                        WHERE
                                            s2.session_id = tst.session_id
                                            AND s2.recursion = 1
                                    ) AS s3
                                    ORDER BY
                                        s3.request_id
                                ) AS session_tran_map
                                GROUP BY
                                    session_tran_map.session_id,
                                    session_tran_map.request_id,
                                    s_tran.database_id
                            ) AS trans
                        ) AS u_trans
                        FOR XML
                            PATH(''''trans''''),
                            TYPE
                    ) AS trans_raw (trans_xml_raw)
                ) AS trans_final (trans_xml)
                CROSS APPLY trans_final.trans_xml.nodes(''''/trans'''') AS trans_nodes (trans_node)
            ) AS x
            INNER HASH JOIN #sessions AS s ON
                s.session_id = x.session_id
                AND s.request_id = x.request_id
            OPTION (OPTIMIZE FOR (@i = 1));
        END;

        --Variables for text and plan collection
        DECLARE   
            @session_id SMALLINT,
            @request_id INT,
            @sql_handle VARBINARY(64),
            @plan_handle VARBINARY(64),
            @statement_start_offset INT,
            @statement_end_offset INT,
            @start_time DATETIME,
            @database_name sysname;

        IF
            @recursion = 1
            AND @output_column_list LIKE ''''%|[sql_text|]%'''' ESCAPE ''''|''''
        BEGIN;
            DECLARE sql_cursor
            CURSOR LOCAL FAST_FORWARD
            FOR
                SELECT
                    session_id,
                    request_id,
                    sql_handle,
                    statement_start_offset,
                    statement_end_offset
                FROM #sessions
                WHERE
                    recursion = 1
                    AND sql_handle IS NOT NULL
            OPTION (KEEPFIXED PLAN);

            OPEN sql_cursor;

            FETCH NEXT FROM sql_cursor
            INTO
                @session_id,
                @request_id,
                @sql_handle,
                @statement_start_offset,
                @statement_end_offset;

            --Wait up to 5 ms for the SQL text, then give up
            SET LOCK_TIMEOUT 5;

            WHILE @@FETCH_STATUS = 0
            BEGIN;
                BEGIN TRY;
                    UPDATE s
                    SET
                        s.sql_text =
                        (
                            SELECT
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        N''''--'''' + NCHAR(13) + NCHAR(10) +
                                        CASE
                                            WHEN @get_full_inner_text = 1 THEN est.text
                                            WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN est.text
                                            WHEN SUBSTRING(est.text, (@statement_start_offset/2), 2) LIKE N''''[a-zA-Z0-9][a-zA-Z0-9]'''' THEN est.text
                                            ELSE
                                                CASE
                                                    WHEN @statement_start_offset > 0 THEN
                                                        SUBSTRING
                                                        (
                                                            est.text,
                                                            ((@statement_start_offset/2) + 1),
                                                            (
                                                                CASE
                                                                    WHEN @statement_end_offset = -1 THEN 2147483647
                                                                    ELSE ((@statement_end_offset - @statement_start_offset)/2) + 1
                                                                END
                                                            )
                                                        )
                                                    ELSE RTRIM(LTRIM(est.text))
                                                END
                                        END +
                                        NCHAR(13) + NCHAR(10) + N''''--'''' COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                        NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                        NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                                    NCHAR(0),
                                    N''''''''
                                ) AS [processing-instruction(query)]
                            FOR XML
                                PATH(''''''''),
                                TYPE
                        ),
                        s.statement_start_offset =
                            CASE
                                WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN 0
                                WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE ''''[a-zA-Z0-9][a-zA-Z0-9]'''' THEN 0
                                ELSE @statement_start_offset
                            END,
                        s.statement_end_offset =
                            CASE
                                WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN -1
                                WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE ''''[a-zA-Z0-9][a-zA-Z0-9]'''' THEN -1
                                ELSE @statement_end_offset
                            END
                    FROM
                        #sessions AS s,
                        (
                            SELECT TOP(1)
                                text
                            FROM
                            (
                                SELECT
                                    text,
                                    0 AS row_num
                                FROM sys.dm_exec_sql_text(@sql_handle)
                               
                                UNION ALL
                               
                                SELECT
                                    NULL,
                                    1 AS row_num
                            ) AS est0
                            ORDER BY
                                row_num
                        ) AS est
                    WHERE
                        s.session_id = @session_id
                        AND s.request_id = @request_id
                        AND s.recursion = 1
                    OPTION (KEEPFIXED PLAN);
                END TRY
                BEGIN CATCH;
                    UPDATE s
                    SET
                        s.sql_text =
                            CASE ERROR_NUMBER()
                                WHEN 1222 THEN ''''<timeout_exceeded />''''
                                ELSE ''''<error message="'''' + ERROR_MESSAGE() + ''''" />''''
                            END
                    FROM #sessions AS s
                    WHERE
                        s.session_id = @session_id
                        AND s.request_id = @request_id
                        AND s.recursion = 1
                    OPTION (KEEPFIXED PLAN);
                END CATCH;

                FETCH NEXT FROM sql_cursor
                INTO
                    @session_id,
                    @request_id,
                    @sql_handle,
                    @statement_start_offset,
                    @statement_end_offset;
            END;

            --Return this to the default
            SET LOCK_TIMEOUT -1;

            CLOSE sql_cursor;
            DEALLOCATE sql_cursor;
        END;

        IF
            @get_outer_command = 1
            AND @recursion = 1
            AND @output_column_list LIKE ''''%|[sql_command|]%'''' ESCAPE ''''|''''
        BEGIN;
            DECLARE @buffer_results TABLE
            (
                EventType VARCHAR(30),
                Parameters INT,
                EventInfo NVARCHAR(4000),
                start_time DATETIME,
                session_number INT IDENTITY(1,1) NOT NULL PRIMARY KEY
            );

            DECLARE buffer_cursor
            CURSOR LOCAL FAST_FORWARD
            FOR
                SELECT
                    session_id,
                    MAX(start_time) AS start_time
                FROM #sessions
                WHERE
                    recursion = 1
                GROUP BY
                    session_id
                ORDER BY
                    session_id
                OPTION (KEEPFIXED PLAN);

            OPEN buffer_cursor;

            FETCH NEXT FROM buffer_cursor
            INTO
                @session_id,
                @start_time;

            WHILE @@FETCH_STATUS = 0
            BEGIN;
                BEGIN TRY;
                    --In SQL Server 2008, DBCC INPUTBUFFER will throw
                    --an exception if the session no longer exists
                    INSERT @buffer_results
                    (
                        EventType,
                        Parameters,
                        EventInfo
                    )
                    EXEC sp_executesql
                        N''''DBCC INPUTBUFFER(@session_id) WITH NO_INFOMSGS;'''',
                        N''''@session_id SMALLINT'''',
                        @session_id;

                    UPDATE br
                    SET
                        br.start_time = @start_time
                    FROM @buffer_results AS br
                    WHERE
                        br.session_number =
                        (
                            SELECT MAX(br2.session_number)
                            FROM @buffer_results br2
                        );
                END TRY
                BEGIN CATCH
                END CATCH;

                FETCH NEXT FROM buffer_cursor
                INTO
                    @session_id,
                    @start_time;
            END;

            UPDATE s
            SET
                sql_command =
                (
                    SELECT
                        REPLACE
                        (
                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                CONVERT
                                (
                                    NVARCHAR(MAX),
                                    N''''--'''' + NCHAR(13) + NCHAR(10) + br.EventInfo + NCHAR(13) + NCHAR(10) + N''''--'''' COLLATE Latin1_General_Bin2
                                ),
                                NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                            NCHAR(0),
                            N''''''''
                        ) AS [processing-instruction(query)]
                    FROM @buffer_results AS br
                    WHERE
                        br.session_number = s.session_number
                        AND br.start_time = s.start_time
                        AND
                        (
                            (
                                s.start_time = s.last_request_start_time
                                AND EXISTS
                                (
                                    SELECT *
                                    FROM sys.dm_exec_requests r2
                                    WHERE
                                        r2.session_id = s.session_id
                                        AND r2.request_id = s.request_id
                                        AND r2.start_time = s.start_time
                                )
                            )
                            OR
                            (
                                s.request_id = 0
                                AND EXISTS
                                (
                                    SELECT *
                                    FROM sys.dm_exec_sessions s2
                                    WHERE
                                        s2.session_id = s.session_id
                                        AND s2.last_request_start_time = s.last_request_start_time
                                )
                            )
                        )
                    FOR XML
                        PATH(''''''''),
                        TYPE
                )
            FROM #sessions AS s
            WHERE
                recursion = 1
            OPTION (KEEPFIXED PLAN);

            CLOSE buffer_cursor;
            DEALLOCATE buffer_cursor;
        END;

        IF
            @get_plans >= 1
            AND @recursion = 1
            AND @output_column_list LIKE ''''%|[query_plan|]%'''' ESCAPE ''''|''''
        BEGIN;
            DECLARE @live_plan BIT;
            SET @live_plan = ISNULL(CONVERT(BIT, SIGN(OBJECT_ID(''''sys.dm_exec_query_statistics_xml''''))), 0)

            DECLARE plan_cursor
            CURSOR LOCAL FAST_FORWARD
            FOR
                SELECT
                    session_id,
                    request_id,
                    plan_handle,
                    statement_start_offset,
                    statement_end_offset
                FROM #sessions
                WHERE
                    recursion = 1
                    AND plan_handle IS NOT NULL
            OPTION (KEEPFIXED PLAN);

            OPEN plan_cursor;

            FETCH NEXT FROM plan_cursor
            INTO
                @session_id,
                @request_id,
                @plan_handle,
                @statement_start_offset,
                @statement_end_offset;

            --Wait up to 5 ms for a query plan, then give up
            SET LOCK_TIMEOUT 5;

            WHILE @@FETCH_STATUS = 0
            BEGIN;
                DECLARE @query_plan XML;
                SET @query_plan = NULL;

                IF @live_plan = 1
                BEGIN;
                    BEGIN TRY;
                        SELECT
                            @query_plan = x.query_plan
                        FROM sys.dm_exec_query_statistics_xml(@session_id) AS x;

                        IF
                            @query_plan IS NOT NULL
                            AND EXISTS
                            (
                                SELECT
                                    *
                                FROM sys.dm_exec_requests AS r
                                WHERE
                                    r.session_id = @session_id
                                    AND r.request_id = @request_id
                                    AND r.plan_handle = @plan_handle
                                    AND r.statement_start_offset = @statement_start_offset
                                    AND r.statement_end_offset = @statement_end_offset
                            )
                        BEGIN;
                            UPDATE s
                            SET
                                s.query_plan = @query_plan
                            FROM #sessions AS s
                            WHERE
                                s.session_id = @session_id
                                AND s.request_id = @request_id
                                AND s.recursion = 1
                            OPTION (KEEPFIXED PLAN);
                        END;
                    END TRY
                    BEGIN CATCH;
                        SET @query_plan = NULL;
                    END CATCH;
                END;

                IF @query_plan IS NULL
                BEGIN;
                    BEGIN TRY;
                        UPDATE s
                        SET
                            s.query_plan =
                            (
                                SELECT
                                    CONVERT(xml, query_plan)
                                FROM sys.dm_exec_text_query_plan
                                (
                                    @plan_handle,
                                    CASE @get_plans
                                        WHEN 1 THEN
                                            @statement_start_offset
                                        ELSE
                                            0
                                    END,
                                    CASE @get_plans
                                        WHEN 1 THEN
                                            @statement_end_offset
                                        ELSE
                                            -1
                                    END
                                )
                            )
                        FROM #sessions AS s
                        WHERE
                            s.session_id = @session_id
                            AND s.request_id = @request_id
                            AND s.recursion = 1
                        OPTION (KEEPFIXED PLAN);
                    END TRY
                    BEGIN CATCH;
                        IF ERROR_NUMBER() = 6335
                        BEGIN;
                            UPDATE s
                            SET
                                s.query_plan =
                                (
                                    SELECT
                                        N''''--'''' + NCHAR(13) + NCHAR(10) +
                                        N''''-- Could not render showplan due to XML data type limitations. '''' + NCHAR(13) + NCHAR(10) +
                                        N''''-- To see the graphical plan save the XML below as a .SQLPLAN file and re-open in SSMS.'''' + NCHAR(13) + NCHAR(10) +
                                        N''''--'''' + NCHAR(13) + NCHAR(10) +
                                            REPLACE(qp.query_plan, N''''<RelOp'''', NCHAR(13)+NCHAR(10)+N''''<RelOp'''') +
                                            NCHAR(13) + NCHAR(10) + N''''--'''' COLLATE Latin1_General_Bin2 AS [processing-instruction(query_plan)]
                                    FROM sys.dm_exec_text_query_plan
                                    (
                                        @plan_handle,
                                        CASE @get_plans
                                            WHEN 1 THEN
                                                @statement_start_offset
                                            ELSE
                                                0
                                        END,
                                        CASE @get_plans
                                            WHEN 1 THEN
                                                @statement_end_offset
                                            ELSE
                                                -1
                                        END
                                    ) AS qp
                                    FOR XML
                                        PATH(''''''''),
                                        TYPE
                                )
                            FROM #sessions AS s
                            WHERE
                                s.session_id = @session_id
                                AND s.request_id = @request_id
                                AND s.recursion = 1
                            OPTION (KEEPFIXED PLAN);
                        END;
                        ELSE
                        BEGIN;
                            UPDATE s
                            SET
                                s.query_plan =
                                    CASE ERROR_NUMBER()
                                        WHEN 1222 THEN ''''<timeout_exceeded />''''
                                        ELSE ''''<error message="'''' + ERROR_MESSAGE() + ''''" />''''
                                    END
                            FROM #sessions AS s
                            WHERE
                                s.session_id = @session_id
                                AND s.request_id = @request_id
                                AND s.recursion = 1
                            OPTION (KEEPFIXED PLAN);
                        END;
                    END CATCH;
                END;

                FETCH NEXT FROM plan_cursor
                INTO
                    @session_id,
                    @request_id,
                    @plan_handle,
                    @statement_start_offset,
                    @statement_end_offset;
            END;

            --Return this to the default
            SET LOCK_TIMEOUT -1;

            CLOSE plan_cursor;
            DEALLOCATE plan_cursor;
        END;

        IF
            @get_locks = 1
            AND @recursion = 1
            AND @output_column_list LIKE ''''%|[locks|]%'''' ESCAPE ''''|''''
        BEGIN;
            DECLARE locks_cursor
            CURSOR LOCAL FAST_FORWARD
            FOR
                SELECT DISTINCT
                    database_name
                FROM #locks
                WHERE
                    EXISTS
                    (
                        SELECT *
                        FROM #sessions AS s
                        WHERE
                            s.session_id = #locks.session_id
                            AND recursion = 1
                    )
                    AND database_name <> ''''(null)''''
                OPTION (KEEPFIXED PLAN);

            OPEN locks_cursor;

            FETCH NEXT FROM locks_cursor
            INTO
                @database_name;

            WHILE @@FETCH_STATUS = 0
            BEGIN;
                BEGIN TRY;
                    SET @sql_n = CONVERT(NVARCHAR(MAX), N'''''''') + N''''
                        UPDATE l
                        SET
                            object_name =
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        o.name COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                        NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                        NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                    NCHAR(0),
                                    N''''''''''''''''
                                ),
                            index_name =
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        i.name COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                        NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                        NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                    NCHAR(0),
                                    N''''''''''''''''
                                ),
                            schema_name =
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        s.name COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                        NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                        NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                    NCHAR(0),
                                    N''''''''''''''''
                                ),
                            principal_name =
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        dp.name COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                        NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                        NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                    NCHAR(0),
                                    N''''''''''''''''
                                )
                        FROM #locks AS l
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.allocation_units AS au ON
                            au.allocation_unit_id = l.allocation_unit_id
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.partitions AS p ON
                            p.hobt_id =
                                COALESCE
                                (
                                    l.hobt_id,
                                    CASE
                                        WHEN au.type IN (1, 3) THEN au.container_id
                                        ELSE NULL
                                    END
                                )
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.partitions AS p1 ON
                            l.hobt_id IS NULL
                            AND au.type = 2
                            AND p1.partition_id = au.container_id
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.objects AS o ON
                            o.object_id = COALESCE(l.object_id, p.object_id, p1.object_id)
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.indexes AS i ON
                            i.object_id = COALESCE(l.object_id, p.object_id, p1.object_id)
                            AND i.index_id = COALESCE(l.index_id, p.index_id, p1.index_id)
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.schemas AS s ON
                            s.schema_id = COALESCE(l.schema_id, o.schema_id)
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.database_principals AS dp ON
                            dp.principal_id = l.principal_id
                        WHERE
                            l.database_name = @database_name
                        OPTION (KEEPFIXED PLAN); '''';

                    EXEC sp_executesql
                        @sql_n,
                        N''''@database_name sysname'''',
                        @database_name;
                END TRY
                BEGIN CATCH;
                    UPDATE #locks
                    SET
                        query_error =
                            REPLACE
                            (
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    CONVERT
                                    (
                                        NVARCHAR(MAX),
                                        ERROR_MESSAGE() COLLATE Latin1_General_Bin2
                                    ),
                                    NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                    NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                    NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                                NCHAR(0),
                                N''''''''
                            )
                    WHERE
                        database_name = @database_name
                    OPTION (KEEPFIXED PLAN);
                END CATCH;

                FETCH NEXT FROM locks_cursor
                INTO
                    @database_name;
            END;

            CLOSE locks_cursor;
            DEALLOCATE locks_cursor;

            CREATE CLUSTERED INDEX IX_SRD ON #locks (session_id, request_id, database_name);

            UPDATE s
            SET
                s.locks =
                (
                    SELECT
                        REPLACE
                        (
                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                CONVERT
                                (
                                    NVARCHAR(MAX),
                                    l1.database_name COLLATE Latin1_General_Bin2
                                ),
                                NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                            NCHAR(0),
                            N''''''''
                        ) AS [Database/@name],
                        MIN(l1.query_error) AS [Database/@query_error],
                        (
                            SELECT
                                l2.request_mode AS [Lock/@request_mode],
                                l2.request_status AS [Lock/@request_status],
                                COUNT(*) AS [Lock/@request_count]
                            FROM #locks AS l2
                            WHERE
                                l1.session_id = l2.session_id
                                AND l1.request_id = l2.request_id
                                AND l2.database_name = l1.database_name
                                AND l2.resource_type = ''''DATABASE''''
                            GROUP BY
                                l2.request_mode,
                                l2.request_status
                            FOR XML
                                PATH(''''''''),
                                TYPE
                        ) AS [Database/Locks],
                        (
                            SELECT
                                COALESCE(l3.object_name, ''''(null)'''') AS [Object/@name],
                                l3.schema_name AS [Object/@schema_name],
                                (
                                    SELECT
                                        l4.resource_type AS [Lock/@resource_type],
                                        l4.page_type AS [Lock/@page_type],
                                        l4.index_name AS [Lock/@index_name],
                                        CASE
                                            WHEN l4.object_name IS NULL THEN l4.schema_name
                                            ELSE NULL
                                        END AS [Lock/@schema_name],
                                        l4.principal_name AS [Lock/@principal_name],
                                        REPLACE
                                        (
                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                                l4.resource_description COLLATE Latin1_General_Bin2,
                                                NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                                NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                                NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                                            NCHAR(0),
                                            N''''''''
                                        ) AS [Lock/@resource_description],
                                        l4.request_mode AS [Lock/@request_mode],
                                        l4.request_status AS [Lock/@request_status],
                                        SUM(l4.request_count) AS [Lock/@request_count]
                                    FROM #locks AS l4
                                    WHERE
                                        l4.session_id = l3.session_id
                                        AND l4.request_id = l3.request_id
                                        AND l3.database_name = l4.database_name
                                        AND COALESCE(l3.object_name, ''''(null)'''') = COALESCE(l4.object_name, ''''(null)'''')
                                        AND COALESCE(l3.schema_name, '''''''') = COALESCE(l4.schema_name, '''''''')
                                        AND l4.resource_type <> ''''DATABASE''''
                                    GROUP BY
                                        l4.resource_type,
                                        l4.page_type,
                                        l4.index_name,
                                        CASE
                                            WHEN l4.object_name IS NULL THEN l4.schema_name
                                            ELSE NULL
                                        END,
                                        l4.principal_name,
                                        l4.resource_description,
                                        l4.request_mode,
                                        l4.request_status
                                    FOR XML
                                        PATH(''''''''),
                                        TYPE
                                ) AS [Object/Locks]
                            FROM #locks AS l3
                            WHERE
                                l3.session_id = l1.session_id
                                AND l3.request_id = l1.request_id
                                AND l3.database_name = l1.database_name
                                AND l3.resource_type <> ''''DATABASE''''
                            GROUP BY
                                l3.session_id,
                                l3.request_id,
                                l3.database_name,
                                COALESCE(l3.object_name, ''''(null)''''),
                                l3.schema_name
                            FOR XML
                                PATH(''''''''),
                                TYPE
                        ) AS [Database/Objects]
                    FROM #locks AS l1
                    WHERE
                        l1.session_id = s.session_id
                        AND l1.request_id = s.request_id
                        AND l1.start_time IN (s.start_time, s.last_request_start_time)
                        AND s.recursion = 1
                    GROUP BY
                        l1.session_id,
                        l1.request_id,
                        l1.database_name
                    FOR XML
                        PATH(''''''''),
                        TYPE
                )
            FROM #sessions s
            OPTION (KEEPFIXED PLAN);
        END;

        IF
            @find_block_leaders = 1
            AND @recursion = 1
            AND @output_column_list LIKE ''''%|[blocked_session_count|]%'''' ESCAPE ''''|''''
        BEGIN;
            WITH
            blockers AS
            (
                SELECT
                    session_id,
                    session_id AS top_level_session_id,
                    CONVERT(VARCHAR(8000), ''''.'''' + CONVERT(VARCHAR(8000), session_id) + ''''.'''') AS the_path
                FROM #sessions
                WHERE
                    recursion = 1

                UNION ALL

                SELECT
                    s.session_id,
                    b.top_level_session_id,
                    CONVERT(VARCHAR(8000), b.the_path + CONVERT(VARCHAR(8000), s.session_id) + ''''.'''') AS the_path
                FROM blockers AS b
                JOIN #sessions AS s ON
                    s.blocking_session_id = b.session_id
                    AND s.recursion = 1
                    AND b.the_path NOT LIKE ''''%.'''' + CONVERT(VARCHAR(8000), s.session_id) + ''''.%'''' COLLATE Latin1_General_Bin2
            )
            UPDATE s
            SET
                s.blocked_session_count = x.blocked_session_count
            FROM #sessions AS s
            JOIN
            (
                SELECT
                    b.top_level_session_id AS session_id,
                    COUNT(*) - 1 AS blocked_session_count
                FROM blockers AS b
                GROUP BY
                    b.top_level_session_id
            ) x ON
                s.session_id = x.session_id
            WHERE
                s.recursion = 1;
        END;

        IF
            @get_task_info = 2
            AND @output_column_list LIKE ''''%|[additional_info|]%'''' ESCAPE ''''|''''
            AND @recursion = 1
        BEGIN;
            CREATE TABLE #blocked_requests
            (
                session_id SMALLINT NOT NULL,
                request_id INT NOT NULL,
                database_name sysname NOT NULL,
                object_id INT,
                hobt_id BIGINT,
                schema_id INT,
                schema_name sysname NULL,
                object_name sysname NULL,
                query_error NVARCHAR(2048),
                PRIMARY KEY (database_name, session_id, request_id)
            );

            CREATE STATISTICS s_database_name ON #blocked_requests (database_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_schema_name ON #blocked_requests (schema_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_object_name ON #blocked_requests (object_name)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
            CREATE STATISTICS s_query_error ON #blocked_requests (query_error)
            WITH SAMPLE 0 ROWS, NORECOMPUTE;
       
            INSERT #blocked_requests
            (
                session_id,
                request_id,
                database_name,
                object_id,
                hobt_id,
                schema_id
            )
            SELECT
                session_id,
                request_id,
                database_name,
                object_id,
                hobt_id,
                CONVERT(INT, SUBSTRING(schema_node, CHARINDEX('''' = '''', schema_node) + 3, LEN(schema_node))) AS schema_id
            FROM
            (
                SELECT
                    session_id,
                    request_id,
                    agent_nodes.agent_node.value(''''(database_name/text())[1]'''', ''''sysname'''') AS database_name,
                    agent_nodes.agent_node.value(''''(object_id/text())[1]'''', ''''int'''') AS object_id,
                    agent_nodes.agent_node.value(''''(hobt_id/text())[1]'''', ''''bigint'''') AS hobt_id,
                    agent_nodes.agent_node.value(''''(metadata_resource/text()[.="SCHEMA"]/../../metadata_class_id/text())[1]'''', ''''varchar(100)'''') AS schema_node
                FROM #sessions AS s
                CROSS APPLY s.additional_info.nodes(''''//block_info'''') AS agent_nodes (agent_node)
                WHERE
                    s.recursion = 1
            ) AS t
            WHERE
                t.database_name IS NOT NULL
                AND
                (
                    t.object_id IS NOT NULL
                    OR t.hobt_id IS NOT NULL
                    OR t.schema_node IS NOT NULL
                );
           
            DECLARE blocks_cursor
            CURSOR LOCAL FAST_FORWARD
            FOR
                SELECT DISTINCT
                    database_name
                FROM #blocked_requests;
               
            OPEN blocks_cursor;
           
            FETCH NEXT FROM blocks_cursor
            INTO
                @database_name;
           
            WHILE @@FETCH_STATUS = 0
            BEGIN;
                BEGIN TRY;
                    SET @sql_n =
                        CONVERT(NVARCHAR(MAX), N'''''''') + N''''
                        UPDATE b
                        SET
                            b.schema_name =
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        s.name COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                        NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                        NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                    NCHAR(0),
                                    N''''''''''''''''
                                ),
                            b.object_name =
                                REPLACE
                                (
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                        o.name COLLATE Latin1_General_Bin2,
                                        NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                        NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                        NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                    NCHAR(0),
                                    N''''''''''''''''
                                )
                        FROM #blocked_requests AS b
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.partitions AS p ON
                            p.hobt_id = b.hobt_id
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.objects AS o ON
                            o.object_id = COALESCE(p.object_id, b.object_id)
                        LEFT OUTER JOIN '''' + QUOTENAME(@database_name) + N''''.sys.schemas AS s ON
                            s.schema_id = COALESCE(o.schema_id, b.schema_id)
                        WHERE
                            b.database_name = @database_name; '''';
                   
                    EXEC sp_executesql
                        @sql_n,
                        N''''@database_name sysname'''',
                        @database_name;
                END TRY
                BEGIN CATCH;
                    UPDATE #blocked_requests
                    SET
                        query_error =
                            REPLACE
                            (
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    CONVERT
                                    (
                                        NVARCHAR(MAX),
                                        ERROR_MESSAGE() COLLATE Latin1_General_Bin2
                                    ),
                                    NCHAR(31),N''''?''''),NCHAR(30),N''''?''''),NCHAR(29),N''''?''''),NCHAR(28),N''''?''''),NCHAR(27),N''''?''''),NCHAR(26),N''''?''''),NCHAR(25),N''''?''''),NCHAR(24),N''''?''''),NCHAR(23),N''''?''''),NCHAR(22),N''''?''''),
                                    NCHAR(21),N''''?''''),NCHAR(20),N''''?''''),NCHAR(19),N''''?''''),NCHAR(18),N''''?''''),NCHAR(17),N''''?''''),NCHAR(16),N''''?''''),NCHAR(15),N''''?''''),NCHAR(14),N''''?''''),NCHAR(12),N''''?''''),
                                    NCHAR(11),N''''?''''),NCHAR(8),N''''?''''),NCHAR(7),N''''?''''),NCHAR(6),N''''?''''),NCHAR(5),N''''?''''),NCHAR(4),N''''?''''),NCHAR(3),N''''?''''),NCHAR(2),N''''?''''),NCHAR(1),N''''?''''),
                                NCHAR(0),
                                N''''''''
                            )
                    WHERE
                        database_name = @database_name;
                END CATCH;

                FETCH NEXT FROM blocks_cursor
                INTO
                    @database_name;
            END;
           
            CLOSE blocks_cursor;
            DEALLOCATE blocks_cursor;
           
            UPDATE s
            SET
                additional_info.modify
                (''''
                    insert <schema_name>{sql:column("b.schema_name")}</schema_name>
                    as last
                    into (/additional_info/block_info)[1]
                '''')
            FROM #sessions AS s
            INNER JOIN #blocked_requests AS b ON
                b.session_id = s.session_id
                AND b.request_id = s.request_id
                AND s.recursion = 1
            WHERE
                b.schema_name IS NOT NULL;

            UPDATE s
            SET
                additional_info.modify
                (''''
                    insert <object_name>{sql:column("b.object_name")}</object_name>
                    as last
                    into (/additional_info/block_info)[1]
                '''')
            FROM #sessions AS s
            INNER JOIN #blocked_requests AS b ON
                b.session_id = s.session_id
                AND b.request_id = s.request_id
                AND s.recursion = 1
            WHERE
                b.object_name IS NOT NULL;

            UPDATE s
            SET
                additional_info.modify
                (''''
                    insert <query_error>{sql:column("b.query_error")}</query_error>
                    as last
                    into (/additional_info/block_info)[1]
                '''')
            FROM #sessions AS s
            INNER JOIN #blocked_requests AS b ON
                b.session_id = s.session_id
                AND b.request_id = s.request_id
                AND s.recursion = 1
            WHERE
                b.query_error IS NOT NULL;
        END;

        IF
            @output_column_list LIKE ''''%|[program_name|]%'''' ESCAPE ''''|''''
            AND @output_column_list LIKE ''''%|[additional_info|]%'''' ESCAPE ''''|''''
            AND @recursion = 1
            AND DB_ID(''''msdb'''') IS NOT NULL
        BEGIN;
            SET @sql_n =
                N''''BEGIN TRY;
                    DECLARE @job_name sysname;
                    SET @job_name = NULL;
                    DECLARE @step_name sysname;
                    SET @step_name = NULL;

                    SELECT
                        @job_name =
                            REPLACE
                            (
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    j.name,
                                    NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                    NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                    NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                NCHAR(0),
                                N''''''''?''''''''
                            ),
                        @step_name =
                            REPLACE
                            (
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
                                    s.step_name,
                                    NCHAR(31),N''''''''?''''''''),NCHAR(30),N''''''''?''''''''),NCHAR(29),N''''''''?''''''''),NCHAR(28),N''''''''?''''''''),NCHAR(27),N''''''''?''''''''),NCHAR(26),N''''''''?''''''''),NCHAR(25),N''''''''?''''''''),NCHAR(24),N''''''''?''''''''),NCHAR(23),N''''''''?''''''''),NCHAR(22),N''''''''?''''''''),
                                    NCHAR(21),N''''''''?''''''''),NCHAR(20),N''''''''?''''''''),NCHAR(19),N''''''''?''''''''),NCHAR(18),N''''''''?''''''''),NCHAR(17),N''''''''?''''''''),NCHAR(16),N''''''''?''''''''),NCHAR(15),N''''''''?''''''''),NCHAR(14),N''''''''?''''''''),NCHAR(12),N''''''''?''''''''),
                                    NCHAR(11),N''''''''?''''''''),NCHAR(8),N''''''''?''''''''),NCHAR(7),N''''''''?''''''''),NCHAR(6),N''''''''?''''''''),NCHAR(5),N''''''''?''''''''),NCHAR(4),N''''''''?''''''''),NCHAR(3),N''''''''?''''''''),NCHAR(2),N''''''''?''''''''),NCHAR(1),N''''''''?''''''''),
                                NCHAR(0),
                                N''''''''?''''''''
                            )
                    FROM msdb.dbo.sysjobs AS j
                    INNER JOIN msdb.dbo.sysjobsteps AS s ON
                        j.job_id = s.job_id
                    WHERE
                        j.job_id = @job_id
                        AND s.step_id = @step_id;

                    IF @job_name IS NOT NULL
                    BEGIN;
                        UPDATE s
                        SET
                            additional_info.modify
                            (''''''''
                                insert text{sql:variable("@job_name")}
                                into (/additional_info/agent_job_info/job_name)[1]
                            '''''''')
                        FROM #sessions AS s
                        WHERE
                            s.session_id = @session_id
                            AND s.recursion = 1
                        OPTION (KEEPFIXED PLAN);
                       
                        UPDATE s
                        SET
                            additional_info.modify
                            (''''''''
                                insert text{sql:variable("@step_name")}
                                into (/additional_info/agent_job_info/step_name)[1]
                            '''''''')
                        FROM #sessions AS s
                        WHERE
                            s.session_id = @session_id
                            AND s.recursion = 1
                        OPTION (KEEPFIXED PLAN);
                    END;
                END TRY
                BEGIN CATCH;
                    DECLARE @msdb_error_message NVARCHAR(256);
                    SET @msdb_error_message = ERROR_MESSAGE();
               
                    UPDATE s
                    SET
                        additional_info.modify
                        (''''''''
                            insert <msdb_query_error>{sql:variable("@msdb_error_message")}</msdb_query_error>
                            as last
                            into (/additional_info/agent_job_info)[1]
                        '''''''')
                    FROM #sessions AS s
                    WHERE
                        s.session_id = @session_id
                        AND s.recursion = 1
                    OPTION (KEEPFIXED PLAN);
                END CATCH;''''

            DECLARE @job_id UNIQUEIDENTIFIER;
            DECLARE @step_id INT;

            DECLARE agent_cursor
            CURSOR LOCAL FAST_FORWARD
            FOR
                SELECT
                    s.session_id,
                    agent_nodes.agent_node.value(''''(job_id/text())[1]'''', ''''uniqueidentifier'''') AS job_id,
                    agent_nodes.agent_node.value(''''(step_id/text())[1]'''', ''''int'''') AS step_id
                FROM #sessions AS s
                CROSS APPLY s.additional_info.nodes(''''//agent_job_info'''') AS agent_nodes (agent_node)
                WHERE
                    s.recursion = 1
            OPTION (KEEPFIXED PLAN);
           
            OPEN agent_cursor;

            FETCH NEXT FROM agent_cursor
            INTO
                @session_id,
                @job_id,
                @step_id;

            WHILE @@FETCH_STATUS = 0
            BEGIN;
                EXEC sp_executesql
                    @sql_n,
                    N''''@job_id UNIQUEIDENTIFIER, @step_id INT, @session_id SMALLINT'''',
                    @job_id, @step_id, @session_id

                FETCH NEXT FROM agent_cursor
                INTO
                    @session_id,
                    @job_id,
                    @step_id;
            END;

            CLOSE agent_cursor;
            DEALLOCATE agent_cursor;
        END;
       
        IF
            @delta_interval > 0
            AND @recursion <> 1
        BEGIN;
            SET @recursion = 1;

            DECLARE @delay_time CHAR(12);
            SET @delay_time = CONVERT(VARCHAR, DATEADD(second, @delta_interval, 0), 114);
            WAITFOR DELAY @delay_time;

            GOTO REDO;
        END;
    END;

    DECLARE
        @num_data_threshold MONEY,
        @num_col_fmt NVARCHAR(MAX),
        @num_delta_col_fmt NVARCHAR(MAX);

    SET @num_data_threshold = 919919919919919;
    SET @num_col_fmt =
        CASE @format_output
            WHEN 1 THEN N''''
                CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, [col_name]))) OVER() - LEN(CONVERT(VARCHAR, [col_name]))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN [col_name] > @num_data_threshold THEN @num_data_threshold ELSE [col_name] END), 1), 19)) AS ''''
            WHEN 2 THEN N''''
                CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN [col_name] > @num_data_threshold THEN @num_data_threshold ELSE [col_name] END), 1), 19)) AS ''''
            ELSE N''''''''
        END + N''''[col_name], '''';
    SET @num_delta_col_fmt =
        N''''
        CASE
            WHEN
                first_request_start_time = last_request_start_time
                AND num_events = 2
                AND [col_name] >= 0
                    THEN '''' +
                    CASE @format_output
                        WHEN 1 THEN N''''CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, [col_name]))) OVER() - LEN(CONVERT(VARCHAR, [col_name]))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN [col_name] > @num_data_threshold THEN @num_data_threshold ELSE [col_name] END), 1), 19)) ''''
                        WHEN 2 THEN N''''CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN [col_name] > @num_data_threshold THEN @num_data_threshold ELSE [col_name] END), 1), 19)) ''''
                        ELSE N''''[col_name] ''''
                    END + N''''
            ELSE NULL
        END AS [col_name], '''';

    SET @sql_n = CONVERT(NVARCHAR(MAX), N'''''''') +
        --Outer column list
        CASE
            WHEN
                @destination_table <> ''''''''
                AND @return_schema = 0
                    THEN N''''INSERT '''' + @destination_table + '''' ''''
            ELSE N''''''''
        END +
        N''''SELECT '''' +
            @output_column_list + N'''' '''' +
        CASE @return_schema
            WHEN 1 THEN N''''INTO #session_schema ''''
            ELSE N''''''''
        END
        --End outer column list
        +
        --Inner column list
        N''''
        FROM
        (
            SELECT
                session_id, '''' +
                --[dd hh:mm:ss.mss]
                CASE
                    WHEN @format_output IN (1, 2) THEN
                        N''''
                        CASE
                            WHEN elapsed_time < 0 THEN
                                RIGHT
                                (
                                    REPLICATE(''''''''0'''''''', max_elapsed_length) + CONVERT(VARCHAR, (-1 * elapsed_time) / 86400),
                                    max_elapsed_length
                                ) +
                                    RIGHT
                                    (
                                        CONVERT(VARCHAR, DATEADD(second, (-1 * elapsed_time), 0), 120),
                                        9
                                    ) +
                                    ''''''''.000''''''''
                            ELSE
                                RIGHT
                                (
                                    REPLICATE(''''''''0'''''''', max_elapsed_length) + CONVERT(VARCHAR, elapsed_time / 86400000),
                                    max_elapsed_length
                                ) +
                                    RIGHT
                                    (
                                        CONVERT(VARCHAR, DATEADD(second, elapsed_time / 1000, 0), 120),
                                        9
                                    ) +
                                    ''''''''.'''''''' +
                                    RIGHT(''''''''000'''''''' + CONVERT(VARCHAR, elapsed_time % 1000), 3)
                        END AS [dd hh:mm:ss.mss], ''''
                    ELSE
                        N''''''''
                END +
                --[dd hh:mm:ss.mss (avg)] / avg_elapsed_time
                CASE
                    WHEN  @format_output IN (1, 2) THEN
                        N''''
                        RIGHT
                        (
                            ''''''''00'''''''' + CONVERT(VARCHAR, avg_elapsed_time / 86400000),
                            2
                        ) +
                            RIGHT
                            (
                                CONVERT(VARCHAR, DATEADD(second, avg_elapsed_time / 1000, 0), 120),
                                9
                            ) +
                            ''''''''.'''''''' +
                            RIGHT(''''''''000'''''''' + CONVERT(VARCHAR, avg_elapsed_time % 1000), 3) AS [dd hh:mm:ss.mss (avg)], ''''
                    ELSE
                        N''''avg_elapsed_time, ''''
                END +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''physical_io'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''reads'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''physical_reads'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''writes'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''tempdb_allocations'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''tempdb_current'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''CPU'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''context_switches'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''used_memory'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''max_used_memory'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''requested_memory'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''granted_memory'''') +
                CASE
                    WHEN @output_column_list LIKE ''''%|_delta|]%'''' ESCAPE ''''|'''' THEN
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''physical_io_delta'''') +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''reads_delta'''') +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''physical_reads_delta'''') +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''writes_delta'''') +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''tempdb_allocations_delta'''') +
                        --this is the only one that can (legitimately) go negative
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''tempdb_current_delta'''') +
                        --CPU_delta
                        --leaving this one hardcoded, as there is a bit of different interaction here
                        N''''
                        CASE
                            WHEN
                                first_request_start_time = last_request_start_time
                                AND num_events = 2
                                    THEN
                                        CASE
                                            WHEN
                                                thread_CPU_delta > CPU_delta
                                                AND thread_CPU_delta > 0
                                                    THEN '''' +
                                                        CASE @format_output
                                                            WHEN 1 THEN N''''CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, thread_CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN thread_CPU_delta > @num_data_threshold THEN @num_data_threshold ELSE thread_CPU_delta END), 1), 19)) ''''
                                                            WHEN 2 THEN N''''CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN thread_CPU_delta > @num_data_threshold THEN @num_data_threshold ELSE thread_CPU_delta END), 1), 19)) ''''
                                                            ELSE N''''thread_CPU_delta ''''
                                                        END + N''''
                                            WHEN CPU_delta >= 0 THEN '''' +
                                                CASE @format_output
                                                    WHEN 1 THEN N''''CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN CPU_delta > @num_data_threshold THEN @num_data_threshold ELSE CPU_delta END), 1), 19)) ''''
                                                    WHEN 2 THEN N''''CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CASE WHEN CPU_delta > @num_data_threshold THEN @num_data_threshold ELSE CPU_delta END), 1), 19)) ''''
                                                    ELSE N''''CPU_delta ''''
                                                END + N''''
                                            ELSE NULL
                                        END
                            ELSE
                                NULL
                        END AS CPU_delta, '''' +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''context_switches_delta'''') +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''used_memory_delta'''') +
                        REPLACE(@num_delta_col_fmt, N''''[col_name]'''', N''''max_used_memory_delta'''')
                    ELSE N''''''''
                END + N''''
                '''' +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''tasks'''') + N''''
                status,
                wait_info,
                locks,
                tran_start_time,
                LEFT(tran_log_writes, LEN(tran_log_writes) - 1) AS tran_log_writes,
                implicit_tran, '''' +
                REPLACE(@num_col_fmt, ''''[col_name]'''', ''''open_tran_count'''') + N''''
                '''' +
                --sql_command
                CASE @format_output
                    WHEN 0 THEN N''''REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_command), ''''''''<?query --''''''''+CHAR(13)+CHAR(10), ''''''''''''''''), CHAR(13)+CHAR(10)+''''''''--?>'''''''', '''''''''''''''') AS ''''
                    ELSE N''''''''
                END + N''''sql_command,
                '''' +
                --sql_text
                CASE @format_output
                    WHEN 0 THEN N''''REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_text), ''''''''<?query --''''''''+CHAR(13)+CHAR(10), ''''''''''''''''), CHAR(13)+CHAR(10)+''''''''--?>'''''''', '''''''''''''''') AS ''''
                    ELSE N''''''''
                END + N''''sql_text,
                query_plan,
                blocking_session_id, '''' +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''blocked_session_count'''') +
                REPLACE(@num_col_fmt, N''''[col_name]'''', N''''percent_complete'''') + N''''
                host_name,
                login_name,
                database_name,
                program_name,
                additional_info,
                memory_info,
                start_time,
                login_time,
                CASE
                    WHEN status = N''''''''sleeping'''''''' THEN NULL
                    ELSE request_id
                END AS request_id,
                GETDATE() AS collection_time ''''
        --End inner column list
        +
        --Derived table and INSERT specification
            N''''
            FROM
            (
                SELECT TOP(2147483647)
                    *,
                    CASE
                        MAX
                        (
                            LEN
                            (
                                CONVERT
                                (
                                    VARCHAR,
                                    CASE
                                        WHEN elapsed_time < 0 THEN
                                            (-1 * elapsed_time) / 86400
                                        ELSE
                                            elapsed_time / 86400000
                                    END
                                )
                            )
                        ) OVER ()
                            WHEN 1 THEN 2
                            ELSE
                                MAX
                                (
                                    LEN
                                    (
                                        CONVERT
                                        (
                                            VARCHAR,
                                            CASE
                                                WHEN elapsed_time < 0 THEN
                                                    (-1 * elapsed_time) / 86400
                                                ELSE
                                                    elapsed_time / 86400000
                                            END
                                        )
                                    )
                                ) OVER ()
                    END AS max_elapsed_length, '''' +
                    CASE
                        WHEN @output_column_list LIKE ''''%|_delta|]%'''' ESCAPE ''''|'''' THEN
                            N''''
                            MAX(physical_io * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(physical_io * recursion) OVER (PARTITION BY session_id, request_id) AS physical_io_delta,
                            MAX(reads * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(reads * recursion) OVER (PARTITION BY session_id, request_id) AS reads_delta,
                            MAX(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) AS physical_reads_delta,
                            MAX(writes * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(writes * recursion) OVER (PARTITION BY session_id, request_id) AS writes_delta,
                            MAX(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_allocations_delta,
                            MAX(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_current_delta,
                            MAX(CPU * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(CPU * recursion) OVER (PARTITION BY session_id, request_id) AS CPU_delta,
                            MAX(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) AS thread_CPU_delta,
                            MAX(context_switches * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(context_switches * recursion) OVER (PARTITION BY session_id, request_id) AS context_switches_delta,
                            MAX(used_memory * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(used_memory * recursion) OVER (PARTITION BY session_id, request_id) AS used_memory_delta,
                            MAX(max_used_memory * recursion) OVER (PARTITION BY session_id, request_id) +
                                MIN(max_used_memory * recursion) OVER (PARTITION BY session_id, request_id) AS max_used_memory_delta,
                            MIN(last_request_start_time) OVER (PARTITION BY session_id, request_id) AS first_request_start_time, ''''
                        ELSE N''''''''
                    END + N''''
                    COUNT(*) OVER (PARTITION BY session_id, request_id) AS num_events
                FROM #sessions AS s1 '''' +
                CASE
                    WHEN @sort_order = '''''''' THEN N''''''''
                    ELSE
                        N''''
                        ORDER BY '''' +
                            CONVERT(NVARCHAR(MAX), @sort_order)
                END +
            N''''
            ) AS s
            WHERE
                s.recursion = 1
        ) x
        OPTION (KEEPFIXED PLAN);
        '''' +
        CASE @return_schema
            WHEN 1 THEN
                N''''
                SET @schema =
                    ''''''''CREATE TABLE <table_name> ( '''''''' +
                        STUFF
                        (
                            (
                                SELECT
                                    '''''''','''''''' +
                                    QUOTENAME(COLUMN_NAME) + '''''''' '''''''' +
                                    DATA_TYPE +
                                    CASE
                                        WHEN DATA_TYPE LIKE ''''''''%char'''''''' THEN ''''''''('''''''' + COALESCE(NULLIF(CONVERT(VARCHAR, CHARACTER_MAXIMUM_LENGTH), ''''''''-1''''''''), ''''''''max'''''''') + '''''''') ''''''''
                                        ELSE '''''''' ''''''''
                                    END +
                                    CASE IS_NULLABLE
                                        WHEN ''''''''NO'''''''' THEN ''''''''NOT ''''''''
                                        ELSE ''''''''''''''''
                                    END + ''''''''NULL'''''''' AS [text()]
                                FROM tempdb.INFORMATION_SCHEMA.COLUMNS
                                WHERE
                                    TABLE_NAME = (SELECT name FROM tempdb.sys.objects WHERE object_id = OBJECT_ID(''''''''tempdb..#session_schema''''''''))
                                    ORDER BY
                                        ORDINAL_POSITION
                                FOR XML
                                    PATH('''''''''''''''')
                            ), +
                            1,
                            1,
                            ''''''''''''''''
                        ) +
                    '''''''');''''''''; ''''
            ELSE N''''''''
        END;
        --End derived table and INSERT specification

    EXEC sp_executesql
        @sql_n,
        N''''@num_data_threshold MONEY, @schema VARCHAR(MAX) OUTPUT'''',
        @num_data_threshold, @schema OUTPUT;
END;
'';
EXEC(@stmt);
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:WhoIsActive-002.sql modified: 2025.08.05 19.13.35
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Set service to be disabled by default
--
BEGIN
	DECLARE @enableWhoIsActive bit;

	SET @enableWhoIsActive = 0;
END;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Installing WhoIsActive-002'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @edition nvarchar(128);
	DECLARE @myUserName nvarchar(128);
	DECLARE @nowUTC datetime;
	DECLARE @nowUTCStr nvarchar(128);
	DECLARE @objectName nvarchar(128);
	DECLARE @objName nvarchar(128);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @productEndPos int;
	DECLARE @productStartPos int;
	DECLARE @productVersion nvarchar(128);
	DECLARE @productVersion1 int;
	DECLARE @productVersion2 int;
	DECLARE @productVersion3 int;
	DECLARE @returnValue int;
	DECLARE @schName nvarchar(128);
	DECLARE @stmt nvarchar(max);
	DECLARE @tableCompressionStmt nvarchar(max);
	DECLARE @version nvarchar(128);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @myUserName = SUSER_NAME();
		SET @nowUTC = SYSUTCDATETIME();
		SET @nowUTCStr = CONVERT(nvarchar(128), @nowUTC, 126);
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
		SET @version = ''2.9.1'';

		SET @productVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS nvarchar);
		SET @productStartPos = 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion1 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion2 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
		SET @productStartPos = @productEndPos + 1;
		SET @productEndPos = CHARINDEX(''.'', @productVersion, @productStartPos);
		SET @productVersion3 = dbo.fhsmFNTryParseAsInt(SUBSTRING(@productVersion, @productStartPos, @productEndPos - @productStartpos));
	END;

	--
	-- Variables used in view to control the statement output
	--
	BEGIN
		DECLARE @maxSQLTextLength int;

		SET @maxSQLTextLength = 1024;
	END;

	--
	-- Check if SQL version allows to use data compression
	--
	BEGIN
		SET @tableCompressionStmt = '''';

		SET @edition = CAST(SERVERPROPERTY(''Edition'') AS nvarchar);

		IF (@edition = ''SQL Azure'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Developer'')
			OR (SUBSTRING(@edition, 1, CHARINDEX('' '', @edition)) = ''Enterprise'')
			OR (@productVersion1 > 13)
			OR ((@productVersion1 = 13) AND (@productVersion2 >= 1))
			OR ((@productVersion1 = 13) AND (@productVersion2 = 0) AND (@productVersion3 >= 4001))
		BEGIN
			SET @tableCompressionStmt = '' WITH (DATA_COMPRESSION = PAGE)'';
		END;
	END;

	--
	-- Create tables
	--
	BEGIN
		--
		-- Create dbo.fhsmWhoIsActive
		--
		IF OBJECT_ID(''dbo.fhsmWhoIsActive'', ''U'') IS NULL
		BEGIN
			RAISERROR(''Creating table dbo.fhsmWhoIsActive'', 0, 1) WITH NOWAIT;

			EXEC dbo.sp_WhoIsActive
				@format_output = 0
				,@get_transaction_info = 1
				,@get_outer_command = 1
				,@get_plans = 1
				,@return_schema = 1
				,@schema = @stmt OUTPUT;

			SET @stmt = REPLACE(@stmt, ''<table_name>'', QUOTENAME(DB_NAME()) + ''.dbo.fhsmWhoIsActive'');
			EXEC(@stmt);
		END;

		--
		-- Create index on dbo.fhsmWhoIsActive
		--
		IF NOT EXISTS (SELECT * FROM sys.indexes AS i WHERE (i.object_id = OBJECT_ID(''dbo.fhsmWhoIsActive'')) AND (i.name = ''CL_fhsmWhoIsActive_collection_time''))
		BEGIN
			SET @stmt = ''
				CREATE CLUSTERED INDEX CL_fhsmWhoIsActive_collection_time ON dbo.fhsmWhoIsActive(collection_time ASC)'' + @tableCompressionStmt + '';
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the table dbo.fhsmWhoIsActive
		--
		BEGIN
			SET @objectName = ''dbo.fhsmWhoIsActive'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Table'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create functions
	--

	--
	-- Create views
	--
	BEGIN
		--
		-- Create fact view @pbiSchema.[Who is active]
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID('''''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Who is active'') + '''''', ''''V'''') IS NULL
				BEGIN
					EXEC(''''CREATE VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Who is active'') + '' AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER VIEW  '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Who is active'') + ''
				AS
				SELECT
					DATEDIFF(SECOND, a.collection_time, lastExecuted.Timestamp) AS SecondsSinceLastSeen
					,a.collection_time AS CollectionTime
					,a.login_time AS LoginTime
					,DATEDIFF(MILLISECOND, a.start_time, a.collection_time) AS ElapsedTimeMS
					,a.session_id AS SessionId
					,CASE
						WHEN LEN(a.sql_text) > '' + CAST(@maxSQLTextLength AS nvarchar) + '' THEN LEFT(a.sql_text, '' + CAST(@maxSQLTextLength AS nvarchar) + '') + CHAR(10) + ''''...Statement truncated''''
						ELSE a.sql_text
					END AS SQLText
					,a.sql_command AS SQLCommand
					,a.login_name AS LoginName
					,a.wait_info AS WaitInfo
					,a.tran_log_writes AS TransLogWrite
					,a.CPU - a.FirstCPU AS CPU
					,a.tempdb_allocations - a.FirstTempdbAllocations AS TempdbAllocations
					,a.blocking_session_id AS BlockingSessionId
					,a.reads - a.FirstReads AS Reads
					,a.writes - a.FirstWrites AS Writes
					,a.physical_reads - a.FirstPhysicalReads AS PhysicalReads
					,a.used_memory AS UsedMemory
					,a.status AS Status
					,a.tran_start_time AS TranStartTime
					,a.implicit_tran AS ImplicitTran
					,a.open_tran_count AS OpenTranCount
					,a.percent_complete AS PercentComplete
					,a.host_name AS HostName
					,a.program_name AS ProgramName
					,ROW_NUMBER() OVER(ORDER BY a.collection_time, (a.reads - a.FirstReads), a.session_id DESC) AS SortOrder
					,(SELECT k.[Key] FROM dbo.fhsmFNGenerateKey(a.database_name, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT) AS k) AS DatabaseKey
				FROM (
					SELECT
						ROW_NUMBER() OVER(PARTITION BY wia.session_id, wia.login_time, wia.start_time ORDER BY wia.collection_time DESC) AS _Rnk_
						,wia.*
						,firstWia.CPU AS FirstCPU
						,firstWia.tempdb_allocations AS FirstTempdbAllocations
						,firstWia.reads AS FirstReads
						,firstWia.writes AS FirstWrites
						,firstWia.physical_reads AS FirstPhysicalReads
					FROM dbo.fhsmWhoIsActive AS wia
					CROSS APPLY (
						SELECT TOP (1)
							fWia.CPU
							,fWia.tempdb_allocations
							,fWia.reads
							,fWia.writes
							,fWia.physical_reads
						FROM dbo.fhsmWhoIsActive AS fWia
						WHERE
							(fWia.session_id = wia.session_id)
							AND (fWia.login_time = wia.login_time)
							AND (fWia.start_time = wia.start_time)
						ORDER BY fWia.collection_time
					) AS firstWia
					WHERE (DATEDIFF(HOUR, wia.collection_time, (SELECT MAX(wia2.collection_time) FROM dbo.fhsmWhoIsActive AS wia2)) < 24)
						AND (wia.sql_text <> ''''sp_server_diagnostics'''')
						AND (wia.sql_text NOT LIKE ''''WAITFOR DELAY %'''')
				) AS a
				CROSS APPLY (
					SELECT TOP 1 l.Timestamp
					FROM dbo.fhsmLog AS l
					WHERE (l.Name = ''''Who is active'''')
					ORDER BY l.TimestampUTC DESC
				) AS lastExecuted
				WHERE (a._Rnk_ = 1);
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on fact view @pbiSchema.[Who is active]
		--
		BEGIN
			SET @objectName = QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''Who is active'');
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''View'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Create stored procedures
	--
	BEGIN
		--
		-- Create stored procedure dbo.fhsmSPWhoIsActive
		--
		BEGIN
			SET @stmt = ''
				IF OBJECT_ID(''''dbo.fhsmSPWhoIsActive'''', ''''P'''') IS NULL
				BEGIN
					EXEC(''''CREATE PROC dbo.fhsmSPWhoIsActive AS SELECT ''''''''dummy'''''''' AS Txt'''');
				END;
			'';
			EXEC(@stmt);

			SET @stmt = ''
				ALTER PROC dbo.fhsmSPWhoIsActive(
					@name nvarchar(128)
					,@version nvarchar(128) OUTPUT
				)
				AS
				BEGIN
					SET NOCOUNT ON;

					DECLARE @parameter nvarchar(max);
					DECLARE @stmt nvarchar(max);
					DECLARE @thisTask nvarchar(128);

					SET @thisTask = OBJECT_NAME(@@PROCID);
					SET @version = '''''' + @version + '''''';

					SET @parameter = dbo.fhsmFNGetTaskParameter(@thisTask, @name);

					SET @stmt = ''''EXEC dbo.sp_WhoIsActive '''' + @parameter;
					EXEC(@stmt);

					RETURN 0;
				END;
			'';
			EXEC(@stmt);
		END;

		--
		-- Register extended properties on the stored procedure dbo.fhsmSPIndexUsage
		--
		BEGIN
			SET @objectName = ''dbo.fhsmSPWhoIsActive'';
			SET @objName = PARSENAME(@objectName, 1);
			SET @schName = PARSENAME(@objectName, 2);

			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMVersion'', @propertyValue = @version;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreated'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 0, @propertyName = ''FHSMCreatedBy'', @propertyValue = @myUserName;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModified'', @propertyValue = @nowUTCStr;
			EXEC dbo.fhsmSPExtendedProperties @objectType = ''Procedure'', @level0name = @schName, @level1name = @objName, @updateIfExists = 1, @propertyName = ''FHSMModifiedBy'', @propertyValue = @myUserName;
		END;
	END;

	--
	-- Register retention
	--
	BEGIN
		WITH
		retention(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter) AS(
			SELECT
				1
				,''dbo.fhsmWhoIsActive''
				,1
				,''collection_time''
				,0
				,7
				,NULL
		)
		MERGE dbo.fhsmRetentions AS tgt
		USING retention AS src ON (src.TableName = tgt.TableName) AND (src.Sequence = tgt.Sequence)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, TableName, Sequence, TimeColumn, IsUtc, Days, Filter)
			VALUES(src.Enabled, src.TableName, src.Sequence, src.TimeColumn, src.IsUtc, src.Days, src.Filter);
	END;

	--
	-- Register schedules
	--
	BEGIN
		WITH
		schedules(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter) AS(
			SELECT
				@enableWhoIsActive								AS Enabled
				,0												AS DeploymentStatus
				,''Who is active''								AS Name
				,PARSENAME(''dbo.fhsmSPWhoIsActive'', 1)			AS Task
				,60												AS ExecutionDelaySec
				,CAST(''1900-1-1T00:00:00.0000'' AS datetime2(0))	AS FromTime
				,CAST(''1900-1-1T23:59:59.0000'' AS datetime2(0))	AS ToTime
				,1, 1, 1, 1, 1, 1, 1							-- Monday..Sunday
				,''@format_output = 0, @get_transaction_info = 1, @get_outer_command = 1, @get_plans = 1, @destination_table = '''''' + QUOTENAME(DB_NAME()) + ''.dbo.fhsmWhoIsActive''''''
		)
		MERGE dbo.fhsmSchedules AS tgt
		USING schedules AS src ON (src.Name = tgt.Name COLLATE SQL_Latin1_General_CP1_CI_AS)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(Enabled, DeploymentStatus, Name, Task, ExecutionDelaySec, FromTime, ToTime, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, Parameter)
			VALUES(src.Enabled, src.DeploymentStatus, src.Name, src.Task, src.ExecutionDelaySec, src.FromTime, src.ToTime, src.Monday, src.Tuesday, src.Wednesday, src.Thursday, src.Friday, src.Saturday, src.Sunday, src.Parameter);
	END;

	--
	-- Register dimensions
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1
			,OutputColumn1
		) AS (
			SELECT
				''Database'' AS DimensionName
				,''DatabaseKey'' AS DimensionKey
				,''dbo.fhsmWhoIsActive'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[collection_time]'' AS SrcDateColumn
				,''src.[database_name]''
				,''Database''
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.OutputColumn1 = src.OutputColumn1
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1
				,OutputColumn1
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1
				,src.OutputColumn1
			);
	END;

	--
	-- Update dimensions based upon the fact tables
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmWhoIsActive'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:_PostInstall-FHSQLMonitor-1.sql modified: 2025.06.12 06.55.08
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Post-installing-1 FHSQLMonitor main'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @msg nvarchar(max);
	DECLARE @pbiSchema nvarchar(128);
	DECLARE @returnValue int;
	DECLARE @stmt nvarchar(max);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Initialize variables
	--
	BEGIN
		SET @pbiSchema = dbo.fhsmFNGetConfiguration(''PBISchema'');
	END;

	--
	-- Delete wrongly named dimension for dbo.fhsmLog
	--
	BEGIN
		DELETE d
		FROM dbo.fhsmDimensions AS d
		WHERE (d.DimensionName = ''LogTaskName'') AND (d.DimensionKey = ''LogTaskNameKey'') AND (d.SrcTable = ''dbo.fhsmLog'');
	END;

	--
	-- Delete wrongly created dimension view pbiSchema.[LogTaskName] if it exists
	--
	BEGIN
		IF OBJECT_ID('''' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''LogTaskName'') + '''', ''V'') IS NOT NULL
		BEGIN
			SET @msg = ''Dropping view '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''LogTaskName'');
			RAISERROR(@msg, 0, 1) WITH NOWAIT;

			SET @stmt = ''DROP VIEW '' + QUOTENAME(@pbiSchema) + ''.'' + QUOTENAME(''LogTaskName'') + '';'';
			EXEC(@stmt);
		END;
	END;

	--
	-- Register dimensions for dbo.fhsmLog
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Task name version'' AS DimensionName
				,''TaskNameVersionKey'' AS DimensionKey
				,''dbo.fhsmLog'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[Timestamp]'' AS SrcDateColumn
				,''src.[Task]'', ''src.[Name]'', ''src.[Version]'', NULL
				,''Task'', ''Name'', ''Version'', NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact table dbo.fhsmLog
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmLog'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:_PostInstall-FHSQLMonitor-2.sql modified: 2025.06.11 17.01.26
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Post-installing-2 FHSQLMonitor main'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @msg nvarchar(max);
	DECLARE @returnValue int;
	DECLARE @stmt nvarchar(max);
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not install as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Register dimensions for dbo.fhsmProcessing
	--
	BEGIN
		WITH
		dimensions(
			DimensionName, DimensionKey
			,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
			,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
			,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
		) AS (
			SELECT
				''Task name version'' AS DimensionName
				,''TaskNameVersionKey'' AS DimensionKey
				,''dbo.fhsmProcessing'' AS SrcTable
				,''src'' AS SrcAlias
				,NULL AS SrcWhere
				,''src.[StartedTimestamp]'' AS SrcDateColumn
				,''src.[Task]'', ''src.[Name]'', ''src.[Version]'', NULL
				,''Task'', ''Name'', ''Version'', NULL
		)
		MERGE dbo.fhsmDimensions AS tgt
		USING dimensions AS src ON (src.DimensionName = tgt.DimensionName) AND (src.SrcTable = tgt.SrcTable)
		WHEN MATCHED
			THEN UPDATE SET
				tgt.DimensionKey = src.DimensionKey
				,tgt.SrcTable = src.SrcTable
				,tgt.SrcAlias = src.SrcAlias
				,tgt.SrcWhere = src.SrcWhere
				,tgt.SrcDateColumn = src.SrcDateColumn
				,tgt.SrcColumn1 = src.SrcColumn1
				,tgt.SrcColumn2 = src.SrcColumn2
				,tgt.SrcColumn3 = src.SrcColumn3
				,tgt.SrcColumn4 = src.SrcColumn4
				,tgt.OutputColumn1 = src.OutputColumn1
				,tgt.OutputColumn2 = src.OutputColumn2
				,tgt.OutputColumn3 = src.OutputColumn3
				,tgt.OutputColumn4 = src.OutputColumn4
		WHEN NOT MATCHED BY TARGET
			THEN INSERT(
				DimensionName, DimensionKey
				,SrcTable, SrcAlias, SrcWhere, SrcDateColumn
				,SrcColumn1, SrcColumn2, SrcColumn3, SrcColumn4
				,OutputColumn1, OutputColumn2, OutputColumn3, OutputColumn4
			)
			VALUES(
				src.DimensionName, src.DimensionKey
				,src.SrcTable, src.SrcAlias, src.SrcWhere, src.SrcDateColumn
				,src.SrcColumn1, src.SrcColumn2, src.SrcColumn3, src.SrcColumn4
				,src.OutputColumn1, src.OutputColumn2, src.OutputColumn3, src.OutputColumn4
			);
	END;

	--
	-- Update dimensions based upon the fact table dbo.fhsmProcessing
	--
	BEGIN
		EXEC dbo.fhsmSPUpdateDimensions @table = ''dbo.fhsmProcessing'';
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- File part:CleanupAfterInstallationAndUpgrade.sql modified: 2025.05.04 17.18.19
--
SET @stmt = '
USE [' + @fhSQLMonitorDatabase + '];
SET NOCOUNT ON;

--
-- Print out start message
--
BEGIN
	RAISERROR('''', 0, 1) WITH NOWAIT;
	RAISERROR(''Cleanup after installation and upgrade'', 0, 1) WITH NOWAIT;
END;

--
-- Declare variables
--
BEGIN
	DECLARE @returnValue int;
END;

--
-- Test if we are in a database with FHSM registered
--
BEGIN
	SET @returnValue = 0;

	IF OBJECT_ID(''dbo.fhsmFNIsValidInstallation'') IS NOT NULL
	BEGIN
		SET @returnValue = dbo.fhsmFNIsValidInstallation();
	END;
END;

IF (@returnValue = 0)
BEGIN
	RAISERROR(''Can not execute as it appears the database is not correct installed'', 0, 1) WITH NOWAIT;
END
ELSE BEGIN
	--
	-- Drop function dbo.fhsmFNSplitLines
	--
	BEGIN
		IF OBJECT_ID(''dbo.fhsmFNSplitLines'', ''FN'') IS NOT NULL
		BEGIN
			IF EXISTS(
				SELECT *
				FROM sys.dm_sql_referencing_entities(''dbo.fhsmFNSplitLines'', ''OBJECT'') AS dsre
			)
			BEGIN
				RAISERROR(''Cannot drop function dbo.fhsmFNSplitLines as it is still in use'', 0, 1) WITH NOWAIT;
			END
			ELSE BEGIN
				RAISERROR(''Dropping function dbo.fhsmFNSplitLines'', 0, 1) WITH NOWAIT;

				EXEC(''DROP FUNCTION dbo.fhsmFNSplitLines;'');
			END;
		END;
	END;

	--
	-- Drop function dbo.fhsmSplitLines
	--
	BEGIN
		IF OBJECT_ID(''dbo.fhsmSplitLines'', ''FN'') IS NOT NULL
		BEGIN
			IF EXISTS(
				SELECT *
				FROM sys.dm_sql_referencing_entities(''dbo.fhsmSplitLines'', ''OBJECT'') AS dsre
			)
			BEGIN
				RAISERROR(''Cannot drop function dbo.fhsmSplitLines as it is still in use'', 0, 1) WITH NOWAIT;
			END
			ELSE BEGIN
				RAISERROR(''Dropping function dbo.fhsmSplitLines'', 0, 1) WITH NOWAIT;

				EXEC(''DROP FUNCTION dbo.fhsmSplitLines;'');
			END;
		END;
	END;
END;

';
SET @stmt = REPLACE(@stmt, 'SET @blocksAndDeadlocksFilePath = NULL;', 'SET @blocksAndDeadlocksFilePath = ' + COALESCE('''' + CAST(@blocksAndDeadlocksFilePath AS nvarchar) + '''', 'NULL') + ';');
SET @stmt = REPLACE(@stmt, 'SET @olaDatabase = NULL;', 'SET @olaDatabase = ' + COALESCE('''' + CAST(@olaDatabase AS nvarchar) + '''', 'NULL') + ';');

SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobs = 0;',                'SET @enableAgentJobs = '                + CAST(@enableAgentJobs AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgentJobsPerformance = 0;',     'SET @enableAgentJobsPerformance = '     + CAST(@enableAgentJobsPerformance AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableAgeOfStatistics = 0;',          'SET @enableAgeOfStatistics = '          + CAST(@enableAgeOfStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBackupStatus = 0;',             'SET @enableBackupStatus = '             + CAST(@enableBackupStatus AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableBlocksAndDeadlocks = 0;',       'SET @enableBlocksAndDeadlocks = '       + CAST(@enableBlocksAndDeadlocks AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCapacity = 0;',                 'SET @enableCapacity = '                 + CAST(@enableCapacity AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableConnections = 0;',              'SET @enableConnections = '              + CAST(@enableConnections AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableCPUUtilization = 0;',           'SET @enableCPUUtilization = '           + CAST(@enableCPUUtilization AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseIO = 0;',               'SET @enableDatabaseIO = '               + CAST(@enableDatabaseIO AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableDatabaseState = 0;',            'SET @enableDatabaseState = '            + CAST(@enableDatabaseState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexOperational = 0;',         'SET @enableIndexOperational = '         + CAST(@enableIndexOperational AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexPhysical = 0;',            'SET @enableIndexPhysical = '            + CAST(@enableIndexPhysical AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexUsage = 0;',               'SET @enableIndexUsage = '               + CAST(@enableIndexUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableInstanceState = 0;',            'SET @enableInstanceState = '            + CAST(@enableInstanceState AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableMissingIndexes = 0;',           'SET @enableMissingIndexes = '           + CAST(@enableMissingIndexes AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePerformanceStatistics = 0;',    'SET @enablePerformanceStatistics = '    + CAST(@enablePerformanceStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanCacheUsage = 0;',           'SET @enablePlanCacheUsage = '           + CAST(@enablePlanCacheUsage AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enablePlanGuides = 0;',               'SET @enablePlanGuides = '               + CAST(@enablePlanGuides AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableQueryStatistics = 0;',          'SET @enableQueryStatistics = '          + CAST(@enableQueryStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableTriggers = 0;',                 'SET @enableTriggers = '                 + CAST(@enableTriggers AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWaitStatistics = 0;',           'SET @enableWaitStatistics = '           + CAST(@enableWaitStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableWhoIsActive = 0;',              'SET @enableWhoIsActive = '              + CAST(@enableWhoIsActive AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexRebuild = 0;',             'SET @enableIndexRebuild = '             + CAST(@enableIndexRebuild AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableIndexReorganize = 0;',          'SET @enableIndexReorganize = '          + CAST(@enableIndexReorganize AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateAllStatistics = 0;',      'SET @enableUpdateAllStatistics = '      + CAST(@enableUpdateAllStatistics AS nvarchar) + ';');
SET @stmt = REPLACE(@stmt, 'SET @enableUpdateModifiedStatistics = 0;', 'SET @enableUpdateModifiedStatistics = ' + CAST(@enableUpdateModifiedStatistics AS nvarchar) + ';');
EXEC(@stmt);

--
-- Enable job again if it was enabled when we started
--
IF (@installationJobStatus = 1)
BEGIN
	RAISERROR('', 0, 1) WITH NOWAIT;
	SET @installationMsg = 'Enabling job ' + QUOTENAME(@fhsqlAgentJobName);
	RAISERROR(@installationMsg, 0, 1) WITH NOWAIT;

	EXEC msdb.dbo.sp_update_job
		@job_name = @fhsqlAgentJobName,
		@enabled = 1;
END;

RAISERROR('', 0, 1) WITH NOWAIT;
SET @installationMsg = 'FHSQLMonitor in database ' + @fhSQLMonitorDatabase + ' on ' + @serverInfo + ' has been ' + CASE @installUpgradeFlag WHEN 1 THEN 'installed with' ELSE 'upgraded to' END + ' v2.9.1';
RAISERROR(@installationMsg, 0, 1) WITH NOWAIT;
